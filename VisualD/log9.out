Program 1
{
	Stack: [{procedure[forkBody[v, latch]->{wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}], {Ref(int) v1, {Ref(int) v2, {Ref(int) v3, {int cnt, {new(v1,2), {new(v2,3), {new(v3,4), {newLatch(cnt, rH(v2)), {fork({call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}}}}}}}}}]
	Symbol Table: {}
	Output: []
	File table: {}
	Heap: {}
	Procedures: null
	Lock table: null
	Barrier table: null
	Latch table: null
	Count Semaphore table: null
};
Program 1
{
	Stack: [procedure[forkBody[v, latch]->{wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}], {Ref(int) v1, {Ref(int) v2, {Ref(int) v3, {int cnt, {new(v1,2), {new(v2,3), {new(v3,4), {newLatch(cnt, rH(v2)), {fork({call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}}}}}}}}]
	Symbol Table: {}
	Output: []
	File table: {}
	Heap: {}
	Procedures: null
	Lock table: null
	Barrier table: null
	Latch table: null
	Count Semaphore table: null
};
Program 1
{
	Stack: [procedure[forkBody[v, latch]->{wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}], {Ref(int) v1, {Ref(int) v2, {Ref(int) v3, {int cnt, {new(v1,2), {new(v2,3), {new(v3,4), {newLatch(cnt, rH(v2)), {fork({call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}}}}}}}}]
	Symbol Table: {}
	Output: []
	File table: {}
	Heap: {}
	Procedures: null
	Lock table: null
	Barrier table: null
	Latch table: null
	Count Semaphore table: null
};
Program 1
{
	Stack: [{Ref(int) v1, {Ref(int) v2, {Ref(int) v3, {int cnt, {new(v1,2), {new(v2,3), {new(v3,4), {newLatch(cnt, rH(v2)), {fork({call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}}}}}}}}]
	Symbol Table: {}
	Output: []
	File table: {}
	Heap: {}
	Procedures: null
	Lock table: null
	Barrier table: null
	Latch table: null
	Count Semaphore table: null
};
Program 1
{
	Stack: [Ref(int) v1, {Ref(int) v2, {Ref(int) v3, {int cnt, {new(v1,2), {new(v2,3), {new(v3,4), {newLatch(cnt, rH(v2)), {fork({call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}}}}}}}]
	Symbol Table: {}
	Output: []
	File table: {}
	Heap: {}
	Procedures: null
	Lock table: null
	Barrier table: null
	Latch table: null
	Count Semaphore table: null
};
Program 1
{
	Stack: [Ref(int) v1, {Ref(int) v2, {Ref(int) v3, {int cnt, {new(v1,2), {new(v2,3), {new(v3,4), {newLatch(cnt, rH(v2)), {fork({call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}}}}}}}]
	Symbol Table: {}
	Output: []
	File table: {}
	Heap: {}
	Procedures: null
	Lock table: null
	Barrier table: null
	Latch table: null
	Count Semaphore table: null
};
Program 1
{
	Stack: [{Ref(int) v2, {Ref(int) v3, {int cnt, {new(v1,2), {new(v2,3), {new(v3,4), {newLatch(cnt, rH(v2)), {fork({call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}}}}}}}]
	Symbol Table: {v1=RefValue(0, int)}
	Output: []
	File table: {}
	Heap: {}
	Procedures: null
	Lock table: null
	Barrier table: null
	Latch table: null
	Count Semaphore table: null
};
Program 1
{
	Stack: [{Ref(int) v2, {Ref(int) v3, {int cnt, {new(v1,2), {new(v2,3), {new(v3,4), {newLatch(cnt, rH(v2)), {fork({call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}}}}}}}]
	Symbol Table: {v1=RefValue(0, int)}
	Output: []
	File table: {}
	Heap: {}
	Procedures: null
	Lock table: null
	Barrier table: null
	Latch table: null
	Count Semaphore table: null
};
Program 1
{
	Stack: [Ref(int) v2, {Ref(int) v3, {int cnt, {new(v1,2), {new(v2,3), {new(v3,4), {newLatch(cnt, rH(v2)), {fork({call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}}}}}}]
	Symbol Table: {v1=RefValue(0, int)}
	Output: []
	File table: {}
	Heap: {}
	Procedures: null
	Lock table: null
	Barrier table: null
	Latch table: null
	Count Semaphore table: null
};
Program 1
{
	Stack: [Ref(int) v2, {Ref(int) v3, {int cnt, {new(v1,2), {new(v2,3), {new(v3,4), {newLatch(cnt, rH(v2)), {fork({call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}}}}}}]
	Symbol Table: {v1=RefValue(0, int)}
	Output: []
	File table: {}
	Heap: {}
	Procedures: null
	Lock table: null
	Barrier table: null
	Latch table: null
	Count Semaphore table: null
};
Program 1
{
	Stack: [{Ref(int) v3, {int cnt, {new(v1,2), {new(v2,3), {new(v3,4), {newLatch(cnt, rH(v2)), {fork({call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}}}}}}]
	Symbol Table: {v1=RefValue(0, int), v2=RefValue(0, int)}
	Output: []
	File table: {}
	Heap: {}
	Procedures: null
	Lock table: null
	Barrier table: null
	Latch table: null
	Count Semaphore table: null
};
Program 1
{
	Stack: [{Ref(int) v3, {int cnt, {new(v1,2), {new(v2,3), {new(v3,4), {newLatch(cnt, rH(v2)), {fork({call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}}}}}}]
	Symbol Table: {v1=RefValue(0, int), v2=RefValue(0, int)}
	Output: []
	File table: {}
	Heap: {}
	Procedures: null
	Lock table: null
	Barrier table: null
	Latch table: null
	Count Semaphore table: null
};
Program 1
{
	Stack: [Ref(int) v3, {int cnt, {new(v1,2), {new(v2,3), {new(v3,4), {newLatch(cnt, rH(v2)), {fork({call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}}}}}]
	Symbol Table: {v1=RefValue(0, int), v2=RefValue(0, int)}
	Output: []
	File table: {}
	Heap: {}
	Procedures: null
	Lock table: null
	Barrier table: null
	Latch table: null
	Count Semaphore table: null
};
Program 1
{
	Stack: [Ref(int) v3, {int cnt, {new(v1,2), {new(v2,3), {new(v3,4), {newLatch(cnt, rH(v2)), {fork({call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}}}}}]
	Symbol Table: {v1=RefValue(0, int), v2=RefValue(0, int)}
	Output: []
	File table: {}
	Heap: {}
	Procedures: null
	Lock table: null
	Barrier table: null
	Latch table: null
	Count Semaphore table: null
};
Program 1
{
	Stack: [{int cnt, {new(v1,2), {new(v2,3), {new(v3,4), {newLatch(cnt, rH(v2)), {fork({call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}}}}}]
	Symbol Table: {v1=RefValue(0, int), v2=RefValue(0, int), v3=RefValue(0, int)}
	Output: []
	File table: {}
	Heap: {}
	Procedures: null
	Lock table: null
	Barrier table: null
	Latch table: null
	Count Semaphore table: null
};
Program 1
{
	Stack: [{int cnt, {new(v1,2), {new(v2,3), {new(v3,4), {newLatch(cnt, rH(v2)), {fork({call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}}}}}]
	Symbol Table: {v1=RefValue(0, int), v2=RefValue(0, int), v3=RefValue(0, int)}
	Output: []
	File table: {}
	Heap: {}
	Procedures: null
	Lock table: null
	Barrier table: null
	Latch table: null
	Count Semaphore table: null
};
Program 1
{
	Stack: [int cnt, {new(v1,2), {new(v2,3), {new(v3,4), {newLatch(cnt, rH(v2)), {fork({call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}}}}]
	Symbol Table: {v1=RefValue(0, int), v2=RefValue(0, int), v3=RefValue(0, int)}
	Output: []
	File table: {}
	Heap: {}
	Procedures: null
	Lock table: null
	Barrier table: null
	Latch table: null
	Count Semaphore table: null
};
Program 1
{
	Stack: [int cnt, {new(v1,2), {new(v2,3), {new(v3,4), {newLatch(cnt, rH(v2)), {fork({call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}}}}]
	Symbol Table: {v1=RefValue(0, int), v2=RefValue(0, int), v3=RefValue(0, int)}
	Output: []
	File table: {}
	Heap: {}
	Procedures: null
	Lock table: null
	Barrier table: null
	Latch table: null
	Count Semaphore table: null
};
Program 1
{
	Stack: [{new(v1,2), {new(v2,3), {new(v3,4), {newLatch(cnt, rH(v2)), {fork({call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}}}}]
	Symbol Table: {cnt=0, v1=RefValue(0, int), v2=RefValue(0, int), v3=RefValue(0, int)}
	Output: []
	File table: {}
	Heap: {}
	Procedures: null
	Lock table: null
	Barrier table: null
	Latch table: null
	Count Semaphore table: null
};
Program 1
{
	Stack: [{new(v1,2), {new(v2,3), {new(v3,4), {newLatch(cnt, rH(v2)), {fork({call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}}}}]
	Symbol Table: {cnt=0, v1=RefValue(0, int), v2=RefValue(0, int), v3=RefValue(0, int)}
	Output: []
	File table: {}
	Heap: {}
	Procedures: null
	Lock table: null
	Barrier table: null
	Latch table: null
	Count Semaphore table: null
};
Program 1
{
	Stack: [new(v1,2), {new(v2,3), {new(v3,4), {newLatch(cnt, rH(v2)), {fork({call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}}}]
	Symbol Table: {cnt=0, v1=RefValue(0, int), v2=RefValue(0, int), v3=RefValue(0, int)}
	Output: []
	File table: {}
	Heap: {}
	Procedures: null
	Lock table: null
	Barrier table: null
	Latch table: null
	Count Semaphore table: null
};
Program 1
{
	Stack: [new(v1,2), {new(v2,3), {new(v3,4), {newLatch(cnt, rH(v2)), {fork({call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}}}]
	Symbol Table: {cnt=0, v1=RefValue(0, int), v2=RefValue(0, int), v3=RefValue(0, int)}
	Output: []
	File table: {}
	Heap: {}
	Procedures: null
	Lock table: null
	Barrier table: null
	Latch table: null
	Count Semaphore table: null
};
Program 1
{
	Stack: [{new(v2,3), {new(v3,4), {newLatch(cnt, rH(v2)), {fork({call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}}}]
	Symbol Table: {cnt=0, v1=RefValue(1, int), v2=RefValue(0, int), v3=RefValue(0, int)}
	Output: []
	File table: {}
	Heap: {1=2}
	Procedures: null
	Lock table: null
	Barrier table: null
	Latch table: null
	Count Semaphore table: null
};
Program 1
{
	Stack: [{new(v2,3), {new(v3,4), {newLatch(cnt, rH(v2)), {fork({call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}}}]
	Symbol Table: {cnt=0, v1=RefValue(1, int), v2=RefValue(0, int), v3=RefValue(0, int)}
	Output: []
	File table: {}
	Heap: {1=2}
	Procedures: null
	Lock table: null
	Barrier table: null
	Latch table: null
	Count Semaphore table: null
};
Program 1
{
	Stack: [new(v2,3), {new(v3,4), {newLatch(cnt, rH(v2)), {fork({call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}}]
	Symbol Table: {cnt=0, v1=RefValue(1, int), v2=RefValue(0, int), v3=RefValue(0, int)}
	Output: []
	File table: {}
	Heap: {1=2}
	Procedures: null
	Lock table: null
	Barrier table: null
	Latch table: null
	Count Semaphore table: null
};
Program 1
{
	Stack: [new(v2,3), {new(v3,4), {newLatch(cnt, rH(v2)), {fork({call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}}]
	Symbol Table: {cnt=0, v1=RefValue(1, int), v2=RefValue(0, int), v3=RefValue(0, int)}
	Output: []
	File table: {}
	Heap: {1=2}
	Procedures: null
	Lock table: null
	Barrier table: null
	Latch table: null
	Count Semaphore table: null
};
Program 1
{
	Stack: [{new(v3,4), {newLatch(cnt, rH(v2)), {fork({call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}}]
	Symbol Table: {cnt=0, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(0, int)}
	Output: []
	File table: {}
	Heap: {1=2, 2=3}
	Procedures: null
	Lock table: null
	Barrier table: null
	Latch table: null
	Count Semaphore table: null
};
Program 1
{
	Stack: [{new(v3,4), {newLatch(cnt, rH(v2)), {fork({call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}}]
	Symbol Table: {cnt=0, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(0, int)}
	Output: []
	File table: {}
	Heap: {1=2, 2=3}
	Procedures: null
	Lock table: null
	Barrier table: null
	Latch table: null
	Count Semaphore table: null
};
Program 1
{
	Stack: [new(v3,4), {newLatch(cnt, rH(v2)), {fork({call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}]
	Symbol Table: {cnt=0, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(0, int)}
	Output: []
	File table: {}
	Heap: {1=2, 2=3}
	Procedures: null
	Lock table: null
	Barrier table: null
	Latch table: null
	Count Semaphore table: null
};
Program 1
{
	Stack: [new(v3,4), {newLatch(cnt, rH(v2)), {fork({call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}]
	Symbol Table: {cnt=0, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(0, int)}
	Output: []
	File table: {}
	Heap: {1=2, 2=3}
	Procedures: null
	Lock table: null
	Barrier table: null
	Latch table: null
	Count Semaphore table: null
};
Program 1
{
	Stack: [{newLatch(cnt, rH(v2)), {fork({call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}]
	Symbol Table: {cnt=0, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: []
	File table: {}
	Heap: {1=2, 2=3, 3=4}
	Procedures: null
	Lock table: null
	Barrier table: null
	Latch table: null
	Count Semaphore table: null
};
Program 1
{
	Stack: [{newLatch(cnt, rH(v2)), {fork({call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}]
	Symbol Table: {cnt=0, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: []
	File table: {}
	Heap: {1=2, 2=3, 3=4}
	Procedures: null
	Lock table: null
	Barrier table: null
	Latch table: null
	Count Semaphore table: null
};
Program 1
{
	Stack: [newLatch(cnt, rH(v2)), {fork({call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}]
	Symbol Table: {cnt=0, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: []
	File table: {}
	Heap: {1=2, 2=3, 3=4}
	Procedures: null
	Lock table: null
	Barrier table: null
	Latch table: null
	Count Semaphore table: null
};
Program 1
{
	Stack: [newLatch(cnt, rH(v2)), {fork({call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}]
	Symbol Table: {cnt=0, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: []
	File table: {}
	Heap: {1=2, 2=3, 3=4}
	Procedures: null
	Lock table: null
	Barrier table: null
	Latch table: null
	Count Semaphore table: null
};
Program 1
{
	Stack: [{fork({call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}]
	Symbol Table: {cnt=0, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: []
	File table: {}
	Heap: {1=2, 2=3, 3=4}
	Procedures: null
	Lock table: null
	Barrier table: null
	Latch table: null
	Count Semaphore table: null
};
Program 1
{
	Stack: [fork({call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}]
	Symbol Table: {cnt=0, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: []
	File table: {}
	Heap: {1=2, 2=3, 3=4}
	Procedures: null
	Lock table: null
	Barrier table: null
	Latch table: null
	Count Semaphore table: null
};
Program 1
{
	Stack: [fork({call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}]
	Symbol Table: {cnt=0, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: []
	File table: {}
	Heap: {1=2, 2=3, 3=4}
	Procedures: null
	Lock table: null
	Barrier table: null
	Latch table: null
	Count Semaphore table: null
};
Program 1
{
	Stack: [{await(cnt), {print(100), {countDown(cnt), print(100)}}}]
	Symbol Table: {cnt=0, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: []
	File table: {}
	Heap: {1=2, 2=3, 3=4}
	Procedures: null
	Lock table: null
	Barrier table: null
	Latch table: null
	Count Semaphore table: null
};
Program 2
{
	Stack: [{call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})}]
	Symbol Table: {cnt=0, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: []
	File table: {}
	Heap: {1=2, 2=3, 3=4}
	Procedures: null
	Lock table: null
	Barrier table: null
	Latch table: null
	Count Semaphore table: null
};
Program 1
{
	Stack: [{await(cnt), {print(100), {countDown(cnt), print(100)}}}]
	Symbol Table: {cnt=0, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: []
	File table: {}
	Heap: {1=2, 2=3, 3=4}
	Procedures: null
	Lock table: null
	Barrier table: null
	Latch table: null
	Count Semaphore table: null
};
Program 2
{
	Stack: [{call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})}]
	Symbol Table: {cnt=0, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: []
	File table: {}
	Heap: {1=2, 2=3, 3=4}
	Procedures: null
	Lock table: null
	Barrier table: null
	Latch table: null
	Count Semaphore table: null
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=0, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: []
	File table: {}
	Heap: {1=2, 2=3, 3=4}
	Procedures: null
	Lock table: null
	Barrier table: null
	Latch table: null
	Count Semaphore table: null
};
Program 2
{
	Stack: [call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})]
	Symbol Table: {cnt=0, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: []
	File table: {}
	Heap: {1=2, 2=3, 3=4}
	Procedures: null
	Lock table: null
	Barrier table: null
	Latch table: null
	Count Semaphore table: null
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=0, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: []
	File table: {}
	Heap: {1=2, 2=3, 3=4}
	Procedures: null
	Lock table: null
	Barrier table: null
	Latch table: null
	Count Semaphore table: null
};
Program 2
{
	Stack: [call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})]
	Symbol Table: {cnt=0, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: []
	File table: {}
	Heap: {1=2, 2=3, 3=4}
	Procedures: null
	Lock table: null
	Barrier table: null
	Latch table: null
	Count Semaphore table: null
};
Program 4
{
	Stack: [{procedure[forkBody[v, latch]->{wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}], {Ref(int) v1, {Ref(int) v2, {Ref(int) v3, {int cnt, {new(v1,2), {new(v2,3), {new(v3,4), {newLatch(cnt, rH(v2)), {fork({call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}}}}}}}}}]
	Symbol Table: {}
	Output: []
	File table: {}
	Heap: {}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 4
{
	Stack: [procedure[forkBody[v, latch]->{wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}], {Ref(int) v1, {Ref(int) v2, {Ref(int) v3, {int cnt, {new(v1,2), {new(v2,3), {new(v3,4), {newLatch(cnt, rH(v2)), {fork({call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}}}}}}}}]
	Symbol Table: {}
	Output: []
	File table: {}
	Heap: {}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 4
{
	Stack: [procedure[forkBody[v, latch]->{wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}], {Ref(int) v1, {Ref(int) v2, {Ref(int) v3, {int cnt, {new(v1,2), {new(v2,3), {new(v3,4), {newLatch(cnt, rH(v2)), {fork({call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}}}}}}}}]
	Symbol Table: {}
	Output: []
	File table: {}
	Heap: {}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 4
{
	Stack: [{Ref(int) v1, {Ref(int) v2, {Ref(int) v3, {int cnt, {new(v1,2), {new(v2,3), {new(v3,4), {newLatch(cnt, rH(v2)), {fork({call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}}}}}}}}]
	Symbol Table: {}
	Output: []
	File table: {}
	Heap: {}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 4
{
	Stack: [{Ref(int) v1, {Ref(int) v2, {Ref(int) v3, {int cnt, {new(v1,2), {new(v2,3), {new(v3,4), {newLatch(cnt, rH(v2)), {fork({call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}}}}}}}}]
	Symbol Table: {}
	Output: []
	File table: {}
	Heap: {}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 4
{
	Stack: [Ref(int) v1, {Ref(int) v2, {Ref(int) v3, {int cnt, {new(v1,2), {new(v2,3), {new(v3,4), {newLatch(cnt, rH(v2)), {fork({call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}}}}}}}]
	Symbol Table: {}
	Output: []
	File table: {}
	Heap: {}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 4
{
	Stack: [Ref(int) v1, {Ref(int) v2, {Ref(int) v3, {int cnt, {new(v1,2), {new(v2,3), {new(v3,4), {newLatch(cnt, rH(v2)), {fork({call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}}}}}}}]
	Symbol Table: {}
	Output: []
	File table: {}
	Heap: {}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 4
{
	Stack: [{Ref(int) v2, {Ref(int) v3, {int cnt, {new(v1,2), {new(v2,3), {new(v3,4), {newLatch(cnt, rH(v2)), {fork({call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}}}}}}}]
	Symbol Table: {v1=RefValue(0, int)}
	Output: []
	File table: {}
	Heap: {}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 4
{
	Stack: [{Ref(int) v2, {Ref(int) v3, {int cnt, {new(v1,2), {new(v2,3), {new(v3,4), {newLatch(cnt, rH(v2)), {fork({call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}}}}}}}]
	Symbol Table: {v1=RefValue(0, int)}
	Output: []
	File table: {}
	Heap: {}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 4
{
	Stack: [Ref(int) v2, {Ref(int) v3, {int cnt, {new(v1,2), {new(v2,3), {new(v3,4), {newLatch(cnt, rH(v2)), {fork({call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}}}}}}]
	Symbol Table: {v1=RefValue(0, int)}
	Output: []
	File table: {}
	Heap: {}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 4
{
	Stack: [Ref(int) v2, {Ref(int) v3, {int cnt, {new(v1,2), {new(v2,3), {new(v3,4), {newLatch(cnt, rH(v2)), {fork({call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}}}}}}]
	Symbol Table: {v1=RefValue(0, int)}
	Output: []
	File table: {}
	Heap: {}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 4
{
	Stack: [{Ref(int) v3, {int cnt, {new(v1,2), {new(v2,3), {new(v3,4), {newLatch(cnt, rH(v2)), {fork({call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}}}}}}]
	Symbol Table: {v1=RefValue(0, int), v2=RefValue(0, int)}
	Output: []
	File table: {}
	Heap: {}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 4
{
	Stack: [{Ref(int) v3, {int cnt, {new(v1,2), {new(v2,3), {new(v3,4), {newLatch(cnt, rH(v2)), {fork({call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}}}}}}]
	Symbol Table: {v1=RefValue(0, int), v2=RefValue(0, int)}
	Output: []
	File table: {}
	Heap: {}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 4
{
	Stack: [Ref(int) v3, {int cnt, {new(v1,2), {new(v2,3), {new(v3,4), {newLatch(cnt, rH(v2)), {fork({call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}}}}}]
	Symbol Table: {v1=RefValue(0, int), v2=RefValue(0, int)}
	Output: []
	File table: {}
	Heap: {}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 4
{
	Stack: [Ref(int) v3, {int cnt, {new(v1,2), {new(v2,3), {new(v3,4), {newLatch(cnt, rH(v2)), {fork({call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}}}}}]
	Symbol Table: {v1=RefValue(0, int), v2=RefValue(0, int)}
	Output: []
	File table: {}
	Heap: {}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 4
{
	Stack: [{int cnt, {new(v1,2), {new(v2,3), {new(v3,4), {newLatch(cnt, rH(v2)), {fork({call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}}}}}]
	Symbol Table: {v1=RefValue(0, int), v2=RefValue(0, int), v3=RefValue(0, int)}
	Output: []
	File table: {}
	Heap: {}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 4
{
	Stack: [{int cnt, {new(v1,2), {new(v2,3), {new(v3,4), {newLatch(cnt, rH(v2)), {fork({call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}}}}}]
	Symbol Table: {v1=RefValue(0, int), v2=RefValue(0, int), v3=RefValue(0, int)}
	Output: []
	File table: {}
	Heap: {}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 4
{
	Stack: [int cnt, {new(v1,2), {new(v2,3), {new(v3,4), {newLatch(cnt, rH(v2)), {fork({call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}}}}]
	Symbol Table: {v1=RefValue(0, int), v2=RefValue(0, int), v3=RefValue(0, int)}
	Output: []
	File table: {}
	Heap: {}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 4
{
	Stack: [int cnt, {new(v1,2), {new(v2,3), {new(v3,4), {newLatch(cnt, rH(v2)), {fork({call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}}}}]
	Symbol Table: {v1=RefValue(0, int), v2=RefValue(0, int), v3=RefValue(0, int)}
	Output: []
	File table: {}
	Heap: {}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 4
{
	Stack: [{new(v1,2), {new(v2,3), {new(v3,4), {newLatch(cnt, rH(v2)), {fork({call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}}}}]
	Symbol Table: {cnt=0, v1=RefValue(0, int), v2=RefValue(0, int), v3=RefValue(0, int)}
	Output: []
	File table: {}
	Heap: {}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 4
{
	Stack: [{new(v1,2), {new(v2,3), {new(v3,4), {newLatch(cnt, rH(v2)), {fork({call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}}}}]
	Symbol Table: {cnt=0, v1=RefValue(0, int), v2=RefValue(0, int), v3=RefValue(0, int)}
	Output: []
	File table: {}
	Heap: {}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 4
{
	Stack: [new(v1,2), {new(v2,3), {new(v3,4), {newLatch(cnt, rH(v2)), {fork({call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}}}]
	Symbol Table: {cnt=0, v1=RefValue(0, int), v2=RefValue(0, int), v3=RefValue(0, int)}
	Output: []
	File table: {}
	Heap: {}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 4
{
	Stack: [new(v1,2), {new(v2,3), {new(v3,4), {newLatch(cnt, rH(v2)), {fork({call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}}}]
	Symbol Table: {cnt=0, v1=RefValue(0, int), v2=RefValue(0, int), v3=RefValue(0, int)}
	Output: []
	File table: {}
	Heap: {}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 4
{
	Stack: [{new(v2,3), {new(v3,4), {newLatch(cnt, rH(v2)), {fork({call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}}}]
	Symbol Table: {cnt=0, v1=RefValue(2, int), v2=RefValue(0, int), v3=RefValue(0, int)}
	Output: []
	File table: {}
	Heap: {2=2}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 4
{
	Stack: [{new(v2,3), {new(v3,4), {newLatch(cnt, rH(v2)), {fork({call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}}}]
	Symbol Table: {cnt=0, v1=RefValue(2, int), v2=RefValue(0, int), v3=RefValue(0, int)}
	Output: []
	File table: {}
	Heap: {2=2}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 4
{
	Stack: [new(v2,3), {new(v3,4), {newLatch(cnt, rH(v2)), {fork({call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}}]
	Symbol Table: {cnt=0, v1=RefValue(2, int), v2=RefValue(0, int), v3=RefValue(0, int)}
	Output: []
	File table: {}
	Heap: {2=2}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 4
{
	Stack: [new(v2,3), {new(v3,4), {newLatch(cnt, rH(v2)), {fork({call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}}]
	Symbol Table: {cnt=0, v1=RefValue(2, int), v2=RefValue(0, int), v3=RefValue(0, int)}
	Output: []
	File table: {}
	Heap: {2=2}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 4
{
	Stack: [{new(v3,4), {newLatch(cnt, rH(v2)), {fork({call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}}]
	Symbol Table: {cnt=0, v1=RefValue(2, int), v2=RefValue(3, int), v3=RefValue(0, int)}
	Output: []
	File table: {}
	Heap: {2=2, 3=3}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 4
{
	Stack: [{new(v3,4), {newLatch(cnt, rH(v2)), {fork({call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}}]
	Symbol Table: {cnt=0, v1=RefValue(2, int), v2=RefValue(3, int), v3=RefValue(0, int)}
	Output: []
	File table: {}
	Heap: {2=2, 3=3}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 4
{
	Stack: [new(v3,4), {newLatch(cnt, rH(v2)), {fork({call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}]
	Symbol Table: {cnt=0, v1=RefValue(2, int), v2=RefValue(3, int), v3=RefValue(0, int)}
	Output: []
	File table: {}
	Heap: {2=2, 3=3}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 4
{
	Stack: [new(v3,4), {newLatch(cnt, rH(v2)), {fork({call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}]
	Symbol Table: {cnt=0, v1=RefValue(2, int), v2=RefValue(3, int), v3=RefValue(0, int)}
	Output: []
	File table: {}
	Heap: {2=2, 3=3}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 4
{
	Stack: [{newLatch(cnt, rH(v2)), {fork({call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}]
	Symbol Table: {cnt=0, v1=RefValue(2, int), v2=RefValue(3, int), v3=RefValue(4, int)}
	Output: []
	File table: {}
	Heap: {2=2, 3=3, 4=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 4
{
	Stack: [{newLatch(cnt, rH(v2)), {fork({call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}]
	Symbol Table: {cnt=0, v1=RefValue(2, int), v2=RefValue(3, int), v3=RefValue(4, int)}
	Output: []
	File table: {}
	Heap: {2=2, 3=3, 4=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 4
{
	Stack: [newLatch(cnt, rH(v2)), {fork({call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}]
	Symbol Table: {cnt=0, v1=RefValue(2, int), v2=RefValue(3, int), v3=RefValue(4, int)}
	Output: []
	File table: {}
	Heap: {2=2, 3=3, 4=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 4
{
	Stack: [newLatch(cnt, rH(v2)), {fork({call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}]
	Symbol Table: {cnt=0, v1=RefValue(2, int), v2=RefValue(3, int), v3=RefValue(4, int)}
	Output: []
	File table: {}
	Heap: {2=2, 3=3, 4=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 4
{
	Stack: [{fork({call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}]
	Symbol Table: {cnt=1, v1=RefValue(2, int), v2=RefValue(3, int), v3=RefValue(4, int)}
	Output: []
	File table: {}
	Heap: {2=2, 3=3, 4=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=3}
	Count Semaphore table: {}
};
Program 4
{
	Stack: [{fork({call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}]
	Symbol Table: {cnt=1, v1=RefValue(2, int), v2=RefValue(3, int), v3=RefValue(4, int)}
	Output: []
	File table: {}
	Heap: {2=2, 3=3, 4=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=3}
	Count Semaphore table: {}
};
Program 4
{
	Stack: [fork({call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}]
	Symbol Table: {cnt=1, v1=RefValue(2, int), v2=RefValue(3, int), v3=RefValue(4, int)}
	Output: []
	File table: {}
	Heap: {2=2, 3=3, 4=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=3}
	Count Semaphore table: {}
};
Program 4
{
	Stack: [fork({call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}]
	Symbol Table: {cnt=1, v1=RefValue(2, int), v2=RefValue(3, int), v3=RefValue(4, int)}
	Output: []
	File table: {}
	Heap: {2=2, 3=3, 4=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=3}
	Count Semaphore table: {}
};
Program 4
{
	Stack: [{await(cnt), {print(100), {countDown(cnt), print(100)}}}]
	Symbol Table: {cnt=1, v1=RefValue(2, int), v2=RefValue(3, int), v3=RefValue(4, int)}
	Output: []
	File table: {}
	Heap: {2=2, 3=3, 4=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=3}
	Count Semaphore table: {}
};
Program 5
{
	Stack: [{call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})}]
	Symbol Table: {cnt=1, v1=RefValue(2, int), v2=RefValue(3, int), v3=RefValue(4, int)}
	Output: []
	File table: {}
	Heap: {2=2, 3=3, 4=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=3}
	Count Semaphore table: {}
};
Program 4
{
	Stack: [{await(cnt), {print(100), {countDown(cnt), print(100)}}}]
	Symbol Table: {cnt=1, v1=RefValue(2, int), v2=RefValue(3, int), v3=RefValue(4, int)}
	Output: []
	File table: {}
	Heap: {2=2, 3=3, 4=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=3}
	Count Semaphore table: {}
};
Program 5
{
	Stack: [{call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})}]
	Symbol Table: {cnt=1, v1=RefValue(2, int), v2=RefValue(3, int), v3=RefValue(4, int)}
	Output: []
	File table: {}
	Heap: {2=2, 3=3, 4=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=3}
	Count Semaphore table: {}
};
Program 4
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(2, int), v2=RefValue(3, int), v3=RefValue(4, int)}
	Output: []
	File table: {}
	Heap: {2=2, 3=3, 4=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=3}
	Count Semaphore table: {}
};
Program 5
{
	Stack: [call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})]
	Symbol Table: {cnt=1, v1=RefValue(2, int), v2=RefValue(3, int), v3=RefValue(4, int)}
	Output: []
	File table: {}
	Heap: {2=2, 3=3, 4=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=3}
	Count Semaphore table: {}
};
Program 4
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(2, int), v2=RefValue(3, int), v3=RefValue(4, int)}
	Output: []
	File table: {}
	Heap: {2=2, 3=3, 4=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=3}
	Count Semaphore table: {}
};
Program 5
{
	Stack: [call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})]
	Symbol Table: {cnt=1, v1=RefValue(2, int), v2=RefValue(3, int), v3=RefValue(4, int)}
	Output: []
	File table: {}
	Heap: {2=2, 3=3, 4=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=3}
	Count Semaphore table: {}
};
Program 4
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(2, int), v2=RefValue(3, int), v3=RefValue(4, int)}
	Output: []
	File table: {}
	Heap: {2=2, 3=3, 4=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=3}
	Count Semaphore table: {}
};
Program 5
{
	Stack: [{wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}, return, fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})]
	Symbol Table: {v=RefValue(2, int), latch=1}
	Output: []
	File table: {}
	Heap: {2=2, 3=3, 4=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=3}
	Count Semaphore table: {}
};
Program 4
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(2, int), v2=RefValue(3, int), v3=RefValue(4, int)}
	Output: []
	File table: {}
	Heap: {2=2, 3=3, 4=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=3}
	Count Semaphore table: {}
};
Program 5
{
	Stack: [{wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}, return, fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})]
	Symbol Table: {v=RefValue(2, int), latch=1}
	Output: []
	File table: {}
	Heap: {2=2, 3=3, 4=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=3}
	Count Semaphore table: {}
};
Program 4
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(2, int), v2=RefValue(3, int), v3=RefValue(4, int)}
	Output: []
	File table: {}
	Heap: {2=2, 3=3, 4=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=3}
	Count Semaphore table: {}
};
Program 5
{
	Stack: [wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}, return, fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})]
	Symbol Table: {v=RefValue(2, int), latch=1}
	Output: []
	File table: {}
	Heap: {2=2, 3=3, 4=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=3}
	Count Semaphore table: {}
};
Program 4
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(2, int), v2=RefValue(3, int), v3=RefValue(4, int)}
	Output: []
	File table: {}
	Heap: {2=2, 3=3, 4=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=3}
	Count Semaphore table: {}
};
Program 5
{
	Stack: [wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}, return, fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})]
	Symbol Table: {v=RefValue(2, int), latch=1}
	Output: []
	File table: {}
	Heap: {2=2, 3=3, 4=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=3}
	Count Semaphore table: {}
};
Program 4
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(2, int), v2=RefValue(3, int), v3=RefValue(4, int)}
	Output: []
	File table: {}
	Heap: {2=20, 3=3, 4=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=3}
	Count Semaphore table: {}
};
Program 5
{
	Stack: [{print(rH(v)), countDown(latch)}, return, fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})]
	Symbol Table: {v=RefValue(2, int), latch=1}
	Output: []
	File table: {}
	Heap: {2=20, 3=3, 4=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=3}
	Count Semaphore table: {}
};
Program 4
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(2, int), v2=RefValue(3, int), v3=RefValue(4, int)}
	Output: []
	File table: {}
	Heap: {2=20, 3=3, 4=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=3}
	Count Semaphore table: {}
};
Program 5
{
	Stack: [{print(rH(v)), countDown(latch)}, return, fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})]
	Symbol Table: {v=RefValue(2, int), latch=1}
	Output: []
	File table: {}
	Heap: {2=20, 3=3, 4=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=3}
	Count Semaphore table: {}
};
Program 4
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(2, int), v2=RefValue(3, int), v3=RefValue(4, int)}
	Output: []
	File table: {}
	Heap: {2=20, 3=3, 4=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=3}
	Count Semaphore table: {}
};
Program 5
{
	Stack: [print(rH(v)), countDown(latch), return, fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})]
	Symbol Table: {v=RefValue(2, int), latch=1}
	Output: []
	File table: {}
	Heap: {2=20, 3=3, 4=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=3}
	Count Semaphore table: {}
};
Program 4
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(2, int), v2=RefValue(3, int), v3=RefValue(4, int)}
	Output: []
	File table: {}
	Heap: {2=20, 3=3, 4=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=3}
	Count Semaphore table: {}
};
Program 5
{
	Stack: [print(rH(v)), countDown(latch), return, fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})]
	Symbol Table: {v=RefValue(2, int), latch=1}
	Output: []
	File table: {}
	Heap: {2=20, 3=3, 4=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=3}
	Count Semaphore table: {}
};
Program 4
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(2, int), v2=RefValue(3, int), v3=RefValue(4, int)}
	Output: [20]
	File table: {}
	Heap: {2=20, 3=3, 4=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=3}
	Count Semaphore table: {}
};
Program 5
{
	Stack: [countDown(latch), return, fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})]
	Symbol Table: {v=RefValue(2, int), latch=1}
	Output: [20]
	File table: {}
	Heap: {2=20, 3=3, 4=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=3}
	Count Semaphore table: {}
};
Program 4
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(2, int), v2=RefValue(3, int), v3=RefValue(4, int)}
	Output: [20]
	File table: {}
	Heap: {2=20, 3=3, 4=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=3}
	Count Semaphore table: {}
};
Program 5
{
	Stack: [countDown(latch), return, fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})]
	Symbol Table: {v=RefValue(2, int), latch=1}
	Output: [20]
	File table: {}
	Heap: {2=20, 3=3, 4=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=3}
	Count Semaphore table: {}
};
Program 4
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(2, int), v2=RefValue(3, int), v3=RefValue(4, int)}
	Output: [20, 5]
	File table: {}
	Heap: {2=20, 3=3, 4=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 5
{
	Stack: [return, fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})]
	Symbol Table: {v=RefValue(2, int), latch=1}
	Output: [20, 5]
	File table: {}
	Heap: {2=20, 3=3, 4=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 4
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(2, int), v2=RefValue(3, int), v3=RefValue(4, int)}
	Output: [20, 5]
	File table: {}
	Heap: {2=20, 3=3, 4=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 5
{
	Stack: [return, fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})]
	Symbol Table: {v=RefValue(2, int), latch=1}
	Output: [20, 5]
	File table: {}
	Heap: {2=20, 3=3, 4=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 4
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(2, int), v2=RefValue(3, int), v3=RefValue(4, int)}
	Output: [20, 5]
	File table: {}
	Heap: {2=20, 3=3, 4=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 5
{
	Stack: [fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})]
	Symbol Table: {cnt=1, v1=RefValue(2, int), v2=RefValue(3, int), v3=RefValue(4, int)}
	Output: [20, 5]
	File table: {}
	Heap: {2=20, 3=3, 4=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 4
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(2, int), v2=RefValue(3, int), v3=RefValue(4, int)}
	Output: [20, 5]
	File table: {}
	Heap: {2=20, 3=3, 4=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 5
{
	Stack: [fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})]
	Symbol Table: {cnt=1, v1=RefValue(2, int), v2=RefValue(3, int), v3=RefValue(4, int)}
	Output: [20, 5]
	File table: {}
	Heap: {2=20, 3=3, 4=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 4
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(2, int), v2=RefValue(3, int), v3=RefValue(4, int)}
	Output: [20, 5]
	File table: {}
	Heap: {2=20, 3=3, 4=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 5
{
	Stack: []
	Symbol Table: {cnt=1, v1=RefValue(2, int), v2=RefValue(3, int), v3=RefValue(4, int)}
	Output: [20, 5]
	File table: {}
	Heap: {2=20, 3=3, 4=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 6
{
	Stack: [{call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])}]
	Symbol Table: {cnt=1, v1=RefValue(2, int), v2=RefValue(3, int), v3=RefValue(4, int)}
	Output: [20, 5]
	File table: {}
	Heap: {2=20, 3=3, 4=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 4
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(2, int), v2=RefValue(3, int), v3=RefValue(4, int)}
	Output: [20, 5]
	File table: {}
	Heap: {2=20, 3=3, 4=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 6
{
	Stack: [{call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])}]
	Symbol Table: {cnt=1, v1=RefValue(2, int), v2=RefValue(3, int), v3=RefValue(4, int)}
	Output: [20, 5]
	File table: {}
	Heap: {2=20, 3=3, 4=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 4
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(2, int), v2=RefValue(3, int), v3=RefValue(4, int)}
	Output: [20, 5]
	File table: {}
	Heap: {2=20, 3=3, 4=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 6
{
	Stack: [call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])]
	Symbol Table: {cnt=1, v1=RefValue(2, int), v2=RefValue(3, int), v3=RefValue(4, int)}
	Output: [20, 5]
	File table: {}
	Heap: {2=20, 3=3, 4=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 4
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(2, int), v2=RefValue(3, int), v3=RefValue(4, int)}
	Output: [20, 5]
	File table: {}
	Heap: {2=20, 3=3, 4=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 6
{
	Stack: [call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])]
	Symbol Table: {cnt=1, v1=RefValue(2, int), v2=RefValue(3, int), v3=RefValue(4, int)}
	Output: [20, 5]
	File table: {}
	Heap: {2=20, 3=3, 4=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 4
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(2, int), v2=RefValue(3, int), v3=RefValue(4, int)}
	Output: [20, 5]
	File table: {}
	Heap: {2=20, 3=3, 4=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 6
{
	Stack: [{wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}, return, fork(call [forkBody[v3, cnt]])]
	Symbol Table: {v=RefValue(3, int), latch=1}
	Output: [20, 5]
	File table: {}
	Heap: {2=20, 3=3, 4=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 4
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(2, int), v2=RefValue(3, int), v3=RefValue(4, int)}
	Output: [20, 5]
	File table: {}
	Heap: {2=20, 3=3, 4=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 6
{
	Stack: [{wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}, return, fork(call [forkBody[v3, cnt]])]
	Symbol Table: {v=RefValue(3, int), latch=1}
	Output: [20, 5]
	File table: {}
	Heap: {2=20, 3=3, 4=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 4
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(2, int), v2=RefValue(3, int), v3=RefValue(4, int)}
	Output: [20, 5]
	File table: {}
	Heap: {2=20, 3=3, 4=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 6
{
	Stack: [wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}, return, fork(call [forkBody[v3, cnt]])]
	Symbol Table: {v=RefValue(3, int), latch=1}
	Output: [20, 5]
	File table: {}
	Heap: {2=20, 3=3, 4=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 4
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(2, int), v2=RefValue(3, int), v3=RefValue(4, int)}
	Output: [20, 5]
	File table: {}
	Heap: {2=20, 3=3, 4=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 6
{
	Stack: [wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}, return, fork(call [forkBody[v3, cnt]])]
	Symbol Table: {v=RefValue(3, int), latch=1}
	Output: [20, 5]
	File table: {}
	Heap: {2=20, 3=3, 4=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 4
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(2, int), v2=RefValue(3, int), v3=RefValue(4, int)}
	Output: [20, 5]
	File table: {}
	Heap: {2=20, 3=30, 4=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 6
{
	Stack: [{print(rH(v)), countDown(latch)}, return, fork(call [forkBody[v3, cnt]])]
	Symbol Table: {v=RefValue(3, int), latch=1}
	Output: [20, 5]
	File table: {}
	Heap: {2=20, 3=30, 4=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 4
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(2, int), v2=RefValue(3, int), v3=RefValue(4, int)}
	Output: [20, 5]
	File table: {}
	Heap: {2=20, 3=30, 4=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 6
{
	Stack: [{print(rH(v)), countDown(latch)}, return, fork(call [forkBody[v3, cnt]])]
	Symbol Table: {v=RefValue(3, int), latch=1}
	Output: [20, 5]
	File table: {}
	Heap: {2=20, 3=30, 4=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 4
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(2, int), v2=RefValue(3, int), v3=RefValue(4, int)}
	Output: [20, 5]
	File table: {}
	Heap: {2=20, 3=30, 4=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 6
{
	Stack: [print(rH(v)), countDown(latch), return, fork(call [forkBody[v3, cnt]])]
	Symbol Table: {v=RefValue(3, int), latch=1}
	Output: [20, 5]
	File table: {}
	Heap: {2=20, 3=30, 4=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 4
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(2, int), v2=RefValue(3, int), v3=RefValue(4, int)}
	Output: [20, 5]
	File table: {}
	Heap: {2=20, 3=30, 4=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 6
{
	Stack: [print(rH(v)), countDown(latch), return, fork(call [forkBody[v3, cnt]])]
	Symbol Table: {v=RefValue(3, int), latch=1}
	Output: [20, 5]
	File table: {}
	Heap: {2=20, 3=30, 4=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 4
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(2, int), v2=RefValue(3, int), v3=RefValue(4, int)}
	Output: [20, 5, 30]
	File table: {}
	Heap: {2=20, 3=30, 4=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 6
{
	Stack: [countDown(latch), return, fork(call [forkBody[v3, cnt]])]
	Symbol Table: {v=RefValue(3, int), latch=1}
	Output: [20, 5, 30]
	File table: {}
	Heap: {2=20, 3=30, 4=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 4
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(2, int), v2=RefValue(3, int), v3=RefValue(4, int)}
	Output: [20, 5, 30]
	File table: {}
	Heap: {2=20, 3=30, 4=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 6
{
	Stack: [countDown(latch), return, fork(call [forkBody[v3, cnt]])]
	Symbol Table: {v=RefValue(3, int), latch=1}
	Output: [20, 5, 30]
	File table: {}
	Heap: {2=20, 3=30, 4=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 4
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(2, int), v2=RefValue(3, int), v3=RefValue(4, int)}
	Output: [20, 5, 30, 6]
	File table: {}
	Heap: {2=20, 3=30, 4=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=1}
	Count Semaphore table: {}
};
Program 6
{
	Stack: [return, fork(call [forkBody[v3, cnt]])]
	Symbol Table: {v=RefValue(3, int), latch=1}
	Output: [20, 5, 30, 6]
	File table: {}
	Heap: {2=20, 3=30, 4=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=1}
	Count Semaphore table: {}
};
Program 4
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(2, int), v2=RefValue(3, int), v3=RefValue(4, int)}
	Output: [20, 5, 30, 6]
	File table: {}
	Heap: {2=20, 3=30, 4=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=1}
	Count Semaphore table: {}
};
Program 6
{
	Stack: [return, fork(call [forkBody[v3, cnt]])]
	Symbol Table: {v=RefValue(3, int), latch=1}
	Output: [20, 5, 30, 6]
	File table: {}
	Heap: {2=20, 3=30, 4=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=1}
	Count Semaphore table: {}
};
Program 4
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(2, int), v2=RefValue(3, int), v3=RefValue(4, int)}
	Output: [20, 5, 30, 6]
	File table: {}
	Heap: {2=20, 3=30, 4=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=1}
	Count Semaphore table: {}
};
Program 6
{
	Stack: [fork(call [forkBody[v3, cnt]])]
	Symbol Table: {cnt=1, v1=RefValue(2, int), v2=RefValue(3, int), v3=RefValue(4, int)}
	Output: [20, 5, 30, 6]
	File table: {}
	Heap: {2=20, 3=30, 4=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=1}
	Count Semaphore table: {}
};
Program 4
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(2, int), v2=RefValue(3, int), v3=RefValue(4, int)}
	Output: [20, 5, 30, 6]
	File table: {}
	Heap: {2=20, 3=30, 4=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=1}
	Count Semaphore table: {}
};
Program 6
{
	Stack: [fork(call [forkBody[v3, cnt]])]
	Symbol Table: {cnt=1, v1=RefValue(2, int), v2=RefValue(3, int), v3=RefValue(4, int)}
	Output: [20, 5, 30, 6]
	File table: {}
	Heap: {2=20, 3=30, 4=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=1}
	Count Semaphore table: {}
};
Program 4
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(2, int), v2=RefValue(3, int), v3=RefValue(4, int)}
	Output: [20, 5, 30, 6]
	File table: {}
	Heap: {2=20, 3=30, 4=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=1}
	Count Semaphore table: {}
};
Program 6
{
	Stack: []
	Symbol Table: {cnt=1, v1=RefValue(2, int), v2=RefValue(3, int), v3=RefValue(4, int)}
	Output: [20, 5, 30, 6]
	File table: {}
	Heap: {2=20, 3=30, 4=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=1}
	Count Semaphore table: {}
};
Program 7
{
	Stack: [call [forkBody[v3, cnt]]]
	Symbol Table: {cnt=1, v1=RefValue(2, int), v2=RefValue(3, int), v3=RefValue(4, int)}
	Output: [20, 5, 30, 6]
	File table: {}
	Heap: {2=20, 3=30, 4=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=1}
	Count Semaphore table: {}
};
Program 4
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(2, int), v2=RefValue(3, int), v3=RefValue(4, int)}
	Output: [20, 5, 30, 6]
	File table: {}
	Heap: {2=20, 3=30, 4=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=1}
	Count Semaphore table: {}
};
Program 7
{
	Stack: [call [forkBody[v3, cnt]]]
	Symbol Table: {cnt=1, v1=RefValue(2, int), v2=RefValue(3, int), v3=RefValue(4, int)}
	Output: [20, 5, 30, 6]
	File table: {}
	Heap: {2=20, 3=30, 4=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=1}
	Count Semaphore table: {}
};
Program 4
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(2, int), v2=RefValue(3, int), v3=RefValue(4, int)}
	Output: [20, 5, 30, 6]
	File table: {}
	Heap: {2=20, 3=30, 4=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=1}
	Count Semaphore table: {}
};
Program 7
{
	Stack: [{wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}, return]
	Symbol Table: {v=RefValue(4, int), latch=1}
	Output: [20, 5, 30, 6]
	File table: {}
	Heap: {2=20, 3=30, 4=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=1}
	Count Semaphore table: {}
};
Program 4
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(2, int), v2=RefValue(3, int), v3=RefValue(4, int)}
	Output: [20, 5, 30, 6]
	File table: {}
	Heap: {2=20, 3=30, 4=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=1}
	Count Semaphore table: {}
};
Program 7
{
	Stack: [{wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}, return]
	Symbol Table: {v=RefValue(4, int), latch=1}
	Output: [20, 5, 30, 6]
	File table: {}
	Heap: {2=20, 3=30, 4=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=1}
	Count Semaphore table: {}
};
Program 4
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(2, int), v2=RefValue(3, int), v3=RefValue(4, int)}
	Output: [20, 5, 30, 6]
	File table: {}
	Heap: {2=20, 3=30, 4=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=1}
	Count Semaphore table: {}
};
Program 7
{
	Stack: [wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}, return]
	Symbol Table: {v=RefValue(4, int), latch=1}
	Output: [20, 5, 30, 6]
	File table: {}
	Heap: {2=20, 3=30, 4=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=1}
	Count Semaphore table: {}
};
Program 4
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(2, int), v2=RefValue(3, int), v3=RefValue(4, int)}
	Output: [20, 5, 30, 6]
	File table: {}
	Heap: {2=20, 3=30, 4=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=1}
	Count Semaphore table: {}
};
Program 7
{
	Stack: [wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}, return]
	Symbol Table: {v=RefValue(4, int), latch=1}
	Output: [20, 5, 30, 6]
	File table: {}
	Heap: {2=20, 3=30, 4=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=1}
	Count Semaphore table: {}
};
Program 4
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(2, int), v2=RefValue(3, int), v3=RefValue(4, int)}
	Output: [20, 5, 30, 6]
	File table: {}
	Heap: {2=20, 3=30, 4=40}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=1}
	Count Semaphore table: {}
};
Program 7
{
	Stack: [{print(rH(v)), countDown(latch)}, return]
	Symbol Table: {v=RefValue(4, int), latch=1}
	Output: [20, 5, 30, 6]
	File table: {}
	Heap: {2=20, 3=30, 4=40}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=1}
	Count Semaphore table: {}
};
Program 4
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(2, int), v2=RefValue(3, int), v3=RefValue(4, int)}
	Output: [20, 5, 30, 6]
	File table: {}
	Heap: {2=20, 3=30, 4=40}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=1}
	Count Semaphore table: {}
};
Program 7
{
	Stack: [{print(rH(v)), countDown(latch)}, return]
	Symbol Table: {v=RefValue(4, int), latch=1}
	Output: [20, 5, 30, 6]
	File table: {}
	Heap: {2=20, 3=30, 4=40}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=1}
	Count Semaphore table: {}
};
Program 4
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(2, int), v2=RefValue(3, int), v3=RefValue(4, int)}
	Output: [20, 5, 30, 6]
	File table: {}
	Heap: {2=20, 3=30, 4=40}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=1}
	Count Semaphore table: {}
};
Program 7
{
	Stack: [print(rH(v)), countDown(latch), return]
	Symbol Table: {v=RefValue(4, int), latch=1}
	Output: [20, 5, 30, 6]
	File table: {}
	Heap: {2=20, 3=30, 4=40}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=1}
	Count Semaphore table: {}
};
Program 4
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(2, int), v2=RefValue(3, int), v3=RefValue(4, int)}
	Output: [20, 5, 30, 6]
	File table: {}
	Heap: {2=20, 3=30, 4=40}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=1}
	Count Semaphore table: {}
};
Program 7
{
	Stack: [print(rH(v)), countDown(latch), return]
	Symbol Table: {v=RefValue(4, int), latch=1}
	Output: [20, 5, 30, 6]
	File table: {}
	Heap: {2=20, 3=30, 4=40}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=1}
	Count Semaphore table: {}
};
Program 4
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(2, int), v2=RefValue(3, int), v3=RefValue(4, int)}
	Output: [20, 5, 30, 6, 40]
	File table: {}
	Heap: {2=20, 3=30, 4=40}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=1}
	Count Semaphore table: {}
};
Program 7
{
	Stack: [countDown(latch), return]
	Symbol Table: {v=RefValue(4, int), latch=1}
	Output: [20, 5, 30, 6, 40]
	File table: {}
	Heap: {2=20, 3=30, 4=40}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=1}
	Count Semaphore table: {}
};
Program 4
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(2, int), v2=RefValue(3, int), v3=RefValue(4, int)}
	Output: [20, 5, 30, 6, 40]
	File table: {}
	Heap: {2=20, 3=30, 4=40}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=1}
	Count Semaphore table: {}
};
Program 7
{
	Stack: [countDown(latch), return]
	Symbol Table: {v=RefValue(4, int), latch=1}
	Output: [20, 5, 30, 6, 40]
	File table: {}
	Heap: {2=20, 3=30, 4=40}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=1}
	Count Semaphore table: {}
};
Program 4
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(2, int), v2=RefValue(3, int), v3=RefValue(4, int)}
	Output: [20, 5, 30, 6, 40, 7]
	File table: {}
	Heap: {2=20, 3=30, 4=40}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=0}
	Count Semaphore table: {}
};
Program 7
{
	Stack: [return]
	Symbol Table: {v=RefValue(4, int), latch=1}
	Output: [20, 5, 30, 6, 40, 7]
	File table: {}
	Heap: {2=20, 3=30, 4=40}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=0}
	Count Semaphore table: {}
};
Program 4
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(2, int), v2=RefValue(3, int), v3=RefValue(4, int)}
	Output: [20, 5, 30, 6, 40, 7]
	File table: {}
	Heap: {2=20, 3=30, 4=40}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=0}
	Count Semaphore table: {}
};
Program 7
{
	Stack: [return]
	Symbol Table: {v=RefValue(4, int), latch=1}
	Output: [20, 5, 30, 6, 40, 7]
	File table: {}
	Heap: {2=20, 3=30, 4=40}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=0}
	Count Semaphore table: {}
};
Program 4
{
	Stack: [{print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(2, int), v2=RefValue(3, int), v3=RefValue(4, int)}
	Output: [20, 5, 30, 6, 40, 7]
	File table: {}
	Heap: {2=20, 3=30, 4=40}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=0}
	Count Semaphore table: {}
};
Program 7
{
	Stack: []
	Symbol Table: {cnt=1, v1=RefValue(2, int), v2=RefValue(3, int), v3=RefValue(4, int)}
	Output: [20, 5, 30, 6, 40, 7]
	File table: {}
	Heap: {2=20, 3=30, 4=40}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=0}
	Count Semaphore table: {}
};
Program 4
{
	Stack: [{print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(2, int), v2=RefValue(3, int), v3=RefValue(4, int)}
	Output: [20, 5, 30, 6, 40, 7]
	File table: {}
	Heap: {2=20, 3=30, 4=40}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=0}
	Count Semaphore table: {}
};
Program 4
{
	Stack: [print(100), {countDown(cnt), print(100)}]
	Symbol Table: {cnt=1, v1=RefValue(2, int), v2=RefValue(3, int), v3=RefValue(4, int)}
	Output: [20, 5, 30, 6, 40, 7]
	File table: {}
	Heap: {2=20, 3=30, 4=40}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=0}
	Count Semaphore table: {}
};
Program 4
{
	Stack: [print(100), {countDown(cnt), print(100)}]
	Symbol Table: {cnt=1, v1=RefValue(2, int), v2=RefValue(3, int), v3=RefValue(4, int)}
	Output: [20, 5, 30, 6, 40, 7]
	File table: {}
	Heap: {2=20, 3=30, 4=40}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=0}
	Count Semaphore table: {}
};
Program 4
{
	Stack: [{countDown(cnt), print(100)}]
	Symbol Table: {cnt=1, v1=RefValue(2, int), v2=RefValue(3, int), v3=RefValue(4, int)}
	Output: [20, 5, 30, 6, 40, 7, 100]
	File table: {}
	Heap: {2=20, 3=30, 4=40}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=0}
	Count Semaphore table: {}
};
Program 4
{
	Stack: [{countDown(cnt), print(100)}]
	Symbol Table: {cnt=1, v1=RefValue(2, int), v2=RefValue(3, int), v3=RefValue(4, int)}
	Output: [20, 5, 30, 6, 40, 7, 100]
	File table: {}
	Heap: {2=20, 3=30, 4=40}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=0}
	Count Semaphore table: {}
};
Program 4
{
	Stack: [countDown(cnt), print(100)]
	Symbol Table: {cnt=1, v1=RefValue(2, int), v2=RefValue(3, int), v3=RefValue(4, int)}
	Output: [20, 5, 30, 6, 40, 7, 100]
	File table: {}
	Heap: {2=20, 3=30, 4=40}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=0}
	Count Semaphore table: {}
};
Program 4
{
	Stack: [countDown(cnt), print(100)]
	Symbol Table: {cnt=1, v1=RefValue(2, int), v2=RefValue(3, int), v3=RefValue(4, int)}
	Output: [20, 5, 30, 6, 40, 7, 100]
	File table: {}
	Heap: {2=20, 3=30, 4=40}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=0}
	Count Semaphore table: {}
};
Program 4
{
	Stack: [print(100)]
	Symbol Table: {cnt=1, v1=RefValue(2, int), v2=RefValue(3, int), v3=RefValue(4, int)}
	Output: [20, 5, 30, 6, 40, 7, 100, 4]
	File table: {}
	Heap: {2=20, 3=30, 4=40}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=0}
	Count Semaphore table: {}
};
Program 4
{
	Stack: [print(100)]
	Symbol Table: {cnt=1, v1=RefValue(2, int), v2=RefValue(3, int), v3=RefValue(4, int)}
	Output: [20, 5, 30, 6, 40, 7, 100, 4]
	File table: {}
	Heap: {2=20, 3=30, 4=40}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=0}
	Count Semaphore table: {}
};
Program 4
{
	Stack: []
	Symbol Table: {cnt=1, v1=RefValue(2, int), v2=RefValue(3, int), v3=RefValue(4, int)}
	Output: [20, 5, 30, 6, 40, 7, 100, 4, 100]
	File table: {}
	Heap: {2=20, 3=30, 4=40}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=0}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [{procedure[forkBody[v, latch]->{wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}], {Ref(int) v1, {Ref(int) v2, {Ref(int) v3, {int cnt, {new(v1,2), {new(v2,3), {new(v3,4), {newLatch(cnt, rH(v2)), {fork({call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}}}}}}}}}]
	Symbol Table: {}
	Output: []
	File table: {}
	Heap: {}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [procedure[forkBody[v, latch]->{wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}], {Ref(int) v1, {Ref(int) v2, {Ref(int) v3, {int cnt, {new(v1,2), {new(v2,3), {new(v3,4), {newLatch(cnt, rH(v2)), {fork({call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}}}}}}}}]
	Symbol Table: {}
	Output: []
	File table: {}
	Heap: {}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [procedure[forkBody[v, latch]->{wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}], {Ref(int) v1, {Ref(int) v2, {Ref(int) v3, {int cnt, {new(v1,2), {new(v2,3), {new(v3,4), {newLatch(cnt, rH(v2)), {fork({call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}}}}}}}}]
	Symbol Table: {}
	Output: []
	File table: {}
	Heap: {}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [{Ref(int) v1, {Ref(int) v2, {Ref(int) v3, {int cnt, {new(v1,2), {new(v2,3), {new(v3,4), {newLatch(cnt, rH(v2)), {fork({call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}}}}}}}}]
	Symbol Table: {}
	Output: []
	File table: {}
	Heap: {}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [{Ref(int) v1, {Ref(int) v2, {Ref(int) v3, {int cnt, {new(v1,2), {new(v2,3), {new(v3,4), {newLatch(cnt, rH(v2)), {fork({call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}}}}}}}}]
	Symbol Table: {}
	Output: []
	File table: {}
	Heap: {}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [Ref(int) v1, {Ref(int) v2, {Ref(int) v3, {int cnt, {new(v1,2), {new(v2,3), {new(v3,4), {newLatch(cnt, rH(v2)), {fork({call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}}}}}}}]
	Symbol Table: {}
	Output: []
	File table: {}
	Heap: {}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [Ref(int) v1, {Ref(int) v2, {Ref(int) v3, {int cnt, {new(v1,2), {new(v2,3), {new(v3,4), {newLatch(cnt, rH(v2)), {fork({call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}}}}}}}]
	Symbol Table: {}
	Output: []
	File table: {}
	Heap: {}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [{Ref(int) v2, {Ref(int) v3, {int cnt, {new(v1,2), {new(v2,3), {new(v3,4), {newLatch(cnt, rH(v2)), {fork({call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}}}}}}}]
	Symbol Table: {v1=RefValue(0, int)}
	Output: []
	File table: {}
	Heap: {}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [{Ref(int) v2, {Ref(int) v3, {int cnt, {new(v1,2), {new(v2,3), {new(v3,4), {newLatch(cnt, rH(v2)), {fork({call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}}}}}}}]
	Symbol Table: {v1=RefValue(0, int)}
	Output: []
	File table: {}
	Heap: {}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [Ref(int) v2, {Ref(int) v3, {int cnt, {new(v1,2), {new(v2,3), {new(v3,4), {newLatch(cnt, rH(v2)), {fork({call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}}}}}}]
	Symbol Table: {v1=RefValue(0, int)}
	Output: []
	File table: {}
	Heap: {}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [Ref(int) v2, {Ref(int) v3, {int cnt, {new(v1,2), {new(v2,3), {new(v3,4), {newLatch(cnt, rH(v2)), {fork({call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}}}}}}]
	Symbol Table: {v1=RefValue(0, int)}
	Output: []
	File table: {}
	Heap: {}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [{Ref(int) v3, {int cnt, {new(v1,2), {new(v2,3), {new(v3,4), {newLatch(cnt, rH(v2)), {fork({call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}}}}}}]
	Symbol Table: {v1=RefValue(0, int), v2=RefValue(0, int)}
	Output: []
	File table: {}
	Heap: {}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [{Ref(int) v3, {int cnt, {new(v1,2), {new(v2,3), {new(v3,4), {newLatch(cnt, rH(v2)), {fork({call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}}}}}}]
	Symbol Table: {v1=RefValue(0, int), v2=RefValue(0, int)}
	Output: []
	File table: {}
	Heap: {}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [Ref(int) v3, {int cnt, {new(v1,2), {new(v2,3), {new(v3,4), {newLatch(cnt, rH(v2)), {fork({call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}}}}}]
	Symbol Table: {v1=RefValue(0, int), v2=RefValue(0, int)}
	Output: []
	File table: {}
	Heap: {}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [Ref(int) v3, {int cnt, {new(v1,2), {new(v2,3), {new(v3,4), {newLatch(cnt, rH(v2)), {fork({call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}}}}}]
	Symbol Table: {v1=RefValue(0, int), v2=RefValue(0, int)}
	Output: []
	File table: {}
	Heap: {}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [{int cnt, {new(v1,2), {new(v2,3), {new(v3,4), {newLatch(cnt, rH(v2)), {fork({call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}}}}}]
	Symbol Table: {v1=RefValue(0, int), v2=RefValue(0, int), v3=RefValue(0, int)}
	Output: []
	File table: {}
	Heap: {}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [{int cnt, {new(v1,2), {new(v2,3), {new(v3,4), {newLatch(cnt, rH(v2)), {fork({call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}}}}}]
	Symbol Table: {v1=RefValue(0, int), v2=RefValue(0, int), v3=RefValue(0, int)}
	Output: []
	File table: {}
	Heap: {}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [int cnt, {new(v1,2), {new(v2,3), {new(v3,4), {newLatch(cnt, rH(v2)), {fork({call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}}}}]
	Symbol Table: {v1=RefValue(0, int), v2=RefValue(0, int), v3=RefValue(0, int)}
	Output: []
	File table: {}
	Heap: {}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [int cnt, {new(v1,2), {new(v2,3), {new(v3,4), {newLatch(cnt, rH(v2)), {fork({call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}}}}]
	Symbol Table: {v1=RefValue(0, int), v2=RefValue(0, int), v3=RefValue(0, int)}
	Output: []
	File table: {}
	Heap: {}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [{new(v1,2), {new(v2,3), {new(v3,4), {newLatch(cnt, rH(v2)), {fork({call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}}}}]
	Symbol Table: {cnt=0, v1=RefValue(0, int), v2=RefValue(0, int), v3=RefValue(0, int)}
	Output: []
	File table: {}
	Heap: {}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [{new(v1,2), {new(v2,3), {new(v3,4), {newLatch(cnt, rH(v2)), {fork({call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}}}}]
	Symbol Table: {cnt=0, v1=RefValue(0, int), v2=RefValue(0, int), v3=RefValue(0, int)}
	Output: []
	File table: {}
	Heap: {}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [new(v1,2), {new(v2,3), {new(v3,4), {newLatch(cnt, rH(v2)), {fork({call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}}}]
	Symbol Table: {cnt=0, v1=RefValue(0, int), v2=RefValue(0, int), v3=RefValue(0, int)}
	Output: []
	File table: {}
	Heap: {}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [new(v1,2), {new(v2,3), {new(v3,4), {newLatch(cnt, rH(v2)), {fork({call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}}}]
	Symbol Table: {cnt=0, v1=RefValue(0, int), v2=RefValue(0, int), v3=RefValue(0, int)}
	Output: []
	File table: {}
	Heap: {}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [{new(v2,3), {new(v3,4), {newLatch(cnt, rH(v2)), {fork({call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}}}]
	Symbol Table: {cnt=0, v1=RefValue(1, int), v2=RefValue(0, int), v3=RefValue(0, int)}
	Output: []
	File table: {}
	Heap: {1=2}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [{new(v2,3), {new(v3,4), {newLatch(cnt, rH(v2)), {fork({call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}}}]
	Symbol Table: {cnt=0, v1=RefValue(1, int), v2=RefValue(0, int), v3=RefValue(0, int)}
	Output: []
	File table: {}
	Heap: {1=2}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [new(v2,3), {new(v3,4), {newLatch(cnt, rH(v2)), {fork({call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}}]
	Symbol Table: {cnt=0, v1=RefValue(1, int), v2=RefValue(0, int), v3=RefValue(0, int)}
	Output: []
	File table: {}
	Heap: {1=2}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [new(v2,3), {new(v3,4), {newLatch(cnt, rH(v2)), {fork({call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}}]
	Symbol Table: {cnt=0, v1=RefValue(1, int), v2=RefValue(0, int), v3=RefValue(0, int)}
	Output: []
	File table: {}
	Heap: {1=2}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [{new(v3,4), {newLatch(cnt, rH(v2)), {fork({call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}}]
	Symbol Table: {cnt=0, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(0, int)}
	Output: []
	File table: {}
	Heap: {1=2, 2=3}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [{new(v3,4), {newLatch(cnt, rH(v2)), {fork({call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}}]
	Symbol Table: {cnt=0, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(0, int)}
	Output: []
	File table: {}
	Heap: {1=2, 2=3}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [new(v3,4), {newLatch(cnt, rH(v2)), {fork({call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}]
	Symbol Table: {cnt=0, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(0, int)}
	Output: []
	File table: {}
	Heap: {1=2, 2=3}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [new(v3,4), {newLatch(cnt, rH(v2)), {fork({call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}]
	Symbol Table: {cnt=0, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(0, int)}
	Output: []
	File table: {}
	Heap: {1=2, 2=3}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [{newLatch(cnt, rH(v2)), {fork({call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}]
	Symbol Table: {cnt=0, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: []
	File table: {}
	Heap: {1=2, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [{newLatch(cnt, rH(v2)), {fork({call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}]
	Symbol Table: {cnt=0, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: []
	File table: {}
	Heap: {1=2, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [newLatch(cnt, rH(v2)), {fork({call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}]
	Symbol Table: {cnt=0, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: []
	File table: {}
	Heap: {1=2, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [newLatch(cnt, rH(v2)), {fork({call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}]
	Symbol Table: {cnt=0, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: []
	File table: {}
	Heap: {1=2, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [{fork({call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: []
	File table: {}
	Heap: {1=2, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=3}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [{fork({call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: []
	File table: {}
	Heap: {1=2, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=3}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [fork({call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: []
	File table: {}
	Heap: {1=2, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=3}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [fork({call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: []
	File table: {}
	Heap: {1=2, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=3}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [{await(cnt), {print(100), {countDown(cnt), print(100)}}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: []
	File table: {}
	Heap: {1=2, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=3}
	Count Semaphore table: {}
};
Program 2
{
	Stack: [{call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: []
	File table: {}
	Heap: {1=2, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=3}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [{await(cnt), {print(100), {countDown(cnt), print(100)}}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: []
	File table: {}
	Heap: {1=2, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=3}
	Count Semaphore table: {}
};
Program 2
{
	Stack: [{call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: []
	File table: {}
	Heap: {1=2, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=3}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: []
	File table: {}
	Heap: {1=2, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=3}
	Count Semaphore table: {}
};
Program 2
{
	Stack: [call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: []
	File table: {}
	Heap: {1=2, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=3}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: []
	File table: {}
	Heap: {1=2, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=3}
	Count Semaphore table: {}
};
Program 2
{
	Stack: [call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: []
	File table: {}
	Heap: {1=2, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=3}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: []
	File table: {}
	Heap: {1=2, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=3}
	Count Semaphore table: {}
};
Program 2
{
	Stack: [{wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}, return, fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})]
	Symbol Table: {v=RefValue(1, int), latch=1}
	Output: []
	File table: {}
	Heap: {1=2, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=3}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: []
	File table: {}
	Heap: {1=2, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=3}
	Count Semaphore table: {}
};
Program 2
{
	Stack: [{wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}, return, fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})]
	Symbol Table: {v=RefValue(1, int), latch=1}
	Output: []
	File table: {}
	Heap: {1=2, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=3}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: []
	File table: {}
	Heap: {1=2, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=3}
	Count Semaphore table: {}
};
Program 2
{
	Stack: [wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}, return, fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})]
	Symbol Table: {v=RefValue(1, int), latch=1}
	Output: []
	File table: {}
	Heap: {1=2, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=3}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: []
	File table: {}
	Heap: {1=2, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=3}
	Count Semaphore table: {}
};
Program 2
{
	Stack: [wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}, return, fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})]
	Symbol Table: {v=RefValue(1, int), latch=1}
	Output: []
	File table: {}
	Heap: {1=2, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=3}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: []
	File table: {}
	Heap: {1=20, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=3}
	Count Semaphore table: {}
};
Program 2
{
	Stack: [{print(rH(v)), countDown(latch)}, return, fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})]
	Symbol Table: {v=RefValue(1, int), latch=1}
	Output: []
	File table: {}
	Heap: {1=20, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=3}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: []
	File table: {}
	Heap: {1=20, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=3}
	Count Semaphore table: {}
};
Program 2
{
	Stack: [{print(rH(v)), countDown(latch)}, return, fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})]
	Symbol Table: {v=RefValue(1, int), latch=1}
	Output: []
	File table: {}
	Heap: {1=20, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=3}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: []
	File table: {}
	Heap: {1=20, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=3}
	Count Semaphore table: {}
};
Program 2
{
	Stack: [print(rH(v)), countDown(latch), return, fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})]
	Symbol Table: {v=RefValue(1, int), latch=1}
	Output: []
	File table: {}
	Heap: {1=20, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=3}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: []
	File table: {}
	Heap: {1=20, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=3}
	Count Semaphore table: {}
};
Program 2
{
	Stack: [print(rH(v)), countDown(latch), return, fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})]
	Symbol Table: {v=RefValue(1, int), latch=1}
	Output: []
	File table: {}
	Heap: {1=20, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=3}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20]
	File table: {}
	Heap: {1=20, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=3}
	Count Semaphore table: {}
};
Program 2
{
	Stack: [countDown(latch), return, fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})]
	Symbol Table: {v=RefValue(1, int), latch=1}
	Output: [20]
	File table: {}
	Heap: {1=20, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=3}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20]
	File table: {}
	Heap: {1=20, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=3}
	Count Semaphore table: {}
};
Program 2
{
	Stack: [countDown(latch), return, fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})]
	Symbol Table: {v=RefValue(1, int), latch=1}
	Output: [20]
	File table: {}
	Heap: {1=20, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=3}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2]
	File table: {}
	Heap: {1=20, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 2
{
	Stack: [return, fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})]
	Symbol Table: {v=RefValue(1, int), latch=1}
	Output: [20, 2]
	File table: {}
	Heap: {1=20, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2]
	File table: {}
	Heap: {1=20, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 2
{
	Stack: [return, fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})]
	Symbol Table: {v=RefValue(1, int), latch=1}
	Output: [20, 2]
	File table: {}
	Heap: {1=20, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2]
	File table: {}
	Heap: {1=20, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 2
{
	Stack: [fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2]
	File table: {}
	Heap: {1=20, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2]
	File table: {}
	Heap: {1=20, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 2
{
	Stack: [fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2]
	File table: {}
	Heap: {1=20, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2]
	File table: {}
	Heap: {1=20, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 2
{
	Stack: []
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2]
	File table: {}
	Heap: {1=20, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 3
{
	Stack: [{call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2]
	File table: {}
	Heap: {1=20, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2]
	File table: {}
	Heap: {1=20, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 3
{
	Stack: [{call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2]
	File table: {}
	Heap: {1=20, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2]
	File table: {}
	Heap: {1=20, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 3
{
	Stack: [call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2]
	File table: {}
	Heap: {1=20, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2]
	File table: {}
	Heap: {1=20, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 3
{
	Stack: [call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2]
	File table: {}
	Heap: {1=20, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2]
	File table: {}
	Heap: {1=20, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 3
{
	Stack: [{wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}, return, fork(call [forkBody[v3, cnt]])]
	Symbol Table: {v=RefValue(2, int), latch=1}
	Output: [20, 2]
	File table: {}
	Heap: {1=20, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2]
	File table: {}
	Heap: {1=20, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 3
{
	Stack: [{wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}, return, fork(call [forkBody[v3, cnt]])]
	Symbol Table: {v=RefValue(2, int), latch=1}
	Output: [20, 2]
	File table: {}
	Heap: {1=20, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2]
	File table: {}
	Heap: {1=20, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 3
{
	Stack: [wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}, return, fork(call [forkBody[v3, cnt]])]
	Symbol Table: {v=RefValue(2, int), latch=1}
	Output: [20, 2]
	File table: {}
	Heap: {1=20, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2]
	File table: {}
	Heap: {1=20, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 3
{
	Stack: [wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}, return, fork(call [forkBody[v3, cnt]])]
	Symbol Table: {v=RefValue(2, int), latch=1}
	Output: [20, 2]
	File table: {}
	Heap: {1=20, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2]
	File table: {}
	Heap: {1=20, 2=30, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 3
{
	Stack: [{print(rH(v)), countDown(latch)}, return, fork(call [forkBody[v3, cnt]])]
	Symbol Table: {v=RefValue(2, int), latch=1}
	Output: [20, 2]
	File table: {}
	Heap: {1=20, 2=30, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2]
	File table: {}
	Heap: {1=20, 2=30, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 3
{
	Stack: [{print(rH(v)), countDown(latch)}, return, fork(call [forkBody[v3, cnt]])]
	Symbol Table: {v=RefValue(2, int), latch=1}
	Output: [20, 2]
	File table: {}
	Heap: {1=20, 2=30, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2]
	File table: {}
	Heap: {1=20, 2=30, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 3
{
	Stack: [print(rH(v)), countDown(latch), return, fork(call [forkBody[v3, cnt]])]
	Symbol Table: {v=RefValue(2, int), latch=1}
	Output: [20, 2]
	File table: {}
	Heap: {1=20, 2=30, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2]
	File table: {}
	Heap: {1=20, 2=30, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 3
{
	Stack: [print(rH(v)), countDown(latch), return, fork(call [forkBody[v3, cnt]])]
	Symbol Table: {v=RefValue(2, int), latch=1}
	Output: [20, 2]
	File table: {}
	Heap: {1=20, 2=30, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30]
	File table: {}
	Heap: {1=20, 2=30, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 3
{
	Stack: [countDown(latch), return, fork(call [forkBody[v3, cnt]])]
	Symbol Table: {v=RefValue(2, int), latch=1}
	Output: [20, 2, 30]
	File table: {}
	Heap: {1=20, 2=30, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30]
	File table: {}
	Heap: {1=20, 2=30, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 3
{
	Stack: [countDown(latch), return, fork(call [forkBody[v3, cnt]])]
	Symbol Table: {v=RefValue(2, int), latch=1}
	Output: [20, 2, 30]
	File table: {}
	Heap: {1=20, 2=30, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30, 3]
	File table: {}
	Heap: {1=20, 2=30, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=1}
	Count Semaphore table: {}
};
Program 3
{
	Stack: [return, fork(call [forkBody[v3, cnt]])]
	Symbol Table: {v=RefValue(2, int), latch=1}
	Output: [20, 2, 30, 3]
	File table: {}
	Heap: {1=20, 2=30, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=1}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30, 3]
	File table: {}
	Heap: {1=20, 2=30, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=1}
	Count Semaphore table: {}
};
Program 3
{
	Stack: [return, fork(call [forkBody[v3, cnt]])]
	Symbol Table: {v=RefValue(2, int), latch=1}
	Output: [20, 2, 30, 3]
	File table: {}
	Heap: {1=20, 2=30, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=1}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30, 3]
	File table: {}
	Heap: {1=20, 2=30, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=1}
	Count Semaphore table: {}
};
Program 3
{
	Stack: [fork(call [forkBody[v3, cnt]])]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30, 3]
	File table: {}
	Heap: {1=20, 2=30, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=1}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30, 3]
	File table: {}
	Heap: {1=20, 2=30, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=1}
	Count Semaphore table: {}
};
Program 3
{
	Stack: [fork(call [forkBody[v3, cnt]])]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30, 3]
	File table: {}
	Heap: {1=20, 2=30, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=1}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30, 3]
	File table: {}
	Heap: {1=20, 2=30, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=1}
	Count Semaphore table: {}
};
Program 3
{
	Stack: []
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30, 3]
	File table: {}
	Heap: {1=20, 2=30, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=1}
	Count Semaphore table: {}
};
Program 4
{
	Stack: [call [forkBody[v3, cnt]]]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30, 3]
	File table: {}
	Heap: {1=20, 2=30, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=1}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30, 3]
	File table: {}
	Heap: {1=20, 2=30, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=1}
	Count Semaphore table: {}
};
Program 4
{
	Stack: [call [forkBody[v3, cnt]]]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30, 3]
	File table: {}
	Heap: {1=20, 2=30, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=1}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30, 3]
	File table: {}
	Heap: {1=20, 2=30, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=1}
	Count Semaphore table: {}
};
Program 4
{
	Stack: [{wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}, return]
	Symbol Table: {v=RefValue(3, int), latch=1}
	Output: [20, 2, 30, 3]
	File table: {}
	Heap: {1=20, 2=30, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=1}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30, 3]
	File table: {}
	Heap: {1=20, 2=30, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=1}
	Count Semaphore table: {}
};
Program 4
{
	Stack: [{wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}, return]
	Symbol Table: {v=RefValue(3, int), latch=1}
	Output: [20, 2, 30, 3]
	File table: {}
	Heap: {1=20, 2=30, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=1}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30, 3]
	File table: {}
	Heap: {1=20, 2=30, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=1}
	Count Semaphore table: {}
};
Program 4
{
	Stack: [wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}, return]
	Symbol Table: {v=RefValue(3, int), latch=1}
	Output: [20, 2, 30, 3]
	File table: {}
	Heap: {1=20, 2=30, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=1}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30, 3]
	File table: {}
	Heap: {1=20, 2=30, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=1}
	Count Semaphore table: {}
};
Program 4
{
	Stack: [wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}, return]
	Symbol Table: {v=RefValue(3, int), latch=1}
	Output: [20, 2, 30, 3]
	File table: {}
	Heap: {1=20, 2=30, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=1}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30, 3]
	File table: {}
	Heap: {1=20, 2=30, 3=40}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=1}
	Count Semaphore table: {}
};
Program 4
{
	Stack: [{print(rH(v)), countDown(latch)}, return]
	Symbol Table: {v=RefValue(3, int), latch=1}
	Output: [20, 2, 30, 3]
	File table: {}
	Heap: {1=20, 2=30, 3=40}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=1}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30, 3]
	File table: {}
	Heap: {1=20, 2=30, 3=40}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=1}
	Count Semaphore table: {}
};
Program 4
{
	Stack: [{print(rH(v)), countDown(latch)}, return]
	Symbol Table: {v=RefValue(3, int), latch=1}
	Output: [20, 2, 30, 3]
	File table: {}
	Heap: {1=20, 2=30, 3=40}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=1}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30, 3]
	File table: {}
	Heap: {1=20, 2=30, 3=40}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=1}
	Count Semaphore table: {}
};
Program 4
{
	Stack: [print(rH(v)), countDown(latch), return]
	Symbol Table: {v=RefValue(3, int), latch=1}
	Output: [20, 2, 30, 3]
	File table: {}
	Heap: {1=20, 2=30, 3=40}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=1}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30, 3]
	File table: {}
	Heap: {1=20, 2=30, 3=40}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=1}
	Count Semaphore table: {}
};
Program 4
{
	Stack: [print(rH(v)), countDown(latch), return]
	Symbol Table: {v=RefValue(3, int), latch=1}
	Output: [20, 2, 30, 3]
	File table: {}
	Heap: {1=20, 2=30, 3=40}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=1}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30, 3, 40]
	File table: {}
	Heap: {1=20, 2=30, 3=40}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=1}
	Count Semaphore table: {}
};
Program 4
{
	Stack: [countDown(latch), return]
	Symbol Table: {v=RefValue(3, int), latch=1}
	Output: [20, 2, 30, 3, 40]
	File table: {}
	Heap: {1=20, 2=30, 3=40}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=1}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30, 3, 40]
	File table: {}
	Heap: {1=20, 2=30, 3=40}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=1}
	Count Semaphore table: {}
};
Program 4
{
	Stack: [countDown(latch), return]
	Symbol Table: {v=RefValue(3, int), latch=1}
	Output: [20, 2, 30, 3, 40]
	File table: {}
	Heap: {1=20, 2=30, 3=40}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=1}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30, 3, 40, 4]
	File table: {}
	Heap: {1=20, 2=30, 3=40}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=0}
	Count Semaphore table: {}
};
Program 4
{
	Stack: [return]
	Symbol Table: {v=RefValue(3, int), latch=1}
	Output: [20, 2, 30, 3, 40, 4]
	File table: {}
	Heap: {1=20, 2=30, 3=40}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=0}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30, 3, 40, 4]
	File table: {}
	Heap: {1=20, 2=30, 3=40}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=0}
	Count Semaphore table: {}
};
Program 4
{
	Stack: [return]
	Symbol Table: {v=RefValue(3, int), latch=1}
	Output: [20, 2, 30, 3, 40, 4]
	File table: {}
	Heap: {1=20, 2=30, 3=40}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=0}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [{print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30, 3, 40, 4]
	File table: {}
	Heap: {1=20, 2=30, 3=40}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=0}
	Count Semaphore table: {}
};
Program 4
{
	Stack: []
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30, 3, 40, 4]
	File table: {}
	Heap: {1=20, 2=30, 3=40}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=0}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [{print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30, 3, 40, 4]
	File table: {}
	Heap: {1=20, 2=30, 3=40}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=0}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [print(100), {countDown(cnt), print(100)}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30, 3, 40, 4]
	File table: {}
	Heap: {1=20, 2=30, 3=40}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=0}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [print(100), {countDown(cnt), print(100)}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30, 3, 40, 4]
	File table: {}
	Heap: {1=20, 2=30, 3=40}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=0}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [{countDown(cnt), print(100)}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30, 3, 40, 4, 100]
	File table: {}
	Heap: {1=20, 2=30, 3=40}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=0}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [{countDown(cnt), print(100)}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30, 3, 40, 4, 100]
	File table: {}
	Heap: {1=20, 2=30, 3=40}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=0}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [countDown(cnt), print(100)]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30, 3, 40, 4, 100]
	File table: {}
	Heap: {1=20, 2=30, 3=40}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=0}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [countDown(cnt), print(100)]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30, 3, 40, 4, 100]
	File table: {}
	Heap: {1=20, 2=30, 3=40}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=0}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [print(100)]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30, 3, 40, 4, 100, 1]
	File table: {}
	Heap: {1=20, 2=30, 3=40}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=0}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [print(100)]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30, 3, 40, 4, 100, 1]
	File table: {}
	Heap: {1=20, 2=30, 3=40}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=0}
	Count Semaphore table: {}
};
Program 1
{
	Stack: []
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30, 3, 40, 4, 100, 1, 100]
	File table: {}
	Heap: {1=20, 2=30, 3=40}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=0}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [{procedure[forkBody[v, latch]->{wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}], {Ref(int) v1, {Ref(int) v2, {Ref(int) v3, {int cnt, {new(v1,2), {new(v2,3), {new(v3,4), {newLatch(cnt, rH(v2)), {fork({call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}}}}}}}}}]
	Symbol Table: {}
	Output: []
	File table: {}
	Heap: {}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [procedure[forkBody[v, latch]->{wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}], {Ref(int) v1, {Ref(int) v2, {Ref(int) v3, {int cnt, {new(v1,2), {new(v2,3), {new(v3,4), {newLatch(cnt, rH(v2)), {fork({call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}}}}}}}}]
	Symbol Table: {}
	Output: []
	File table: {}
	Heap: {}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [procedure[forkBody[v, latch]->{wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}], {Ref(int) v1, {Ref(int) v2, {Ref(int) v3, {int cnt, {new(v1,2), {new(v2,3), {new(v3,4), {newLatch(cnt, rH(v2)), {fork({call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}}}}}}}}]
	Symbol Table: {}
	Output: []
	File table: {}
	Heap: {}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [{Ref(int) v1, {Ref(int) v2, {Ref(int) v3, {int cnt, {new(v1,2), {new(v2,3), {new(v3,4), {newLatch(cnt, rH(v2)), {fork({call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}}}}}}}}]
	Symbol Table: {}
	Output: []
	File table: {}
	Heap: {}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [{Ref(int) v1, {Ref(int) v2, {Ref(int) v3, {int cnt, {new(v1,2), {new(v2,3), {new(v3,4), {newLatch(cnt, rH(v2)), {fork({call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}}}}}}}}]
	Symbol Table: {}
	Output: []
	File table: {}
	Heap: {}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [Ref(int) v1, {Ref(int) v2, {Ref(int) v3, {int cnt, {new(v1,2), {new(v2,3), {new(v3,4), {newLatch(cnt, rH(v2)), {fork({call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}}}}}}}]
	Symbol Table: {}
	Output: []
	File table: {}
	Heap: {}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [Ref(int) v1, {Ref(int) v2, {Ref(int) v3, {int cnt, {new(v1,2), {new(v2,3), {new(v3,4), {newLatch(cnt, rH(v2)), {fork({call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}}}}}}}]
	Symbol Table: {}
	Output: []
	File table: {}
	Heap: {}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [{Ref(int) v2, {Ref(int) v3, {int cnt, {new(v1,2), {new(v2,3), {new(v3,4), {newLatch(cnt, rH(v2)), {fork({call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}}}}}}}]
	Symbol Table: {v1=RefValue(0, int)}
	Output: []
	File table: {}
	Heap: {}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [{Ref(int) v2, {Ref(int) v3, {int cnt, {new(v1,2), {new(v2,3), {new(v3,4), {newLatch(cnt, rH(v2)), {fork({call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}}}}}}}]
	Symbol Table: {v1=RefValue(0, int)}
	Output: []
	File table: {}
	Heap: {}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [Ref(int) v2, {Ref(int) v3, {int cnt, {new(v1,2), {new(v2,3), {new(v3,4), {newLatch(cnt, rH(v2)), {fork({call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}}}}}}]
	Symbol Table: {v1=RefValue(0, int)}
	Output: []
	File table: {}
	Heap: {}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [Ref(int) v2, {Ref(int) v3, {int cnt, {new(v1,2), {new(v2,3), {new(v3,4), {newLatch(cnt, rH(v2)), {fork({call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}}}}}}]
	Symbol Table: {v1=RefValue(0, int)}
	Output: []
	File table: {}
	Heap: {}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [{Ref(int) v3, {int cnt, {new(v1,2), {new(v2,3), {new(v3,4), {newLatch(cnt, rH(v2)), {fork({call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}}}}}}]
	Symbol Table: {v1=RefValue(0, int), v2=RefValue(0, int)}
	Output: []
	File table: {}
	Heap: {}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [{Ref(int) v3, {int cnt, {new(v1,2), {new(v2,3), {new(v3,4), {newLatch(cnt, rH(v2)), {fork({call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}}}}}}]
	Symbol Table: {v1=RefValue(0, int), v2=RefValue(0, int)}
	Output: []
	File table: {}
	Heap: {}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [Ref(int) v3, {int cnt, {new(v1,2), {new(v2,3), {new(v3,4), {newLatch(cnt, rH(v2)), {fork({call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}}}}}]
	Symbol Table: {v1=RefValue(0, int), v2=RefValue(0, int)}
	Output: []
	File table: {}
	Heap: {}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [Ref(int) v3, {int cnt, {new(v1,2), {new(v2,3), {new(v3,4), {newLatch(cnt, rH(v2)), {fork({call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}}}}}]
	Symbol Table: {v1=RefValue(0, int), v2=RefValue(0, int)}
	Output: []
	File table: {}
	Heap: {}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [{int cnt, {new(v1,2), {new(v2,3), {new(v3,4), {newLatch(cnt, rH(v2)), {fork({call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}}}}}]
	Symbol Table: {v1=RefValue(0, int), v2=RefValue(0, int), v3=RefValue(0, int)}
	Output: []
	File table: {}
	Heap: {}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [{int cnt, {new(v1,2), {new(v2,3), {new(v3,4), {newLatch(cnt, rH(v2)), {fork({call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}}}}}]
	Symbol Table: {v1=RefValue(0, int), v2=RefValue(0, int), v3=RefValue(0, int)}
	Output: []
	File table: {}
	Heap: {}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [int cnt, {new(v1,2), {new(v2,3), {new(v3,4), {newLatch(cnt, rH(v2)), {fork({call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}}}}]
	Symbol Table: {v1=RefValue(0, int), v2=RefValue(0, int), v3=RefValue(0, int)}
	Output: []
	File table: {}
	Heap: {}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [int cnt, {new(v1,2), {new(v2,3), {new(v3,4), {newLatch(cnt, rH(v2)), {fork({call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}}}}]
	Symbol Table: {v1=RefValue(0, int), v2=RefValue(0, int), v3=RefValue(0, int)}
	Output: []
	File table: {}
	Heap: {}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [{new(v1,2), {new(v2,3), {new(v3,4), {newLatch(cnt, rH(v2)), {fork({call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}}}}]
	Symbol Table: {cnt=0, v1=RefValue(0, int), v2=RefValue(0, int), v3=RefValue(0, int)}
	Output: []
	File table: {}
	Heap: {}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [{new(v1,2), {new(v2,3), {new(v3,4), {newLatch(cnt, rH(v2)), {fork({call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}}}}]
	Symbol Table: {cnt=0, v1=RefValue(0, int), v2=RefValue(0, int), v3=RefValue(0, int)}
	Output: []
	File table: {}
	Heap: {}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [new(v1,2), {new(v2,3), {new(v3,4), {newLatch(cnt, rH(v2)), {fork({call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}}}]
	Symbol Table: {cnt=0, v1=RefValue(0, int), v2=RefValue(0, int), v3=RefValue(0, int)}
	Output: []
	File table: {}
	Heap: {}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [new(v1,2), {new(v2,3), {new(v3,4), {newLatch(cnt, rH(v2)), {fork({call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}}}]
	Symbol Table: {cnt=0, v1=RefValue(0, int), v2=RefValue(0, int), v3=RefValue(0, int)}
	Output: []
	File table: {}
	Heap: {}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [{new(v2,3), {new(v3,4), {newLatch(cnt, rH(v2)), {fork({call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}}}]
	Symbol Table: {cnt=0, v1=RefValue(1, int), v2=RefValue(0, int), v3=RefValue(0, int)}
	Output: []
	File table: {}
	Heap: {1=2}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [{new(v2,3), {new(v3,4), {newLatch(cnt, rH(v2)), {fork({call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}}}]
	Symbol Table: {cnt=0, v1=RefValue(1, int), v2=RefValue(0, int), v3=RefValue(0, int)}
	Output: []
	File table: {}
	Heap: {1=2}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [new(v2,3), {new(v3,4), {newLatch(cnt, rH(v2)), {fork({call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}}]
	Symbol Table: {cnt=0, v1=RefValue(1, int), v2=RefValue(0, int), v3=RefValue(0, int)}
	Output: []
	File table: {}
	Heap: {1=2}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [new(v2,3), {new(v3,4), {newLatch(cnt, rH(v2)), {fork({call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}}]
	Symbol Table: {cnt=0, v1=RefValue(1, int), v2=RefValue(0, int), v3=RefValue(0, int)}
	Output: []
	File table: {}
	Heap: {1=2}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [{new(v3,4), {newLatch(cnt, rH(v2)), {fork({call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}}]
	Symbol Table: {cnt=0, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(0, int)}
	Output: []
	File table: {}
	Heap: {1=2, 2=3}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [{new(v3,4), {newLatch(cnt, rH(v2)), {fork({call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}}]
	Symbol Table: {cnt=0, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(0, int)}
	Output: []
	File table: {}
	Heap: {1=2, 2=3}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [new(v3,4), {newLatch(cnt, rH(v2)), {fork({call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}]
	Symbol Table: {cnt=0, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(0, int)}
	Output: []
	File table: {}
	Heap: {1=2, 2=3}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [new(v3,4), {newLatch(cnt, rH(v2)), {fork({call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}]
	Symbol Table: {cnt=0, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(0, int)}
	Output: []
	File table: {}
	Heap: {1=2, 2=3}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [{newLatch(cnt, rH(v2)), {fork({call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}]
	Symbol Table: {cnt=0, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: []
	File table: {}
	Heap: {1=2, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [{newLatch(cnt, rH(v2)), {fork({call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}]
	Symbol Table: {cnt=0, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: []
	File table: {}
	Heap: {1=2, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [newLatch(cnt, rH(v2)), {fork({call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}]
	Symbol Table: {cnt=0, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: []
	File table: {}
	Heap: {1=2, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [newLatch(cnt, rH(v2)), {fork({call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}]
	Symbol Table: {cnt=0, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: []
	File table: {}
	Heap: {1=2, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [{fork({call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: []
	File table: {}
	Heap: {1=2, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=3}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [{fork({call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: []
	File table: {}
	Heap: {1=2, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=3}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [fork({call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: []
	File table: {}
	Heap: {1=2, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=3}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [fork({call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: []
	File table: {}
	Heap: {1=2, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=3}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [{await(cnt), {print(100), {countDown(cnt), print(100)}}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: []
	File table: {}
	Heap: {1=2, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=3}
	Count Semaphore table: {}
};
Program 2
{
	Stack: [{call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: []
	File table: {}
	Heap: {1=2, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=3}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [{await(cnt), {print(100), {countDown(cnt), print(100)}}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: []
	File table: {}
	Heap: {1=2, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=3}
	Count Semaphore table: {}
};
Program 2
{
	Stack: [{call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: []
	File table: {}
	Heap: {1=2, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=3}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: []
	File table: {}
	Heap: {1=2, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=3}
	Count Semaphore table: {}
};
Program 2
{
	Stack: [call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: []
	File table: {}
	Heap: {1=2, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=3}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: []
	File table: {}
	Heap: {1=2, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=3}
	Count Semaphore table: {}
};
Program 2
{
	Stack: [call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: []
	File table: {}
	Heap: {1=2, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=3}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: []
	File table: {}
	Heap: {1=2, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=3}
	Count Semaphore table: {}
};
Program 2
{
	Stack: [{wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}, return, fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})]
	Symbol Table: {v=RefValue(1, int), latch=1}
	Output: []
	File table: {}
	Heap: {1=2, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=3}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: []
	File table: {}
	Heap: {1=2, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=3}
	Count Semaphore table: {}
};
Program 2
{
	Stack: [{wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}, return, fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})]
	Symbol Table: {v=RefValue(1, int), latch=1}
	Output: []
	File table: {}
	Heap: {1=2, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=3}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: []
	File table: {}
	Heap: {1=2, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=3}
	Count Semaphore table: {}
};
Program 2
{
	Stack: [wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}, return, fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})]
	Symbol Table: {v=RefValue(1, int), latch=1}
	Output: []
	File table: {}
	Heap: {1=2, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=3}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: []
	File table: {}
	Heap: {1=2, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=3}
	Count Semaphore table: {}
};
Program 2
{
	Stack: [wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}, return, fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})]
	Symbol Table: {v=RefValue(1, int), latch=1}
	Output: []
	File table: {}
	Heap: {1=2, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=3}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: []
	File table: {}
	Heap: {1=20, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=3}
	Count Semaphore table: {}
};
Program 2
{
	Stack: [{print(rH(v)), countDown(latch)}, return, fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})]
	Symbol Table: {v=RefValue(1, int), latch=1}
	Output: []
	File table: {}
	Heap: {1=20, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=3}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: []
	File table: {}
	Heap: {1=20, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=3}
	Count Semaphore table: {}
};
Program 2
{
	Stack: [{print(rH(v)), countDown(latch)}, return, fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})]
	Symbol Table: {v=RefValue(1, int), latch=1}
	Output: []
	File table: {}
	Heap: {1=20, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=3}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: []
	File table: {}
	Heap: {1=20, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=3}
	Count Semaphore table: {}
};
Program 2
{
	Stack: [print(rH(v)), countDown(latch), return, fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})]
	Symbol Table: {v=RefValue(1, int), latch=1}
	Output: []
	File table: {}
	Heap: {1=20, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=3}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: []
	File table: {}
	Heap: {1=20, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=3}
	Count Semaphore table: {}
};
Program 2
{
	Stack: [print(rH(v)), countDown(latch), return, fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})]
	Symbol Table: {v=RefValue(1, int), latch=1}
	Output: []
	File table: {}
	Heap: {1=20, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=3}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20]
	File table: {}
	Heap: {1=20, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=3}
	Count Semaphore table: {}
};
Program 2
{
	Stack: [countDown(latch), return, fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})]
	Symbol Table: {v=RefValue(1, int), latch=1}
	Output: [20]
	File table: {}
	Heap: {1=20, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=3}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20]
	File table: {}
	Heap: {1=20, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=3}
	Count Semaphore table: {}
};
Program 2
{
	Stack: [countDown(latch), return, fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})]
	Symbol Table: {v=RefValue(1, int), latch=1}
	Output: [20]
	File table: {}
	Heap: {1=20, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=3}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2]
	File table: {}
	Heap: {1=20, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 2
{
	Stack: [return, fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})]
	Symbol Table: {v=RefValue(1, int), latch=1}
	Output: [20, 2]
	File table: {}
	Heap: {1=20, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2]
	File table: {}
	Heap: {1=20, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 2
{
	Stack: [return, fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})]
	Symbol Table: {v=RefValue(1, int), latch=1}
	Output: [20, 2]
	File table: {}
	Heap: {1=20, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2]
	File table: {}
	Heap: {1=20, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 2
{
	Stack: [fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2]
	File table: {}
	Heap: {1=20, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2]
	File table: {}
	Heap: {1=20, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 2
{
	Stack: [fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2]
	File table: {}
	Heap: {1=20, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2]
	File table: {}
	Heap: {1=20, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 2
{
	Stack: []
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2]
	File table: {}
	Heap: {1=20, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 3
{
	Stack: [{call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2]
	File table: {}
	Heap: {1=20, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2]
	File table: {}
	Heap: {1=20, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 3
{
	Stack: [{call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2]
	File table: {}
	Heap: {1=20, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2]
	File table: {}
	Heap: {1=20, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 3
{
	Stack: [call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2]
	File table: {}
	Heap: {1=20, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2]
	File table: {}
	Heap: {1=20, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 3
{
	Stack: [call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2]
	File table: {}
	Heap: {1=20, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2]
	File table: {}
	Heap: {1=20, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 3
{
	Stack: [{wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}, return, fork(call [forkBody[v3, cnt]])]
	Symbol Table: {v=RefValue(2, int), latch=1}
	Output: [20, 2]
	File table: {}
	Heap: {1=20, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2]
	File table: {}
	Heap: {1=20, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 3
{
	Stack: [{wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}, return, fork(call [forkBody[v3, cnt]])]
	Symbol Table: {v=RefValue(2, int), latch=1}
	Output: [20, 2]
	File table: {}
	Heap: {1=20, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2]
	File table: {}
	Heap: {1=20, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 3
{
	Stack: [wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}, return, fork(call [forkBody[v3, cnt]])]
	Symbol Table: {v=RefValue(2, int), latch=1}
	Output: [20, 2]
	File table: {}
	Heap: {1=20, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2]
	File table: {}
	Heap: {1=20, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 3
{
	Stack: [wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}, return, fork(call [forkBody[v3, cnt]])]
	Symbol Table: {v=RefValue(2, int), latch=1}
	Output: [20, 2]
	File table: {}
	Heap: {1=20, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2]
	File table: {}
	Heap: {1=20, 2=30, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 3
{
	Stack: [{print(rH(v)), countDown(latch)}, return, fork(call [forkBody[v3, cnt]])]
	Symbol Table: {v=RefValue(2, int), latch=1}
	Output: [20, 2]
	File table: {}
	Heap: {1=20, 2=30, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2]
	File table: {}
	Heap: {1=20, 2=30, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 3
{
	Stack: [{print(rH(v)), countDown(latch)}, return, fork(call [forkBody[v3, cnt]])]
	Symbol Table: {v=RefValue(2, int), latch=1}
	Output: [20, 2]
	File table: {}
	Heap: {1=20, 2=30, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2]
	File table: {}
	Heap: {1=20, 2=30, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 3
{
	Stack: [print(rH(v)), countDown(latch), return, fork(call [forkBody[v3, cnt]])]
	Symbol Table: {v=RefValue(2, int), latch=1}
	Output: [20, 2]
	File table: {}
	Heap: {1=20, 2=30, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2]
	File table: {}
	Heap: {1=20, 2=30, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 3
{
	Stack: [print(rH(v)), countDown(latch), return, fork(call [forkBody[v3, cnt]])]
	Symbol Table: {v=RefValue(2, int), latch=1}
	Output: [20, 2]
	File table: {}
	Heap: {1=20, 2=30, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30]
	File table: {}
	Heap: {1=20, 2=30, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 3
{
	Stack: [countDown(latch), return, fork(call [forkBody[v3, cnt]])]
	Symbol Table: {v=RefValue(2, int), latch=1}
	Output: [20, 2, 30]
	File table: {}
	Heap: {1=20, 2=30, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30]
	File table: {}
	Heap: {1=20, 2=30, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 3
{
	Stack: [countDown(latch), return, fork(call [forkBody[v3, cnt]])]
	Symbol Table: {v=RefValue(2, int), latch=1}
	Output: [20, 2, 30]
	File table: {}
	Heap: {1=20, 2=30, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30, 3]
	File table: {}
	Heap: {1=20, 2=30, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=1}
	Count Semaphore table: {}
};
Program 3
{
	Stack: [return, fork(call [forkBody[v3, cnt]])]
	Symbol Table: {v=RefValue(2, int), latch=1}
	Output: [20, 2, 30, 3]
	File table: {}
	Heap: {1=20, 2=30, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=1}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30, 3]
	File table: {}
	Heap: {1=20, 2=30, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=1}
	Count Semaphore table: {}
};
Program 3
{
	Stack: [return, fork(call [forkBody[v3, cnt]])]
	Symbol Table: {v=RefValue(2, int), latch=1}
	Output: [20, 2, 30, 3]
	File table: {}
	Heap: {1=20, 2=30, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=1}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30, 3]
	File table: {}
	Heap: {1=20, 2=30, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=1}
	Count Semaphore table: {}
};
Program 3
{
	Stack: [fork(call [forkBody[v3, cnt]])]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30, 3]
	File table: {}
	Heap: {1=20, 2=30, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=1}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30, 3]
	File table: {}
	Heap: {1=20, 2=30, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=1}
	Count Semaphore table: {}
};
Program 3
{
	Stack: [fork(call [forkBody[v3, cnt]])]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30, 3]
	File table: {}
	Heap: {1=20, 2=30, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=1}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30, 3]
	File table: {}
	Heap: {1=20, 2=30, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=1}
	Count Semaphore table: {}
};
Program 3
{
	Stack: []
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30, 3]
	File table: {}
	Heap: {1=20, 2=30, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=1}
	Count Semaphore table: {}
};
Program 4
{
	Stack: [call [forkBody[v3, cnt]]]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30, 3]
	File table: {}
	Heap: {1=20, 2=30, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=1}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30, 3]
	File table: {}
	Heap: {1=20, 2=30, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=1}
	Count Semaphore table: {}
};
Program 4
{
	Stack: [call [forkBody[v3, cnt]]]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30, 3]
	File table: {}
	Heap: {1=20, 2=30, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=1}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30, 3]
	File table: {}
	Heap: {1=20, 2=30, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=1}
	Count Semaphore table: {}
};
Program 4
{
	Stack: [{wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}, return]
	Symbol Table: {v=RefValue(3, int), latch=1}
	Output: [20, 2, 30, 3]
	File table: {}
	Heap: {1=20, 2=30, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=1}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30, 3]
	File table: {}
	Heap: {1=20, 2=30, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=1}
	Count Semaphore table: {}
};
Program 4
{
	Stack: [{wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}, return]
	Symbol Table: {v=RefValue(3, int), latch=1}
	Output: [20, 2, 30, 3]
	File table: {}
	Heap: {1=20, 2=30, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=1}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30, 3]
	File table: {}
	Heap: {1=20, 2=30, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=1}
	Count Semaphore table: {}
};
Program 4
{
	Stack: [wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}, return]
	Symbol Table: {v=RefValue(3, int), latch=1}
	Output: [20, 2, 30, 3]
	File table: {}
	Heap: {1=20, 2=30, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=1}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30, 3]
	File table: {}
	Heap: {1=20, 2=30, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=1}
	Count Semaphore table: {}
};
Program 4
{
	Stack: [wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}, return]
	Symbol Table: {v=RefValue(3, int), latch=1}
	Output: [20, 2, 30, 3]
	File table: {}
	Heap: {1=20, 2=30, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=1}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30, 3]
	File table: {}
	Heap: {1=20, 2=30, 3=40}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=1}
	Count Semaphore table: {}
};
Program 4
{
	Stack: [{print(rH(v)), countDown(latch)}, return]
	Symbol Table: {v=RefValue(3, int), latch=1}
	Output: [20, 2, 30, 3]
	File table: {}
	Heap: {1=20, 2=30, 3=40}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=1}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30, 3]
	File table: {}
	Heap: {1=20, 2=30, 3=40}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=1}
	Count Semaphore table: {}
};
Program 4
{
	Stack: [{print(rH(v)), countDown(latch)}, return]
	Symbol Table: {v=RefValue(3, int), latch=1}
	Output: [20, 2, 30, 3]
	File table: {}
	Heap: {1=20, 2=30, 3=40}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=1}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30, 3]
	File table: {}
	Heap: {1=20, 2=30, 3=40}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=1}
	Count Semaphore table: {}
};
Program 4
{
	Stack: [print(rH(v)), countDown(latch), return]
	Symbol Table: {v=RefValue(3, int), latch=1}
	Output: [20, 2, 30, 3]
	File table: {}
	Heap: {1=20, 2=30, 3=40}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=1}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30, 3]
	File table: {}
	Heap: {1=20, 2=30, 3=40}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=1}
	Count Semaphore table: {}
};
Program 4
{
	Stack: [print(rH(v)), countDown(latch), return]
	Symbol Table: {v=RefValue(3, int), latch=1}
	Output: [20, 2, 30, 3]
	File table: {}
	Heap: {1=20, 2=30, 3=40}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=1}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30, 3, 40]
	File table: {}
	Heap: {1=20, 2=30, 3=40}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=1}
	Count Semaphore table: {}
};
Program 4
{
	Stack: [countDown(latch), return]
	Symbol Table: {v=RefValue(3, int), latch=1}
	Output: [20, 2, 30, 3, 40]
	File table: {}
	Heap: {1=20, 2=30, 3=40}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=1}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30, 3, 40]
	File table: {}
	Heap: {1=20, 2=30, 3=40}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=1}
	Count Semaphore table: {}
};
Program 4
{
	Stack: [countDown(latch), return]
	Symbol Table: {v=RefValue(3, int), latch=1}
	Output: [20, 2, 30, 3, 40]
	File table: {}
	Heap: {1=20, 2=30, 3=40}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=1}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30, 3, 40, 4]
	File table: {}
	Heap: {1=20, 2=30, 3=40}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=0}
	Count Semaphore table: {}
};
Program 4
{
	Stack: [return]
	Symbol Table: {v=RefValue(3, int), latch=1}
	Output: [20, 2, 30, 3, 40, 4]
	File table: {}
	Heap: {1=20, 2=30, 3=40}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=0}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30, 3, 40, 4]
	File table: {}
	Heap: {1=20, 2=30, 3=40}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=0}
	Count Semaphore table: {}
};
Program 4
{
	Stack: [return]
	Symbol Table: {v=RefValue(3, int), latch=1}
	Output: [20, 2, 30, 3, 40, 4]
	File table: {}
	Heap: {1=20, 2=30, 3=40}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=0}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [{print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30, 3, 40, 4]
	File table: {}
	Heap: {1=20, 2=30, 3=40}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=0}
	Count Semaphore table: {}
};
Program 4
{
	Stack: []
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30, 3, 40, 4]
	File table: {}
	Heap: {1=20, 2=30, 3=40}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=0}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [{print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30, 3, 40, 4]
	File table: {}
	Heap: {1=20, 2=30, 3=40}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=0}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [print(100), {countDown(cnt), print(100)}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30, 3, 40, 4]
	File table: {}
	Heap: {1=20, 2=30, 3=40}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=0}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [print(100), {countDown(cnt), print(100)}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30, 3, 40, 4]
	File table: {}
	Heap: {1=20, 2=30, 3=40}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=0}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [{countDown(cnt), print(100)}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30, 3, 40, 4, 100]
	File table: {}
	Heap: {1=20, 2=30, 3=40}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=0}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [{countDown(cnt), print(100)}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30, 3, 40, 4, 100]
	File table: {}
	Heap: {1=20, 2=30, 3=40}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=0}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [countDown(cnt), print(100)]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30, 3, 40, 4, 100]
	File table: {}
	Heap: {1=20, 2=30, 3=40}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=0}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [countDown(cnt), print(100)]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30, 3, 40, 4, 100]
	File table: {}
	Heap: {1=20, 2=30, 3=40}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=0}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [print(100)]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30, 3, 40, 4, 100, 1]
	File table: {}
	Heap: {1=20, 2=30, 3=40}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=0}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [print(100)]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30, 3, 40, 4, 100, 1]
	File table: {}
	Heap: {1=20, 2=30, 3=40}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=0}
	Count Semaphore table: {}
};
Program 1
{
	Stack: []
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30, 3, 40, 4, 100, 1, 100]
	File table: {}
	Heap: {1=20, 2=30, 3=40}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=0}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [{procedure[forkBody[v, latch]->{wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}], {Ref(int) v1, {Ref(int) v2, {Ref(int) v3, {int cnt, {new(v1,2), {new(v2,3), {new(v3,4), {newLatch(cnt, rH(v2)), {fork({call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}}}}}}}}}]
	Symbol Table: {}
	Output: []
	File table: {}
	Heap: {}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [procedure[forkBody[v, latch]->{wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}], {Ref(int) v1, {Ref(int) v2, {Ref(int) v3, {int cnt, {new(v1,2), {new(v2,3), {new(v3,4), {newLatch(cnt, rH(v2)), {fork({call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}}}}}}}}]
	Symbol Table: {}
	Output: []
	File table: {}
	Heap: {}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [procedure[forkBody[v, latch]->{wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}], {Ref(int) v1, {Ref(int) v2, {Ref(int) v3, {int cnt, {new(v1,2), {new(v2,3), {new(v3,4), {newLatch(cnt, rH(v2)), {fork({call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}}}}}}}}]
	Symbol Table: {}
	Output: []
	File table: {}
	Heap: {}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [{Ref(int) v1, {Ref(int) v2, {Ref(int) v3, {int cnt, {new(v1,2), {new(v2,3), {new(v3,4), {newLatch(cnt, rH(v2)), {fork({call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}}}}}}}}]
	Symbol Table: {}
	Output: []
	File table: {}
	Heap: {}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [{Ref(int) v1, {Ref(int) v2, {Ref(int) v3, {int cnt, {new(v1,2), {new(v2,3), {new(v3,4), {newLatch(cnt, rH(v2)), {fork({call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}}}}}}}}]
	Symbol Table: {}
	Output: []
	File table: {}
	Heap: {}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [Ref(int) v1, {Ref(int) v2, {Ref(int) v3, {int cnt, {new(v1,2), {new(v2,3), {new(v3,4), {newLatch(cnt, rH(v2)), {fork({call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}}}}}}}]
	Symbol Table: {}
	Output: []
	File table: {}
	Heap: {}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [Ref(int) v1, {Ref(int) v2, {Ref(int) v3, {int cnt, {new(v1,2), {new(v2,3), {new(v3,4), {newLatch(cnt, rH(v2)), {fork({call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}}}}}}}]
	Symbol Table: {}
	Output: []
	File table: {}
	Heap: {}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [{Ref(int) v2, {Ref(int) v3, {int cnt, {new(v1,2), {new(v2,3), {new(v3,4), {newLatch(cnt, rH(v2)), {fork({call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}}}}}}}]
	Symbol Table: {v1=RefValue(0, int)}
	Output: []
	File table: {}
	Heap: {}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [{Ref(int) v2, {Ref(int) v3, {int cnt, {new(v1,2), {new(v2,3), {new(v3,4), {newLatch(cnt, rH(v2)), {fork({call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}}}}}}}]
	Symbol Table: {v1=RefValue(0, int)}
	Output: []
	File table: {}
	Heap: {}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [Ref(int) v2, {Ref(int) v3, {int cnt, {new(v1,2), {new(v2,3), {new(v3,4), {newLatch(cnt, rH(v2)), {fork({call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}}}}}}]
	Symbol Table: {v1=RefValue(0, int)}
	Output: []
	File table: {}
	Heap: {}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [Ref(int) v2, {Ref(int) v3, {int cnt, {new(v1,2), {new(v2,3), {new(v3,4), {newLatch(cnt, rH(v2)), {fork({call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}}}}}}]
	Symbol Table: {v1=RefValue(0, int)}
	Output: []
	File table: {}
	Heap: {}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [{Ref(int) v3, {int cnt, {new(v1,2), {new(v2,3), {new(v3,4), {newLatch(cnt, rH(v2)), {fork({call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}}}}}}]
	Symbol Table: {v1=RefValue(0, int), v2=RefValue(0, int)}
	Output: []
	File table: {}
	Heap: {}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [{Ref(int) v3, {int cnt, {new(v1,2), {new(v2,3), {new(v3,4), {newLatch(cnt, rH(v2)), {fork({call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}}}}}}]
	Symbol Table: {v1=RefValue(0, int), v2=RefValue(0, int)}
	Output: []
	File table: {}
	Heap: {}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [Ref(int) v3, {int cnt, {new(v1,2), {new(v2,3), {new(v3,4), {newLatch(cnt, rH(v2)), {fork({call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}}}}}]
	Symbol Table: {v1=RefValue(0, int), v2=RefValue(0, int)}
	Output: []
	File table: {}
	Heap: {}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [Ref(int) v3, {int cnt, {new(v1,2), {new(v2,3), {new(v3,4), {newLatch(cnt, rH(v2)), {fork({call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}}}}}]
	Symbol Table: {v1=RefValue(0, int), v2=RefValue(0, int)}
	Output: []
	File table: {}
	Heap: {}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [{int cnt, {new(v1,2), {new(v2,3), {new(v3,4), {newLatch(cnt, rH(v2)), {fork({call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}}}}}]
	Symbol Table: {v1=RefValue(0, int), v2=RefValue(0, int), v3=RefValue(0, int)}
	Output: []
	File table: {}
	Heap: {}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [{int cnt, {new(v1,2), {new(v2,3), {new(v3,4), {newLatch(cnt, rH(v2)), {fork({call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}}}}}]
	Symbol Table: {v1=RefValue(0, int), v2=RefValue(0, int), v3=RefValue(0, int)}
	Output: []
	File table: {}
	Heap: {}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [int cnt, {new(v1,2), {new(v2,3), {new(v3,4), {newLatch(cnt, rH(v2)), {fork({call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}}}}]
	Symbol Table: {v1=RefValue(0, int), v2=RefValue(0, int), v3=RefValue(0, int)}
	Output: []
	File table: {}
	Heap: {}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [int cnt, {new(v1,2), {new(v2,3), {new(v3,4), {newLatch(cnt, rH(v2)), {fork({call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}}}}]
	Symbol Table: {v1=RefValue(0, int), v2=RefValue(0, int), v3=RefValue(0, int)}
	Output: []
	File table: {}
	Heap: {}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [{new(v1,2), {new(v2,3), {new(v3,4), {newLatch(cnt, rH(v2)), {fork({call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}}}}]
	Symbol Table: {cnt=0, v1=RefValue(0, int), v2=RefValue(0, int), v3=RefValue(0, int)}
	Output: []
	File table: {}
	Heap: {}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [{new(v1,2), {new(v2,3), {new(v3,4), {newLatch(cnt, rH(v2)), {fork({call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}}}}]
	Symbol Table: {cnt=0, v1=RefValue(0, int), v2=RefValue(0, int), v3=RefValue(0, int)}
	Output: []
	File table: {}
	Heap: {}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [new(v1,2), {new(v2,3), {new(v3,4), {newLatch(cnt, rH(v2)), {fork({call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}}}]
	Symbol Table: {cnt=0, v1=RefValue(0, int), v2=RefValue(0, int), v3=RefValue(0, int)}
	Output: []
	File table: {}
	Heap: {}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [new(v1,2), {new(v2,3), {new(v3,4), {newLatch(cnt, rH(v2)), {fork({call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}}}]
	Symbol Table: {cnt=0, v1=RefValue(0, int), v2=RefValue(0, int), v3=RefValue(0, int)}
	Output: []
	File table: {}
	Heap: {}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [{new(v2,3), {new(v3,4), {newLatch(cnt, rH(v2)), {fork({call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}}}]
	Symbol Table: {cnt=0, v1=RefValue(1, int), v2=RefValue(0, int), v3=RefValue(0, int)}
	Output: []
	File table: {}
	Heap: {1=2}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [{new(v2,3), {new(v3,4), {newLatch(cnt, rH(v2)), {fork({call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}}}]
	Symbol Table: {cnt=0, v1=RefValue(1, int), v2=RefValue(0, int), v3=RefValue(0, int)}
	Output: []
	File table: {}
	Heap: {1=2}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [new(v2,3), {new(v3,4), {newLatch(cnt, rH(v2)), {fork({call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}}]
	Symbol Table: {cnt=0, v1=RefValue(1, int), v2=RefValue(0, int), v3=RefValue(0, int)}
	Output: []
	File table: {}
	Heap: {1=2}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [new(v2,3), {new(v3,4), {newLatch(cnt, rH(v2)), {fork({call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}}]
	Symbol Table: {cnt=0, v1=RefValue(1, int), v2=RefValue(0, int), v3=RefValue(0, int)}
	Output: []
	File table: {}
	Heap: {1=2}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [{new(v3,4), {newLatch(cnt, rH(v2)), {fork({call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}}]
	Symbol Table: {cnt=0, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(0, int)}
	Output: []
	File table: {}
	Heap: {1=2, 2=3}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [{new(v3,4), {newLatch(cnt, rH(v2)), {fork({call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}}]
	Symbol Table: {cnt=0, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(0, int)}
	Output: []
	File table: {}
	Heap: {1=2, 2=3}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [new(v3,4), {newLatch(cnt, rH(v2)), {fork({call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}]
	Symbol Table: {cnt=0, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(0, int)}
	Output: []
	File table: {}
	Heap: {1=2, 2=3}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [new(v3,4), {newLatch(cnt, rH(v2)), {fork({call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}]
	Symbol Table: {cnt=0, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(0, int)}
	Output: []
	File table: {}
	Heap: {1=2, 2=3}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [{newLatch(cnt, rH(v2)), {fork({call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}]
	Symbol Table: {cnt=0, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: []
	File table: {}
	Heap: {1=2, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [{newLatch(cnt, rH(v2)), {fork({call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}]
	Symbol Table: {cnt=0, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: []
	File table: {}
	Heap: {1=2, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [newLatch(cnt, rH(v2)), {fork({call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}]
	Symbol Table: {cnt=0, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: []
	File table: {}
	Heap: {1=2, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [newLatch(cnt, rH(v2)), {fork({call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}]
	Symbol Table: {cnt=0, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: []
	File table: {}
	Heap: {1=2, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [{fork({call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: []
	File table: {}
	Heap: {1=2, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=3}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [{fork({call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: []
	File table: {}
	Heap: {1=2, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=3}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [fork({call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: []
	File table: {}
	Heap: {1=2, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=3}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [fork({call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: []
	File table: {}
	Heap: {1=2, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=3}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [{await(cnt), {print(100), {countDown(cnt), print(100)}}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: []
	File table: {}
	Heap: {1=2, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=3}
	Count Semaphore table: {}
};
Program 2
{
	Stack: [{call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: []
	File table: {}
	Heap: {1=2, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=3}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [{procedure[forkBody[v, latch]->{wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}], {Ref(int) v1, {Ref(int) v2, {Ref(int) v3, {int cnt, {new(v1,2), {new(v2,3), {new(v3,4), {newLatch(cnt, rH(v2)), {fork({call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}}}}}}}}}]
	Symbol Table: {}
	Output: []
	File table: {}
	Heap: {}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [procedure[forkBody[v, latch]->{wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}], {Ref(int) v1, {Ref(int) v2, {Ref(int) v3, {int cnt, {new(v1,2), {new(v2,3), {new(v3,4), {newLatch(cnt, rH(v2)), {fork({call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}}}}}}}}]
	Symbol Table: {}
	Output: []
	File table: {}
	Heap: {}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [procedure[forkBody[v, latch]->{wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}], {Ref(int) v1, {Ref(int) v2, {Ref(int) v3, {int cnt, {new(v1,2), {new(v2,3), {new(v3,4), {newLatch(cnt, rH(v2)), {fork({call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}}}}}}}}]
	Symbol Table: {}
	Output: []
	File table: {}
	Heap: {}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [{Ref(int) v1, {Ref(int) v2, {Ref(int) v3, {int cnt, {new(v1,2), {new(v2,3), {new(v3,4), {newLatch(cnt, rH(v2)), {fork({call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}}}}}}}}]
	Symbol Table: {}
	Output: []
	File table: {}
	Heap: {}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [{Ref(int) v1, {Ref(int) v2, {Ref(int) v3, {int cnt, {new(v1,2), {new(v2,3), {new(v3,4), {newLatch(cnt, rH(v2)), {fork({call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}}}}}}}}]
	Symbol Table: {}
	Output: []
	File table: {}
	Heap: {}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [Ref(int) v1, {Ref(int) v2, {Ref(int) v3, {int cnt, {new(v1,2), {new(v2,3), {new(v3,4), {newLatch(cnt, rH(v2)), {fork({call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}}}}}}}]
	Symbol Table: {}
	Output: []
	File table: {}
	Heap: {}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [Ref(int) v1, {Ref(int) v2, {Ref(int) v3, {int cnt, {new(v1,2), {new(v2,3), {new(v3,4), {newLatch(cnt, rH(v2)), {fork({call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}}}}}}}]
	Symbol Table: {}
	Output: []
	File table: {}
	Heap: {}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [{Ref(int) v2, {Ref(int) v3, {int cnt, {new(v1,2), {new(v2,3), {new(v3,4), {newLatch(cnt, rH(v2)), {fork({call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}}}}}}}]
	Symbol Table: {v1=RefValue(0, int)}
	Output: []
	File table: {}
	Heap: {}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [{Ref(int) v2, {Ref(int) v3, {int cnt, {new(v1,2), {new(v2,3), {new(v3,4), {newLatch(cnt, rH(v2)), {fork({call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}}}}}}}]
	Symbol Table: {v1=RefValue(0, int)}
	Output: []
	File table: {}
	Heap: {}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [Ref(int) v2, {Ref(int) v3, {int cnt, {new(v1,2), {new(v2,3), {new(v3,4), {newLatch(cnt, rH(v2)), {fork({call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}}}}}}]
	Symbol Table: {v1=RefValue(0, int)}
	Output: []
	File table: {}
	Heap: {}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [Ref(int) v2, {Ref(int) v3, {int cnt, {new(v1,2), {new(v2,3), {new(v3,4), {newLatch(cnt, rH(v2)), {fork({call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}}}}}}]
	Symbol Table: {v1=RefValue(0, int)}
	Output: []
	File table: {}
	Heap: {}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [{Ref(int) v3, {int cnt, {new(v1,2), {new(v2,3), {new(v3,4), {newLatch(cnt, rH(v2)), {fork({call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}}}}}}]
	Symbol Table: {v1=RefValue(0, int), v2=RefValue(0, int)}
	Output: []
	File table: {}
	Heap: {}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [{Ref(int) v3, {int cnt, {new(v1,2), {new(v2,3), {new(v3,4), {newLatch(cnt, rH(v2)), {fork({call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}}}}}}]
	Symbol Table: {v1=RefValue(0, int), v2=RefValue(0, int)}
	Output: []
	File table: {}
	Heap: {}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [Ref(int) v3, {int cnt, {new(v1,2), {new(v2,3), {new(v3,4), {newLatch(cnt, rH(v2)), {fork({call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}}}}}]
	Symbol Table: {v1=RefValue(0, int), v2=RefValue(0, int)}
	Output: []
	File table: {}
	Heap: {}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [Ref(int) v3, {int cnt, {new(v1,2), {new(v2,3), {new(v3,4), {newLatch(cnt, rH(v2)), {fork({call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}}}}}]
	Symbol Table: {v1=RefValue(0, int), v2=RefValue(0, int)}
	Output: []
	File table: {}
	Heap: {}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [{int cnt, {new(v1,2), {new(v2,3), {new(v3,4), {newLatch(cnt, rH(v2)), {fork({call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}}}}}]
	Symbol Table: {v1=RefValue(0, int), v2=RefValue(0, int), v3=RefValue(0, int)}
	Output: []
	File table: {}
	Heap: {}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [{int cnt, {new(v1,2), {new(v2,3), {new(v3,4), {newLatch(cnt, rH(v2)), {fork({call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}}}}}]
	Symbol Table: {v1=RefValue(0, int), v2=RefValue(0, int), v3=RefValue(0, int)}
	Output: []
	File table: {}
	Heap: {}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [int cnt, {new(v1,2), {new(v2,3), {new(v3,4), {newLatch(cnt, rH(v2)), {fork({call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}}}}]
	Symbol Table: {v1=RefValue(0, int), v2=RefValue(0, int), v3=RefValue(0, int)}
	Output: []
	File table: {}
	Heap: {}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [int cnt, {new(v1,2), {new(v2,3), {new(v3,4), {newLatch(cnt, rH(v2)), {fork({call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}}}}]
	Symbol Table: {v1=RefValue(0, int), v2=RefValue(0, int), v3=RefValue(0, int)}
	Output: []
	File table: {}
	Heap: {}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [{new(v1,2), {new(v2,3), {new(v3,4), {newLatch(cnt, rH(v2)), {fork({call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}}}}]
	Symbol Table: {cnt=0, v1=RefValue(0, int), v2=RefValue(0, int), v3=RefValue(0, int)}
	Output: []
	File table: {}
	Heap: {}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [{new(v1,2), {new(v2,3), {new(v3,4), {newLatch(cnt, rH(v2)), {fork({call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}}}}]
	Symbol Table: {cnt=0, v1=RefValue(0, int), v2=RefValue(0, int), v3=RefValue(0, int)}
	Output: []
	File table: {}
	Heap: {}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [new(v1,2), {new(v2,3), {new(v3,4), {newLatch(cnt, rH(v2)), {fork({call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}}}]
	Symbol Table: {cnt=0, v1=RefValue(0, int), v2=RefValue(0, int), v3=RefValue(0, int)}
	Output: []
	File table: {}
	Heap: {}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [new(v1,2), {new(v2,3), {new(v3,4), {newLatch(cnt, rH(v2)), {fork({call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}}}]
	Symbol Table: {cnt=0, v1=RefValue(0, int), v2=RefValue(0, int), v3=RefValue(0, int)}
	Output: []
	File table: {}
	Heap: {}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [{new(v2,3), {new(v3,4), {newLatch(cnt, rH(v2)), {fork({call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}}}]
	Symbol Table: {cnt=0, v1=RefValue(1, int), v2=RefValue(0, int), v3=RefValue(0, int)}
	Output: []
	File table: {}
	Heap: {1=2}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [{new(v2,3), {new(v3,4), {newLatch(cnt, rH(v2)), {fork({call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}}}]
	Symbol Table: {cnt=0, v1=RefValue(1, int), v2=RefValue(0, int), v3=RefValue(0, int)}
	Output: []
	File table: {}
	Heap: {1=2}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [new(v2,3), {new(v3,4), {newLatch(cnt, rH(v2)), {fork({call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}}]
	Symbol Table: {cnt=0, v1=RefValue(1, int), v2=RefValue(0, int), v3=RefValue(0, int)}
	Output: []
	File table: {}
	Heap: {1=2}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [new(v2,3), {new(v3,4), {newLatch(cnt, rH(v2)), {fork({call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}}]
	Symbol Table: {cnt=0, v1=RefValue(1, int), v2=RefValue(0, int), v3=RefValue(0, int)}
	Output: []
	File table: {}
	Heap: {1=2}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [{new(v3,4), {newLatch(cnt, rH(v2)), {fork({call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}}]
	Symbol Table: {cnt=0, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(0, int)}
	Output: []
	File table: {}
	Heap: {1=2, 2=3}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [{new(v3,4), {newLatch(cnt, rH(v2)), {fork({call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}}]
	Symbol Table: {cnt=0, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(0, int)}
	Output: []
	File table: {}
	Heap: {1=2, 2=3}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [new(v3,4), {newLatch(cnt, rH(v2)), {fork({call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}]
	Symbol Table: {cnt=0, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(0, int)}
	Output: []
	File table: {}
	Heap: {1=2, 2=3}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [new(v3,4), {newLatch(cnt, rH(v2)), {fork({call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}]
	Symbol Table: {cnt=0, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(0, int)}
	Output: []
	File table: {}
	Heap: {1=2, 2=3}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [{newLatch(cnt, rH(v2)), {fork({call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}]
	Symbol Table: {cnt=0, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: []
	File table: {}
	Heap: {1=2, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [{newLatch(cnt, rH(v2)), {fork({call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}]
	Symbol Table: {cnt=0, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: []
	File table: {}
	Heap: {1=2, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [newLatch(cnt, rH(v2)), {fork({call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}]
	Symbol Table: {cnt=0, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: []
	File table: {}
	Heap: {1=2, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [newLatch(cnt, rH(v2)), {fork({call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}]
	Symbol Table: {cnt=0, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: []
	File table: {}
	Heap: {1=2, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [{fork({call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: []
	File table: {}
	Heap: {1=2, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=3}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [{fork({call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: []
	File table: {}
	Heap: {1=2, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=3}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [fork({call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: []
	File table: {}
	Heap: {1=2, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=3}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [fork({call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: []
	File table: {}
	Heap: {1=2, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=3}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [{await(cnt), {print(100), {countDown(cnt), print(100)}}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: []
	File table: {}
	Heap: {1=2, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=3}
	Count Semaphore table: {}
};
Program 2
{
	Stack: [{call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: []
	File table: {}
	Heap: {1=2, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=3}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [{await(cnt), {print(100), {countDown(cnt), print(100)}}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: []
	File table: {}
	Heap: {1=2, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=3}
	Count Semaphore table: {}
};
Program 2
{
	Stack: [{call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: []
	File table: {}
	Heap: {1=2, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=3}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: []
	File table: {}
	Heap: {1=2, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=3}
	Count Semaphore table: {}
};
Program 2
{
	Stack: [call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: []
	File table: {}
	Heap: {1=2, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=3}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: []
	File table: {}
	Heap: {1=2, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=3}
	Count Semaphore table: {}
};
Program 2
{
	Stack: [call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: []
	File table: {}
	Heap: {1=2, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=3}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: []
	File table: {}
	Heap: {1=2, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=3}
	Count Semaphore table: {}
};
Program 2
{
	Stack: [{wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}, return, fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})]
	Symbol Table: {v=RefValue(1, int), latch=1}
	Output: []
	File table: {}
	Heap: {1=2, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=3}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: []
	File table: {}
	Heap: {1=2, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=3}
	Count Semaphore table: {}
};
Program 2
{
	Stack: [{wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}, return, fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})]
	Symbol Table: {v=RefValue(1, int), latch=1}
	Output: []
	File table: {}
	Heap: {1=2, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=3}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: []
	File table: {}
	Heap: {1=2, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=3}
	Count Semaphore table: {}
};
Program 2
{
	Stack: [wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}, return, fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})]
	Symbol Table: {v=RefValue(1, int), latch=1}
	Output: []
	File table: {}
	Heap: {1=2, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=3}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: []
	File table: {}
	Heap: {1=2, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=3}
	Count Semaphore table: {}
};
Program 2
{
	Stack: [wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}, return, fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})]
	Symbol Table: {v=RefValue(1, int), latch=1}
	Output: []
	File table: {}
	Heap: {1=2, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=3}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: []
	File table: {}
	Heap: {1=20, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=3}
	Count Semaphore table: {}
};
Program 2
{
	Stack: [{print(rH(v)), countDown(latch)}, return, fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})]
	Symbol Table: {v=RefValue(1, int), latch=1}
	Output: []
	File table: {}
	Heap: {1=20, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=3}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: []
	File table: {}
	Heap: {1=20, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=3}
	Count Semaphore table: {}
};
Program 2
{
	Stack: [{print(rH(v)), countDown(latch)}, return, fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})]
	Symbol Table: {v=RefValue(1, int), latch=1}
	Output: []
	File table: {}
	Heap: {1=20, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=3}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: []
	File table: {}
	Heap: {1=20, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=3}
	Count Semaphore table: {}
};
Program 2
{
	Stack: [print(rH(v)), countDown(latch), return, fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})]
	Symbol Table: {v=RefValue(1, int), latch=1}
	Output: []
	File table: {}
	Heap: {1=20, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=3}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: []
	File table: {}
	Heap: {1=20, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=3}
	Count Semaphore table: {}
};
Program 2
{
	Stack: [print(rH(v)), countDown(latch), return, fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})]
	Symbol Table: {v=RefValue(1, int), latch=1}
	Output: []
	File table: {}
	Heap: {1=20, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=3}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20]
	File table: {}
	Heap: {1=20, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=3}
	Count Semaphore table: {}
};
Program 2
{
	Stack: [countDown(latch), return, fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})]
	Symbol Table: {v=RefValue(1, int), latch=1}
	Output: [20]
	File table: {}
	Heap: {1=20, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=3}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20]
	File table: {}
	Heap: {1=20, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=3}
	Count Semaphore table: {}
};
Program 2
{
	Stack: [countDown(latch), return, fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})]
	Symbol Table: {v=RefValue(1, int), latch=1}
	Output: [20]
	File table: {}
	Heap: {1=20, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=3}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2]
	File table: {}
	Heap: {1=20, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 2
{
	Stack: [return, fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})]
	Symbol Table: {v=RefValue(1, int), latch=1}
	Output: [20, 2]
	File table: {}
	Heap: {1=20, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2]
	File table: {}
	Heap: {1=20, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 2
{
	Stack: [return, fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})]
	Symbol Table: {v=RefValue(1, int), latch=1}
	Output: [20, 2]
	File table: {}
	Heap: {1=20, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2]
	File table: {}
	Heap: {1=20, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 2
{
	Stack: [fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2]
	File table: {}
	Heap: {1=20, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2]
	File table: {}
	Heap: {1=20, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 2
{
	Stack: [fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2]
	File table: {}
	Heap: {1=20, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2]
	File table: {}
	Heap: {1=20, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 2
{
	Stack: []
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2]
	File table: {}
	Heap: {1=20, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 3
{
	Stack: [{call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2]
	File table: {}
	Heap: {1=20, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2]
	File table: {}
	Heap: {1=20, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 3
{
	Stack: [{call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2]
	File table: {}
	Heap: {1=20, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2]
	File table: {}
	Heap: {1=20, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 3
{
	Stack: [call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2]
	File table: {}
	Heap: {1=20, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2]
	File table: {}
	Heap: {1=20, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 3
{
	Stack: [call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2]
	File table: {}
	Heap: {1=20, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2]
	File table: {}
	Heap: {1=20, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 3
{
	Stack: [{wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}, return, fork(call [forkBody[v3, cnt]])]
	Symbol Table: {v=RefValue(2, int), latch=1}
	Output: [20, 2]
	File table: {}
	Heap: {1=20, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2]
	File table: {}
	Heap: {1=20, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 3
{
	Stack: [{wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}, return, fork(call [forkBody[v3, cnt]])]
	Symbol Table: {v=RefValue(2, int), latch=1}
	Output: [20, 2]
	File table: {}
	Heap: {1=20, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2]
	File table: {}
	Heap: {1=20, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 3
{
	Stack: [wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}, return, fork(call [forkBody[v3, cnt]])]
	Symbol Table: {v=RefValue(2, int), latch=1}
	Output: [20, 2]
	File table: {}
	Heap: {1=20, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2]
	File table: {}
	Heap: {1=20, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 3
{
	Stack: [wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}, return, fork(call [forkBody[v3, cnt]])]
	Symbol Table: {v=RefValue(2, int), latch=1}
	Output: [20, 2]
	File table: {}
	Heap: {1=20, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2]
	File table: {}
	Heap: {1=20, 2=30, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 3
{
	Stack: [{print(rH(v)), countDown(latch)}, return, fork(call [forkBody[v3, cnt]])]
	Symbol Table: {v=RefValue(2, int), latch=1}
	Output: [20, 2]
	File table: {}
	Heap: {1=20, 2=30, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2]
	File table: {}
	Heap: {1=20, 2=30, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 3
{
	Stack: [{print(rH(v)), countDown(latch)}, return, fork(call [forkBody[v3, cnt]])]
	Symbol Table: {v=RefValue(2, int), latch=1}
	Output: [20, 2]
	File table: {}
	Heap: {1=20, 2=30, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2]
	File table: {}
	Heap: {1=20, 2=30, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 3
{
	Stack: [print(rH(v)), countDown(latch), return, fork(call [forkBody[v3, cnt]])]
	Symbol Table: {v=RefValue(2, int), latch=1}
	Output: [20, 2]
	File table: {}
	Heap: {1=20, 2=30, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2]
	File table: {}
	Heap: {1=20, 2=30, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 3
{
	Stack: [print(rH(v)), countDown(latch), return, fork(call [forkBody[v3, cnt]])]
	Symbol Table: {v=RefValue(2, int), latch=1}
	Output: [20, 2]
	File table: {}
	Heap: {1=20, 2=30, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30]
	File table: {}
	Heap: {1=20, 2=30, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 3
{
	Stack: [countDown(latch), return, fork(call [forkBody[v3, cnt]])]
	Symbol Table: {v=RefValue(2, int), latch=1}
	Output: [20, 2, 30]
	File table: {}
	Heap: {1=20, 2=30, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30]
	File table: {}
	Heap: {1=20, 2=30, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 3
{
	Stack: [countDown(latch), return, fork(call [forkBody[v3, cnt]])]
	Symbol Table: {v=RefValue(2, int), latch=1}
	Output: [20, 2, 30]
	File table: {}
	Heap: {1=20, 2=30, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30, 3]
	File table: {}
	Heap: {1=20, 2=30, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=1}
	Count Semaphore table: {}
};
Program 3
{
	Stack: [return, fork(call [forkBody[v3, cnt]])]
	Symbol Table: {v=RefValue(2, int), latch=1}
	Output: [20, 2, 30, 3]
	File table: {}
	Heap: {1=20, 2=30, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=1}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30, 3]
	File table: {}
	Heap: {1=20, 2=30, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=1}
	Count Semaphore table: {}
};
Program 3
{
	Stack: [return, fork(call [forkBody[v3, cnt]])]
	Symbol Table: {v=RefValue(2, int), latch=1}
	Output: [20, 2, 30, 3]
	File table: {}
	Heap: {1=20, 2=30, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=1}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30, 3]
	File table: {}
	Heap: {1=20, 2=30, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=1}
	Count Semaphore table: {}
};
Program 3
{
	Stack: [fork(call [forkBody[v3, cnt]])]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30, 3]
	File table: {}
	Heap: {1=20, 2=30, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=1}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30, 3]
	File table: {}
	Heap: {1=20, 2=30, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=1}
	Count Semaphore table: {}
};
Program 3
{
	Stack: [fork(call [forkBody[v3, cnt]])]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30, 3]
	File table: {}
	Heap: {1=20, 2=30, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=1}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30, 3]
	File table: {}
	Heap: {1=20, 2=30, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=1}
	Count Semaphore table: {}
};
Program 3
{
	Stack: []
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30, 3]
	File table: {}
	Heap: {1=20, 2=30, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=1}
	Count Semaphore table: {}
};
Program 4
{
	Stack: [call [forkBody[v3, cnt]]]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30, 3]
	File table: {}
	Heap: {1=20, 2=30, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=1}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30, 3]
	File table: {}
	Heap: {1=20, 2=30, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=1}
	Count Semaphore table: {}
};
Program 4
{
	Stack: [call [forkBody[v3, cnt]]]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30, 3]
	File table: {}
	Heap: {1=20, 2=30, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=1}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30, 3]
	File table: {}
	Heap: {1=20, 2=30, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=1}
	Count Semaphore table: {}
};
Program 4
{
	Stack: [{wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}, return]
	Symbol Table: {v=RefValue(3, int), latch=1}
	Output: [20, 2, 30, 3]
	File table: {}
	Heap: {1=20, 2=30, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=1}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30, 3]
	File table: {}
	Heap: {1=20, 2=30, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=1}
	Count Semaphore table: {}
};
Program 4
{
	Stack: [{wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}, return]
	Symbol Table: {v=RefValue(3, int), latch=1}
	Output: [20, 2, 30, 3]
	File table: {}
	Heap: {1=20, 2=30, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=1}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30, 3]
	File table: {}
	Heap: {1=20, 2=30, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=1}
	Count Semaphore table: {}
};
Program 4
{
	Stack: [wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}, return]
	Symbol Table: {v=RefValue(3, int), latch=1}
	Output: [20, 2, 30, 3]
	File table: {}
	Heap: {1=20, 2=30, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=1}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30, 3]
	File table: {}
	Heap: {1=20, 2=30, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=1}
	Count Semaphore table: {}
};
Program 4
{
	Stack: [wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}, return]
	Symbol Table: {v=RefValue(3, int), latch=1}
	Output: [20, 2, 30, 3]
	File table: {}
	Heap: {1=20, 2=30, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=1}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30, 3]
	File table: {}
	Heap: {1=20, 2=30, 3=40}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=1}
	Count Semaphore table: {}
};
Program 4
{
	Stack: [{print(rH(v)), countDown(latch)}, return]
	Symbol Table: {v=RefValue(3, int), latch=1}
	Output: [20, 2, 30, 3]
	File table: {}
	Heap: {1=20, 2=30, 3=40}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=1}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30, 3]
	File table: {}
	Heap: {1=20, 2=30, 3=40}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=1}
	Count Semaphore table: {}
};
Program 4
{
	Stack: [{print(rH(v)), countDown(latch)}, return]
	Symbol Table: {v=RefValue(3, int), latch=1}
	Output: [20, 2, 30, 3]
	File table: {}
	Heap: {1=20, 2=30, 3=40}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=1}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30, 3]
	File table: {}
	Heap: {1=20, 2=30, 3=40}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=1}
	Count Semaphore table: {}
};
Program 4
{
	Stack: [print(rH(v)), countDown(latch), return]
	Symbol Table: {v=RefValue(3, int), latch=1}
	Output: [20, 2, 30, 3]
	File table: {}
	Heap: {1=20, 2=30, 3=40}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=1}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30, 3]
	File table: {}
	Heap: {1=20, 2=30, 3=40}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=1}
	Count Semaphore table: {}
};
Program 4
{
	Stack: [print(rH(v)), countDown(latch), return]
	Symbol Table: {v=RefValue(3, int), latch=1}
	Output: [20, 2, 30, 3]
	File table: {}
	Heap: {1=20, 2=30, 3=40}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=1}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30, 3, 40]
	File table: {}
	Heap: {1=20, 2=30, 3=40}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=1}
	Count Semaphore table: {}
};
Program 4
{
	Stack: [countDown(latch), return]
	Symbol Table: {v=RefValue(3, int), latch=1}
	Output: [20, 2, 30, 3, 40]
	File table: {}
	Heap: {1=20, 2=30, 3=40}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=1}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30, 3, 40]
	File table: {}
	Heap: {1=20, 2=30, 3=40}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=1}
	Count Semaphore table: {}
};
Program 4
{
	Stack: [countDown(latch), return]
	Symbol Table: {v=RefValue(3, int), latch=1}
	Output: [20, 2, 30, 3, 40]
	File table: {}
	Heap: {1=20, 2=30, 3=40}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=1}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30, 3, 40, 4]
	File table: {}
	Heap: {1=20, 2=30, 3=40}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=0}
	Count Semaphore table: {}
};
Program 4
{
	Stack: [return]
	Symbol Table: {v=RefValue(3, int), latch=1}
	Output: [20, 2, 30, 3, 40, 4]
	File table: {}
	Heap: {1=20, 2=30, 3=40}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=0}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30, 3, 40, 4]
	File table: {}
	Heap: {1=20, 2=30, 3=40}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=0}
	Count Semaphore table: {}
};
Program 4
{
	Stack: [return]
	Symbol Table: {v=RefValue(3, int), latch=1}
	Output: [20, 2, 30, 3, 40, 4]
	File table: {}
	Heap: {1=20, 2=30, 3=40}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=0}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [{print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30, 3, 40, 4]
	File table: {}
	Heap: {1=20, 2=30, 3=40}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=0}
	Count Semaphore table: {}
};
Program 4
{
	Stack: []
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30, 3, 40, 4]
	File table: {}
	Heap: {1=20, 2=30, 3=40}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=0}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [{print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30, 3, 40, 4]
	File table: {}
	Heap: {1=20, 2=30, 3=40}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=0}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [print(100), {countDown(cnt), print(100)}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30, 3, 40, 4]
	File table: {}
	Heap: {1=20, 2=30, 3=40}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=0}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [print(100), {countDown(cnt), print(100)}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30, 3, 40, 4]
	File table: {}
	Heap: {1=20, 2=30, 3=40}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=0}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [{countDown(cnt), print(100)}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30, 3, 40, 4, 100]
	File table: {}
	Heap: {1=20, 2=30, 3=40}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=0}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [{countDown(cnt), print(100)}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30, 3, 40, 4, 100]
	File table: {}
	Heap: {1=20, 2=30, 3=40}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=0}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [countDown(cnt), print(100)]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30, 3, 40, 4, 100]
	File table: {}
	Heap: {1=20, 2=30, 3=40}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=0}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [countDown(cnt), print(100)]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30, 3, 40, 4, 100]
	File table: {}
	Heap: {1=20, 2=30, 3=40}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=0}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [print(100)]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30, 3, 40, 4, 100, 1]
	File table: {}
	Heap: {1=20, 2=30, 3=40}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=0}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [print(100)]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30, 3, 40, 4, 100, 1]
	File table: {}
	Heap: {1=20, 2=30, 3=40}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=0}
	Count Semaphore table: {}
};
Program 1
{
	Stack: []
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30, 3, 40, 4, 100, 1, 100]
	File table: {}
	Heap: {1=20, 2=30, 3=40}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=0}
	Count Semaphore table: {}
};
