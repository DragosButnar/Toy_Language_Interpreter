Program 2
{
	Stack: [{int a, {int b, {a = 2 + 3 * 5, {b = a + 1, print(b)}}}}]
	Symbol Table: {}
	Output: []
	File table: {}
	Heap: {}
};
Program 2
{
	Stack: [int a, {int b, {a = 2 + 3 * 5, {b = a + 1, print(b)}}}]
	Symbol Table: {}
	Output: []
	File table: {}
	Heap: {}
};
Program 2
{
	Stack: [int a, {int b, {a = 2 + 3 * 5, {b = a + 1, print(b)}}}]
	Symbol Table: {}
	Output: []
	File table: {}
	Heap: {}
};
Program 2
{
	Stack: [{int b, {a = 2 + 3 * 5, {b = a + 1, print(b)}}}]
	Symbol Table: {a=0}
	Output: []
	File table: {}
	Heap: {}
};
Program 2
{
	Stack: [{int b, {a = 2 + 3 * 5, {b = a + 1, print(b)}}}]
	Symbol Table: {a=0}
	Output: []
	File table: {}
	Heap: {}
};
Program 2
{
	Stack: [int b, {a = 2 + 3 * 5, {b = a + 1, print(b)}}]
	Symbol Table: {a=0}
	Output: []
	File table: {}
	Heap: {}
};
Program 2
{
	Stack: [int b, {a = 2 + 3 * 5, {b = a + 1, print(b)}}]
	Symbol Table: {a=0}
	Output: []
	File table: {}
	Heap: {}
};
Program 2
{
	Stack: [{a = 2 + 3 * 5, {b = a + 1, print(b)}}]
	Symbol Table: {a=0, b=0}
	Output: []
	File table: {}
	Heap: {}
};
Program 2
{
	Stack: [{a = 2 + 3 * 5, {b = a + 1, print(b)}}]
	Symbol Table: {a=0, b=0}
	Output: []
	File table: {}
	Heap: {}
};
Program 2
{
	Stack: [a = 2 + 3 * 5, {b = a + 1, print(b)}]
	Symbol Table: {a=0, b=0}
	Output: []
	File table: {}
	Heap: {}
};
Program 2
{
	Stack: [a = 2 + 3 * 5, {b = a + 1, print(b)}]
	Symbol Table: {a=0, b=0}
	Output: []
	File table: {}
	Heap: {}
};
Program 2
{
	Stack: [{b = a + 1, print(b)}]
	Symbol Table: {a=17, b=0}
	Output: []
	File table: {}
	Heap: {}
};
Program 2
{
	Stack: [{b = a + 1, print(b)}]
	Symbol Table: {a=17, b=0}
	Output: []
	File table: {}
	Heap: {}
};
Program 2
{
	Stack: [b = a + 1, print(b)]
	Symbol Table: {a=17, b=0}
	Output: []
	File table: {}
	Heap: {}
};
Program 2
{
	Stack: [b = a + 1, print(b)]
	Symbol Table: {a=17, b=0}
	Output: []
	File table: {}
	Heap: {}
};
Program 2
{
	Stack: [print(b)]
	Symbol Table: {a=17, b=18}
	Output: []
	File table: {}
	Heap: {}
};
Program 2
{
	Stack: [print(b)]
	Symbol Table: {a=17, b=18}
	Output: []
	File table: {}
	Heap: {}
};
Program 2
{
	Stack: []
	Symbol Table: {a=17, b=18}
	Output: [18]
	File table: {}
	Heap: {}
};
Program 1
{
	Stack: [{int a, {int b, {a = 2 + 3 * 5, {b = a + 1, print(b)}}}}]
	Symbol Table: {}
	Output: []
	File table: {}
	Heap: {}
};
Program 1
{
	Stack: [int a, {int b, {a = 2 + 3 * 5, {b = a + 1, print(b)}}}]
	Symbol Table: {}
	Output: []
	File table: {}
	Heap: {}
};
Program 1
{
	Stack: [int a, {int b, {a = 2 + 3 * 5, {b = a + 1, print(b)}}}]
	Symbol Table: {}
	Output: []
	File table: {}
	Heap: {}
};
Program 1
{
	Stack: [{int b, {a = 2 + 3 * 5, {b = a + 1, print(b)}}}]
	Symbol Table: {a=0}
	Output: []
	File table: {}
	Heap: {}
};
Program 1
{
	Stack: [{int b, {a = 2 + 3 * 5, {b = a + 1, print(b)}}}]
	Symbol Table: {a=0}
	Output: []
	File table: {}
	Heap: {}
};
Program 1
{
	Stack: [int b, {a = 2 + 3 * 5, {b = a + 1, print(b)}}]
	Symbol Table: {a=0}
	Output: []
	File table: {}
	Heap: {}
};
Program 1
{
	Stack: [int b, {a = 2 + 3 * 5, {b = a + 1, print(b)}}]
	Symbol Table: {a=0}
	Output: []
	File table: {}
	Heap: {}
};
Program 1
{
	Stack: [{a = 2 + 3 * 5, {b = a + 1, print(b)}}]
	Symbol Table: {a=0, b=0}
	Output: []
	File table: {}
	Heap: {}
};
Program 1
{
	Stack: [{a = 2 + 3 * 5, {b = a + 1, print(b)}}]
	Symbol Table: {a=0, b=0}
	Output: []
	File table: {}
	Heap: {}
};
Program 1
{
	Stack: [a = 2 + 3 * 5, {b = a + 1, print(b)}]
	Symbol Table: {a=0, b=0}
	Output: []
	File table: {}
	Heap: {}
};
Program 1
{
	Stack: [a = 2 + 3 * 5, {b = a + 1, print(b)}]
	Symbol Table: {a=0, b=0}
	Output: []
	File table: {}
	Heap: {}
};
Program 1
{
	Stack: [{b = a + 1, print(b)}]
	Symbol Table: {a=17, b=0}
	Output: []
	File table: {}
	Heap: {}
};
Program 1
{
	Stack: [{b = a + 1, print(b)}]
	Symbol Table: {a=17, b=0}
	Output: []
	File table: {}
	Heap: {}
};
Program 1
{
	Stack: [b = a + 1, print(b)]
	Symbol Table: {a=17, b=0}
	Output: []
	File table: {}
	Heap: {}
};
Program 1
{
	Stack: [b = a + 1, print(b)]
	Symbol Table: {a=17, b=0}
	Output: []
	File table: {}
	Heap: {}
};
Program 1
{
	Stack: [print(b)]
	Symbol Table: {a=17, b=18}
	Output: []
	File table: {}
	Heap: {}
};
Program 1
{
	Stack: [print(b)]
	Symbol Table: {a=17, b=18}
	Output: []
	File table: {}
	Heap: {}
};
Program 1
{
	Stack: []
	Symbol Table: {a=17, b=18}
	Output: [18]
	File table: {}
	Heap: {}
};
Program 1
{
	Stack: [{int a, {int b, {a = 2 + 3 * 5, {b = a + 1, print(b)}}}}]
	Symbol Table: {}
	Output: []
	File table: {}
	Heap: {}
};
Program 1
{
	Stack: [int a, {int b, {a = 2 + 3 * 5, {b = a + 1, print(b)}}}]
	Symbol Table: {}
	Output: []
	File table: {}
	Heap: {}
};
Program 1
{
	Stack: [int a, {int b, {a = 2 + 3 * 5, {b = a + 1, print(b)}}}]
	Symbol Table: {}
	Output: []
	File table: {}
	Heap: {}
};
Program 1
{
	Stack: [{int b, {a = 2 + 3 * 5, {b = a + 1, print(b)}}}]
	Symbol Table: {a=0}
	Output: []
	File table: {}
	Heap: {}
};
Program 1
{
	Stack: [{int b, {a = 2 + 3 * 5, {b = a + 1, print(b)}}}]
	Symbol Table: {a=0}
	Output: []
	File table: {}
	Heap: {}
};
Program 1
{
	Stack: [int b, {a = 2 + 3 * 5, {b = a + 1, print(b)}}]
	Symbol Table: {a=0}
	Output: []
	File table: {}
	Heap: {}
};
Program 1
{
	Stack: [int b, {a = 2 + 3 * 5, {b = a + 1, print(b)}}]
	Symbol Table: {a=0}
	Output: []
	File table: {}
	Heap: {}
};
Program 1
{
	Stack: [{a = 2 + 3 * 5, {b = a + 1, print(b)}}]
	Symbol Table: {a=0, b=0}
	Output: []
	File table: {}
	Heap: {}
};
Program 1
{
	Stack: [{a = 2 + 3 * 5, {b = a + 1, print(b)}}]
	Symbol Table: {a=0, b=0}
	Output: []
	File table: {}
	Heap: {}
};
Program 1
{
	Stack: [a = 2 + 3 * 5, {b = a + 1, print(b)}]
	Symbol Table: {a=0, b=0}
	Output: []
	File table: {}
	Heap: {}
};
Program 1
{
	Stack: [a = 2 + 3 * 5, {b = a + 1, print(b)}]
	Symbol Table: {a=0, b=0}
	Output: []
	File table: {}
	Heap: {}
};
Program 1
{
	Stack: [{b = a + 1, print(b)}]
	Symbol Table: {a=17, b=0}
	Output: []
	File table: {}
	Heap: {}
};
Program 1
{
	Stack: [{b = a + 1, print(b)}]
	Symbol Table: {a=17, b=0}
	Output: []
	File table: {}
	Heap: {}
};
Program 1
{
	Stack: [b = a + 1, print(b)]
	Symbol Table: {a=17, b=0}
	Output: []
	File table: {}
	Heap: {}
};
Program 1
{
	Stack: [b = a + 1, print(b)]
	Symbol Table: {a=17, b=0}
	Output: []
	File table: {}
	Heap: {}
};
Program 1
{
	Stack: [print(b)]
	Symbol Table: {a=17, b=18}
	Output: []
	File table: {}
	Heap: {}
};
Program 1
{
	Stack: [print(b)]
	Symbol Table: {a=17, b=18}
	Output: []
	File table: {}
	Heap: {}
};
Program 1
{
	Stack: [print(b), ]
	Symbol Table: {a=17, b=18}
	Output: []
	File table: {}
	Heap: {}
};
Program 1
{
	Stack: [print(b), ]
	Symbol Table: {a=17, b=18}
	Output: []
	File table: {}
	Heap: {}
};
Program 1
{
	Stack: []
	Symbol Table: {a=17, b=18}
	Output: [18]
	File table: {}
	Heap: {}
};
Program 1
{
	Stack: []
	Symbol Table: {a=17, b=18}
	Output: [18]
	File table: {}
	Heap: {}
};
Program 1
{
	Stack: []
	Symbol Table: {a=17, b=18}
	Output: [18]
	File table: {}
	Heap: {}
};
Program 2
{
	Stack: [{int a, {int b, {a = 2 + 3 * 5, {b = a + 1, print(b)}}}}]
	Symbol Table: {}
	Output: []
	File table: {}
	Heap: {}
};
Program 2
{
	Stack: [int a, {int b, {a = 2 + 3 * 5, {b = a + 1, print(b)}}}]
	Symbol Table: {}
	Output: []
	File table: {}
	Heap: {}
};
Program 2
{
	Stack: [int a, {int b, {a = 2 + 3 * 5, {b = a + 1, print(b)}}}]
	Symbol Table: {}
	Output: []
	File table: {}
	Heap: {}
};
Program 2
{
	Stack: [{int b, {a = 2 + 3 * 5, {b = a + 1, print(b)}}}]
	Symbol Table: {a=0}
	Output: []
	File table: {}
	Heap: {}
};
Program 2
{
	Stack: [{int b, {a = 2 + 3 * 5, {b = a + 1, print(b)}}}]
	Symbol Table: {a=0}
	Output: []
	File table: {}
	Heap: {}
};
Program 2
{
	Stack: [int b, {a = 2 + 3 * 5, {b = a + 1, print(b)}}]
	Symbol Table: {a=0}
	Output: []
	File table: {}
	Heap: {}
};
Program 2
{
	Stack: [int b, {a = 2 + 3 * 5, {b = a + 1, print(b)}}]
	Symbol Table: {a=0}
	Output: []
	File table: {}
	Heap: {}
};
Program 2
{
	Stack: [{a = 2 + 3 * 5, {b = a + 1, print(b)}}]
	Symbol Table: {a=0, b=0}
	Output: []
	File table: {}
	Heap: {}
};
Program 2
{
	Stack: [{a = 2 + 3 * 5, {b = a + 1, print(b)}}]
	Symbol Table: {a=0, b=0}
	Output: []
	File table: {}
	Heap: {}
};
Program 2
{
	Stack: [a = 2 + 3 * 5, {b = a + 1, print(b)}]
	Symbol Table: {a=0, b=0}
	Output: []
	File table: {}
	Heap: {}
};
Program 2
{
	Stack: [a = 2 + 3 * 5, {b = a + 1, print(b)}]
	Symbol Table: {a=0, b=0}
	Output: []
	File table: {}
	Heap: {}
};
Program 2
{
	Stack: [{b = a + 1, print(b)}]
	Symbol Table: {a=17, b=0}
	Output: []
	File table: {}
	Heap: {}
};
Program 2
{
	Stack: [{b = a + 1, print(b)}]
	Symbol Table: {a=17, b=0}
	Output: []
	File table: {}
	Heap: {}
};
Program 2
{
	Stack: [b = a + 1, print(b)]
	Symbol Table: {a=17, b=0}
	Output: []
	File table: {}
	Heap: {}
};
Program 2
{
	Stack: [b = a + 1, print(b)]
	Symbol Table: {a=17, b=0}
	Output: []
	File table: {}
	Heap: {}
};
Program 2
{
	Stack: [print(b)]
	Symbol Table: {a=17, b=18}
	Output: []
	File table: {}
	Heap: {}
};
Program 2
{
	Stack: [print(b)]
	Symbol Table: {a=17, b=18}
	Output: []
	File table: {}
	Heap: {}
};
Program 2
{
	Stack: [print(b), ]
	Symbol Table: {a=17, b=18}
	Output: []
	File table: {}
	Heap: {}
};
Program 2
{
	Stack: [print(b), ]
	Symbol Table: {a=17, b=18}
	Output: []
	File table: {}
	Heap: {}
};
Program 2
{
	Stack: []
	Symbol Table: {a=17, b=18}
	Output: [18]
	File table: {}
	Heap: {}
};
Program 2
{
	Stack: []
	Symbol Table: {a=17, b=18}
	Output: [18]
	File table: {}
	Heap: {}
};
Program 2
{
	Stack: []
	Symbol Table: {a=17, b=18}
	Output: [18]
	File table: {}
	Heap: {}
};
Program 2
{
	Stack: [{int a, {int b, {a = 2 + 3 * 5, {b = a + 1, print(b)}}}}]
	Symbol Table: {}
	Output: []
	File table: {}
	Heap: {}
};
Program 2
{
	Stack: [int a, {int b, {a = 2 + 3 * 5, {b = a + 1, print(b)}}}]
	Symbol Table: {}
	Output: []
	File table: {}
	Heap: {}
};
Program 2
{
	Stack: [int a, {int b, {a = 2 + 3 * 5, {b = a + 1, print(b)}}}]
	Symbol Table: {}
	Output: []
	File table: {}
	Heap: {}
};
Program 2
{
	Stack: [{int b, {a = 2 + 3 * 5, {b = a + 1, print(b)}}}]
	Symbol Table: {a=0}
	Output: []
	File table: {}
	Heap: {}
};
Program 2
{
	Stack: [{int b, {a = 2 + 3 * 5, {b = a + 1, print(b)}}}]
	Symbol Table: {a=0}
	Output: []
	File table: {}
	Heap: {}
};
Program 2
{
	Stack: [int b, {a = 2 + 3 * 5, {b = a + 1, print(b)}}]
	Symbol Table: {a=0}
	Output: []
	File table: {}
	Heap: {}
};
Program 2
{
	Stack: [int b, {a = 2 + 3 * 5, {b = a + 1, print(b)}}]
	Symbol Table: {a=0}
	Output: []
	File table: {}
	Heap: {}
};
Program 2
{
	Stack: [{a = 2 + 3 * 5, {b = a + 1, print(b)}}]
	Symbol Table: {a=0, b=0}
	Output: []
	File table: {}
	Heap: {}
};
Program 2
{
	Stack: [{a = 2 + 3 * 5, {b = a + 1, print(b)}}]
	Symbol Table: {a=0, b=0}
	Output: []
	File table: {}
	Heap: {}
};
Program 2
{
	Stack: [a = 2 + 3 * 5, {b = a + 1, print(b)}]
	Symbol Table: {a=0, b=0}
	Output: []
	File table: {}
	Heap: {}
};
Program 2
{
	Stack: [a = 2 + 3 * 5, {b = a + 1, print(b)}]
	Symbol Table: {a=0, b=0}
	Output: []
	File table: {}
	Heap: {}
};
Program 2
{
	Stack: [{b = a + 1, print(b)}]
	Symbol Table: {a=17, b=0}
	Output: []
	File table: {}
	Heap: {}
};
Program 2
{
	Stack: [{b = a + 1, print(b)}]
	Symbol Table: {a=17, b=0}
	Output: []
	File table: {}
	Heap: {}
};
Program 2
{
	Stack: [b = a + 1, print(b)]
	Symbol Table: {a=17, b=0}
	Output: []
	File table: {}
	Heap: {}
};
Program 2
{
	Stack: [b = a + 1, print(b)]
	Symbol Table: {a=17, b=0}
	Output: []
	File table: {}
	Heap: {}
};
Program 2
{
	Stack: [print(b)]
	Symbol Table: {a=17, b=18}
	Output: []
	File table: {}
	Heap: {}
};
Program 2
{
	Stack: [print(b)]
	Symbol Table: {a=17, b=18}
	Output: []
	File table: {}
	Heap: {}
};
Program 2
{
	Stack: []
	Symbol Table: {a=17, b=18}
	Output: [18]
	File table: {}
	Heap: {}
};
Program 1
{
	Stack: [{procedure[forkBody[v, latch]->{wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}], {Ref(int) v1, {Ref(int) v2, {Ref(int) v3, {int cnt, {new(v1,2), {new(v2,3), {new(v3,4), {newLatch(cnt, rH(v2)), {fork({call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}}}}}}}}}]
	Symbol Table: {}
	Output: []
	File table: {}
	Heap: {}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [procedure[forkBody[v, latch]->{wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}], {Ref(int) v1, {Ref(int) v2, {Ref(int) v3, {int cnt, {new(v1,2), {new(v2,3), {new(v3,4), {newLatch(cnt, rH(v2)), {fork({call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}}}}}}}}]
	Symbol Table: {}
	Output: []
	File table: {}
	Heap: {}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [procedure[forkBody[v, latch]->{wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}], {Ref(int) v1, {Ref(int) v2, {Ref(int) v3, {int cnt, {new(v1,2), {new(v2,3), {new(v3,4), {newLatch(cnt, rH(v2)), {fork({call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}}}}}}}}]
	Symbol Table: {}
	Output: []
	File table: {}
	Heap: {}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [{Ref(int) v1, {Ref(int) v2, {Ref(int) v3, {int cnt, {new(v1,2), {new(v2,3), {new(v3,4), {newLatch(cnt, rH(v2)), {fork({call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}}}}}}}}]
	Symbol Table: {}
	Output: []
	File table: {}
	Heap: {}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [{Ref(int) v1, {Ref(int) v2, {Ref(int) v3, {int cnt, {new(v1,2), {new(v2,3), {new(v3,4), {newLatch(cnt, rH(v2)), {fork({call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}}}}}}}}]
	Symbol Table: {}
	Output: []
	File table: {}
	Heap: {}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [Ref(int) v1, {Ref(int) v2, {Ref(int) v3, {int cnt, {new(v1,2), {new(v2,3), {new(v3,4), {newLatch(cnt, rH(v2)), {fork({call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}}}}}}}]
	Symbol Table: {}
	Output: []
	File table: {}
	Heap: {}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [Ref(int) v1, {Ref(int) v2, {Ref(int) v3, {int cnt, {new(v1,2), {new(v2,3), {new(v3,4), {newLatch(cnt, rH(v2)), {fork({call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}}}}}}}]
	Symbol Table: {}
	Output: []
	File table: {}
	Heap: {}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [{Ref(int) v2, {Ref(int) v3, {int cnt, {new(v1,2), {new(v2,3), {new(v3,4), {newLatch(cnt, rH(v2)), {fork({call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}}}}}}}]
	Symbol Table: {v1=RefValue(0, int)}
	Output: []
	File table: {}
	Heap: {}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [{Ref(int) v2, {Ref(int) v3, {int cnt, {new(v1,2), {new(v2,3), {new(v3,4), {newLatch(cnt, rH(v2)), {fork({call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}}}}}}}]
	Symbol Table: {v1=RefValue(0, int)}
	Output: []
	File table: {}
	Heap: {}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [Ref(int) v2, {Ref(int) v3, {int cnt, {new(v1,2), {new(v2,3), {new(v3,4), {newLatch(cnt, rH(v2)), {fork({call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}}}}}}]
	Symbol Table: {v1=RefValue(0, int)}
	Output: []
	File table: {}
	Heap: {}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [Ref(int) v2, {Ref(int) v3, {int cnt, {new(v1,2), {new(v2,3), {new(v3,4), {newLatch(cnt, rH(v2)), {fork({call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}}}}}}]
	Symbol Table: {v1=RefValue(0, int)}
	Output: []
	File table: {}
	Heap: {}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [{Ref(int) v3, {int cnt, {new(v1,2), {new(v2,3), {new(v3,4), {newLatch(cnt, rH(v2)), {fork({call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}}}}}}]
	Symbol Table: {v1=RefValue(0, int), v2=RefValue(0, int)}
	Output: []
	File table: {}
	Heap: {}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [{Ref(int) v3, {int cnt, {new(v1,2), {new(v2,3), {new(v3,4), {newLatch(cnt, rH(v2)), {fork({call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}}}}}}]
	Symbol Table: {v1=RefValue(0, int), v2=RefValue(0, int)}
	Output: []
	File table: {}
	Heap: {}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [Ref(int) v3, {int cnt, {new(v1,2), {new(v2,3), {new(v3,4), {newLatch(cnt, rH(v2)), {fork({call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}}}}}]
	Symbol Table: {v1=RefValue(0, int), v2=RefValue(0, int)}
	Output: []
	File table: {}
	Heap: {}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [Ref(int) v3, {int cnt, {new(v1,2), {new(v2,3), {new(v3,4), {newLatch(cnt, rH(v2)), {fork({call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}}}}}]
	Symbol Table: {v1=RefValue(0, int), v2=RefValue(0, int)}
	Output: []
	File table: {}
	Heap: {}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [{int cnt, {new(v1,2), {new(v2,3), {new(v3,4), {newLatch(cnt, rH(v2)), {fork({call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}}}}}]
	Symbol Table: {v1=RefValue(0, int), v2=RefValue(0, int), v3=RefValue(0, int)}
	Output: []
	File table: {}
	Heap: {}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [{int cnt, {new(v1,2), {new(v2,3), {new(v3,4), {newLatch(cnt, rH(v2)), {fork({call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}}}}}]
	Symbol Table: {v1=RefValue(0, int), v2=RefValue(0, int), v3=RefValue(0, int)}
	Output: []
	File table: {}
	Heap: {}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [int cnt, {new(v1,2), {new(v2,3), {new(v3,4), {newLatch(cnt, rH(v2)), {fork({call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}}}}]
	Symbol Table: {v1=RefValue(0, int), v2=RefValue(0, int), v3=RefValue(0, int)}
	Output: []
	File table: {}
	Heap: {}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [int cnt, {new(v1,2), {new(v2,3), {new(v3,4), {newLatch(cnt, rH(v2)), {fork({call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}}}}]
	Symbol Table: {v1=RefValue(0, int), v2=RefValue(0, int), v3=RefValue(0, int)}
	Output: []
	File table: {}
	Heap: {}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [{new(v1,2), {new(v2,3), {new(v3,4), {newLatch(cnt, rH(v2)), {fork({call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}}}}]
	Symbol Table: {cnt=0, v1=RefValue(0, int), v2=RefValue(0, int), v3=RefValue(0, int)}
	Output: []
	File table: {}
	Heap: {}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [{new(v1,2), {new(v2,3), {new(v3,4), {newLatch(cnt, rH(v2)), {fork({call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}}}}]
	Symbol Table: {cnt=0, v1=RefValue(0, int), v2=RefValue(0, int), v3=RefValue(0, int)}
	Output: []
	File table: {}
	Heap: {}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [new(v1,2), {new(v2,3), {new(v3,4), {newLatch(cnt, rH(v2)), {fork({call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}}}]
	Symbol Table: {cnt=0, v1=RefValue(0, int), v2=RefValue(0, int), v3=RefValue(0, int)}
	Output: []
	File table: {}
	Heap: {}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [new(v1,2), {new(v2,3), {new(v3,4), {newLatch(cnt, rH(v2)), {fork({call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}}}]
	Symbol Table: {cnt=0, v1=RefValue(0, int), v2=RefValue(0, int), v3=RefValue(0, int)}
	Output: []
	File table: {}
	Heap: {}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [{new(v2,3), {new(v3,4), {newLatch(cnt, rH(v2)), {fork({call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}}}]
	Symbol Table: {cnt=0, v1=RefValue(1, int), v2=RefValue(0, int), v3=RefValue(0, int)}
	Output: []
	File table: {}
	Heap: {1=2}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [{new(v2,3), {new(v3,4), {newLatch(cnt, rH(v2)), {fork({call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}}}]
	Symbol Table: {cnt=0, v1=RefValue(1, int), v2=RefValue(0, int), v3=RefValue(0, int)}
	Output: []
	File table: {}
	Heap: {1=2}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [new(v2,3), {new(v3,4), {newLatch(cnt, rH(v2)), {fork({call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}}]
	Symbol Table: {cnt=0, v1=RefValue(1, int), v2=RefValue(0, int), v3=RefValue(0, int)}
	Output: []
	File table: {}
	Heap: {1=2}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [new(v2,3), {new(v3,4), {newLatch(cnt, rH(v2)), {fork({call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}}]
	Symbol Table: {cnt=0, v1=RefValue(1, int), v2=RefValue(0, int), v3=RefValue(0, int)}
	Output: []
	File table: {}
	Heap: {1=2}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [{new(v3,4), {newLatch(cnt, rH(v2)), {fork({call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}}]
	Symbol Table: {cnt=0, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(0, int)}
	Output: []
	File table: {}
	Heap: {1=2, 2=3}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [{new(v3,4), {newLatch(cnt, rH(v2)), {fork({call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}}]
	Symbol Table: {cnt=0, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(0, int)}
	Output: []
	File table: {}
	Heap: {1=2, 2=3}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [new(v3,4), {newLatch(cnt, rH(v2)), {fork({call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}]
	Symbol Table: {cnt=0, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(0, int)}
	Output: []
	File table: {}
	Heap: {1=2, 2=3}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [new(v3,4), {newLatch(cnt, rH(v2)), {fork({call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}]
	Symbol Table: {cnt=0, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(0, int)}
	Output: []
	File table: {}
	Heap: {1=2, 2=3}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [{newLatch(cnt, rH(v2)), {fork({call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}]
	Symbol Table: {cnt=0, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: []
	File table: {}
	Heap: {1=2, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [{newLatch(cnt, rH(v2)), {fork({call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}]
	Symbol Table: {cnt=0, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: []
	File table: {}
	Heap: {1=2, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [newLatch(cnt, rH(v2)), {fork({call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}]
	Symbol Table: {cnt=0, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: []
	File table: {}
	Heap: {1=2, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [newLatch(cnt, rH(v2)), {fork({call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}]
	Symbol Table: {cnt=0, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: []
	File table: {}
	Heap: {1=2, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [{fork({call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: []
	File table: {}
	Heap: {1=2, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=3}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [{fork({call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: []
	File table: {}
	Heap: {1=2, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=3}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [fork({call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: []
	File table: {}
	Heap: {1=2, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=3}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [fork({call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: []
	File table: {}
	Heap: {1=2, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=3}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [{await(cnt), {print(100), {countDown(cnt), print(100)}}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: []
	File table: {}
	Heap: {1=2, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=3}
	Count Semaphore table: {}
};
Program 2
{
	Stack: [{call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: []
	File table: {}
	Heap: {1=2, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=3}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [{await(cnt), {print(100), {countDown(cnt), print(100)}}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: []
	File table: {}
	Heap: {1=2, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=3}
	Count Semaphore table: {}
};
Program 2
{
	Stack: [{call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: []
	File table: {}
	Heap: {1=2, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=3}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: []
	File table: {}
	Heap: {1=2, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=3}
	Count Semaphore table: {}
};
Program 2
{
	Stack: [call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: []
	File table: {}
	Heap: {1=2, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=3}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: []
	File table: {}
	Heap: {1=2, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=3}
	Count Semaphore table: {}
};
Program 2
{
	Stack: [call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: []
	File table: {}
	Heap: {1=2, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=3}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: []
	File table: {}
	Heap: {1=2, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=3}
	Count Semaphore table: {}
};
Program 2
{
	Stack: [{wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}, return, fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})]
	Symbol Table: {v=RefValue(1, int), latch=1}
	Output: []
	File table: {}
	Heap: {1=2, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=3}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: []
	File table: {}
	Heap: {1=2, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=3}
	Count Semaphore table: {}
};
Program 2
{
	Stack: [{wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}, return, fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})]
	Symbol Table: {v=RefValue(1, int), latch=1}
	Output: []
	File table: {}
	Heap: {1=2, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=3}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: []
	File table: {}
	Heap: {1=2, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=3}
	Count Semaphore table: {}
};
Program 2
{
	Stack: [wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}, return, fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})]
	Symbol Table: {v=RefValue(1, int), latch=1}
	Output: []
	File table: {}
	Heap: {1=2, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=3}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: []
	File table: {}
	Heap: {1=2, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=3}
	Count Semaphore table: {}
};
Program 2
{
	Stack: [wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}, return, fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})]
	Symbol Table: {v=RefValue(1, int), latch=1}
	Output: []
	File table: {}
	Heap: {1=2, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=3}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: []
	File table: {}
	Heap: {1=20, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=3}
	Count Semaphore table: {}
};
Program 2
{
	Stack: [{print(rH(v)), countDown(latch)}, return, fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})]
	Symbol Table: {v=RefValue(1, int), latch=1}
	Output: []
	File table: {}
	Heap: {1=20, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=3}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: []
	File table: {}
	Heap: {1=20, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=3}
	Count Semaphore table: {}
};
Program 2
{
	Stack: [{print(rH(v)), countDown(latch)}, return, fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})]
	Symbol Table: {v=RefValue(1, int), latch=1}
	Output: []
	File table: {}
	Heap: {1=20, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=3}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: []
	File table: {}
	Heap: {1=20, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=3}
	Count Semaphore table: {}
};
Program 2
{
	Stack: [print(rH(v)), countDown(latch), return, fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})]
	Symbol Table: {v=RefValue(1, int), latch=1}
	Output: []
	File table: {}
	Heap: {1=20, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=3}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: []
	File table: {}
	Heap: {1=20, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=3}
	Count Semaphore table: {}
};
Program 2
{
	Stack: [print(rH(v)), countDown(latch), return, fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})]
	Symbol Table: {v=RefValue(1, int), latch=1}
	Output: []
	File table: {}
	Heap: {1=20, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=3}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20]
	File table: {}
	Heap: {1=20, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=3}
	Count Semaphore table: {}
};
Program 2
{
	Stack: [countDown(latch), return, fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})]
	Symbol Table: {v=RefValue(1, int), latch=1}
	Output: [20]
	File table: {}
	Heap: {1=20, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=3}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20]
	File table: {}
	Heap: {1=20, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=3}
	Count Semaphore table: {}
};
Program 2
{
	Stack: [countDown(latch), return, fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})]
	Symbol Table: {v=RefValue(1, int), latch=1}
	Output: [20]
	File table: {}
	Heap: {1=20, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=3}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2]
	File table: {}
	Heap: {1=20, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 2
{
	Stack: [return, fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})]
	Symbol Table: {v=RefValue(1, int), latch=1}
	Output: [20, 2]
	File table: {}
	Heap: {1=20, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2]
	File table: {}
	Heap: {1=20, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 2
{
	Stack: [return, fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})]
	Symbol Table: {v=RefValue(1, int), latch=1}
	Output: [20, 2]
	File table: {}
	Heap: {1=20, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2]
	File table: {}
	Heap: {1=20, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 2
{
	Stack: [fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2]
	File table: {}
	Heap: {1=20, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2]
	File table: {}
	Heap: {1=20, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 2
{
	Stack: [fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2]
	File table: {}
	Heap: {1=20, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2]
	File table: {}
	Heap: {1=20, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 2
{
	Stack: []
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2]
	File table: {}
	Heap: {1=20, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 3
{
	Stack: [{call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2]
	File table: {}
	Heap: {1=20, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2]
	File table: {}
	Heap: {1=20, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 3
{
	Stack: [{call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2]
	File table: {}
	Heap: {1=20, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2]
	File table: {}
	Heap: {1=20, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 3
{
	Stack: [call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2]
	File table: {}
	Heap: {1=20, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2]
	File table: {}
	Heap: {1=20, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 3
{
	Stack: [call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2]
	File table: {}
	Heap: {1=20, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2]
	File table: {}
	Heap: {1=20, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 3
{
	Stack: [{wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}, return, fork(call [forkBody[v3, cnt]])]
	Symbol Table: {v=RefValue(2, int), latch=1}
	Output: [20, 2]
	File table: {}
	Heap: {1=20, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2]
	File table: {}
	Heap: {1=20, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 3
{
	Stack: [{wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}, return, fork(call [forkBody[v3, cnt]])]
	Symbol Table: {v=RefValue(2, int), latch=1}
	Output: [20, 2]
	File table: {}
	Heap: {1=20, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2]
	File table: {}
	Heap: {1=20, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 3
{
	Stack: [wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}, return, fork(call [forkBody[v3, cnt]])]
	Symbol Table: {v=RefValue(2, int), latch=1}
	Output: [20, 2]
	File table: {}
	Heap: {1=20, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2]
	File table: {}
	Heap: {1=20, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 3
{
	Stack: [wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}, return, fork(call [forkBody[v3, cnt]])]
	Symbol Table: {v=RefValue(2, int), latch=1}
	Output: [20, 2]
	File table: {}
	Heap: {1=20, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2]
	File table: {}
	Heap: {1=20, 2=30, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 3
{
	Stack: [{print(rH(v)), countDown(latch)}, return, fork(call [forkBody[v3, cnt]])]
	Symbol Table: {v=RefValue(2, int), latch=1}
	Output: [20, 2]
	File table: {}
	Heap: {1=20, 2=30, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2]
	File table: {}
	Heap: {1=20, 2=30, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 3
{
	Stack: [{print(rH(v)), countDown(latch)}, return, fork(call [forkBody[v3, cnt]])]
	Symbol Table: {v=RefValue(2, int), latch=1}
	Output: [20, 2]
	File table: {}
	Heap: {1=20, 2=30, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2]
	File table: {}
	Heap: {1=20, 2=30, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 3
{
	Stack: [print(rH(v)), countDown(latch), return, fork(call [forkBody[v3, cnt]])]
	Symbol Table: {v=RefValue(2, int), latch=1}
	Output: [20, 2]
	File table: {}
	Heap: {1=20, 2=30, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2]
	File table: {}
	Heap: {1=20, 2=30, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 3
{
	Stack: [print(rH(v)), countDown(latch), return, fork(call [forkBody[v3, cnt]])]
	Symbol Table: {v=RefValue(2, int), latch=1}
	Output: [20, 2]
	File table: {}
	Heap: {1=20, 2=30, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30]
	File table: {}
	Heap: {1=20, 2=30, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 3
{
	Stack: [countDown(latch), return, fork(call [forkBody[v3, cnt]])]
	Symbol Table: {v=RefValue(2, int), latch=1}
	Output: [20, 2, 30]
	File table: {}
	Heap: {1=20, 2=30, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30]
	File table: {}
	Heap: {1=20, 2=30, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 3
{
	Stack: [countDown(latch), return, fork(call [forkBody[v3, cnt]])]
	Symbol Table: {v=RefValue(2, int), latch=1}
	Output: [20, 2, 30]
	File table: {}
	Heap: {1=20, 2=30, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30, 3]
	File table: {}
	Heap: {1=20, 2=30, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=1}
	Count Semaphore table: {}
};
Program 3
{
	Stack: [return, fork(call [forkBody[v3, cnt]])]
	Symbol Table: {v=RefValue(2, int), latch=1}
	Output: [20, 2, 30, 3]
	File table: {}
	Heap: {1=20, 2=30, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=1}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30, 3]
	File table: {}
	Heap: {1=20, 2=30, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=1}
	Count Semaphore table: {}
};
Program 3
{
	Stack: [return, fork(call [forkBody[v3, cnt]])]
	Symbol Table: {v=RefValue(2, int), latch=1}
	Output: [20, 2, 30, 3]
	File table: {}
	Heap: {1=20, 2=30, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=1}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30, 3]
	File table: {}
	Heap: {1=20, 2=30, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=1}
	Count Semaphore table: {}
};
Program 3
{
	Stack: [fork(call [forkBody[v3, cnt]])]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30, 3]
	File table: {}
	Heap: {1=20, 2=30, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=1}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30, 3]
	File table: {}
	Heap: {1=20, 2=30, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=1}
	Count Semaphore table: {}
};
Program 3
{
	Stack: [fork(call [forkBody[v3, cnt]])]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30, 3]
	File table: {}
	Heap: {1=20, 2=30, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=1}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30, 3]
	File table: {}
	Heap: {1=20, 2=30, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=1}
	Count Semaphore table: {}
};
Program 3
{
	Stack: []
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30, 3]
	File table: {}
	Heap: {1=20, 2=30, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=1}
	Count Semaphore table: {}
};
Program 4
{
	Stack: [call [forkBody[v3, cnt]]]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30, 3]
	File table: {}
	Heap: {1=20, 2=30, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=1}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30, 3]
	File table: {}
	Heap: {1=20, 2=30, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=1}
	Count Semaphore table: {}
};
Program 4
{
	Stack: [call [forkBody[v3, cnt]]]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30, 3]
	File table: {}
	Heap: {1=20, 2=30, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=1}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30, 3]
	File table: {}
	Heap: {1=20, 2=30, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=1}
	Count Semaphore table: {}
};
Program 4
{
	Stack: [{wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}, return]
	Symbol Table: {v=RefValue(3, int), latch=1}
	Output: [20, 2, 30, 3]
	File table: {}
	Heap: {1=20, 2=30, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=1}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30, 3]
	File table: {}
	Heap: {1=20, 2=30, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=1}
	Count Semaphore table: {}
};
Program 4
{
	Stack: [{wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}, return]
	Symbol Table: {v=RefValue(3, int), latch=1}
	Output: [20, 2, 30, 3]
	File table: {}
	Heap: {1=20, 2=30, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=1}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30, 3]
	File table: {}
	Heap: {1=20, 2=30, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=1}
	Count Semaphore table: {}
};
Program 4
{
	Stack: [wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}, return]
	Symbol Table: {v=RefValue(3, int), latch=1}
	Output: [20, 2, 30, 3]
	File table: {}
	Heap: {1=20, 2=30, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=1}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30, 3]
	File table: {}
	Heap: {1=20, 2=30, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=1}
	Count Semaphore table: {}
};
Program 4
{
	Stack: [wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}, return]
	Symbol Table: {v=RefValue(3, int), latch=1}
	Output: [20, 2, 30, 3]
	File table: {}
	Heap: {1=20, 2=30, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=1}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30, 3]
	File table: {}
	Heap: {1=20, 2=30, 3=40}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=1}
	Count Semaphore table: {}
};
Program 4
{
	Stack: [{print(rH(v)), countDown(latch)}, return]
	Symbol Table: {v=RefValue(3, int), latch=1}
	Output: [20, 2, 30, 3]
	File table: {}
	Heap: {1=20, 2=30, 3=40}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=1}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30, 3]
	File table: {}
	Heap: {1=20, 2=30, 3=40}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=1}
	Count Semaphore table: {}
};
Program 4
{
	Stack: [{print(rH(v)), countDown(latch)}, return]
	Symbol Table: {v=RefValue(3, int), latch=1}
	Output: [20, 2, 30, 3]
	File table: {}
	Heap: {1=20, 2=30, 3=40}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=1}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30, 3]
	File table: {}
	Heap: {1=20, 2=30, 3=40}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=1}
	Count Semaphore table: {}
};
Program 4
{
	Stack: [print(rH(v)), countDown(latch), return]
	Symbol Table: {v=RefValue(3, int), latch=1}
	Output: [20, 2, 30, 3]
	File table: {}
	Heap: {1=20, 2=30, 3=40}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=1}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30, 3]
	File table: {}
	Heap: {1=20, 2=30, 3=40}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=1}
	Count Semaphore table: {}
};
Program 4
{
	Stack: [print(rH(v)), countDown(latch), return]
	Symbol Table: {v=RefValue(3, int), latch=1}
	Output: [20, 2, 30, 3]
	File table: {}
	Heap: {1=20, 2=30, 3=40}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=1}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30, 3, 40]
	File table: {}
	Heap: {1=20, 2=30, 3=40}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=1}
	Count Semaphore table: {}
};
Program 4
{
	Stack: [countDown(latch), return]
	Symbol Table: {v=RefValue(3, int), latch=1}
	Output: [20, 2, 30, 3, 40]
	File table: {}
	Heap: {1=20, 2=30, 3=40}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=1}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30, 3, 40]
	File table: {}
	Heap: {1=20, 2=30, 3=40}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=1}
	Count Semaphore table: {}
};
Program 4
{
	Stack: [countDown(latch), return]
	Symbol Table: {v=RefValue(3, int), latch=1}
	Output: [20, 2, 30, 3, 40]
	File table: {}
	Heap: {1=20, 2=30, 3=40}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=1}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30, 3, 40, 4]
	File table: {}
	Heap: {1=20, 2=30, 3=40}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=0}
	Count Semaphore table: {}
};
Program 4
{
	Stack: [return]
	Symbol Table: {v=RefValue(3, int), latch=1}
	Output: [20, 2, 30, 3, 40, 4]
	File table: {}
	Heap: {1=20, 2=30, 3=40}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=0}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30, 3, 40, 4]
	File table: {}
	Heap: {1=20, 2=30, 3=40}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=0}
	Count Semaphore table: {}
};
Program 4
{
	Stack: [return]
	Symbol Table: {v=RefValue(3, int), latch=1}
	Output: [20, 2, 30, 3, 40, 4]
	File table: {}
	Heap: {1=20, 2=30, 3=40}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=0}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [{print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30, 3, 40, 4]
	File table: {}
	Heap: {1=20, 2=30, 3=40}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=0}
	Count Semaphore table: {}
};
Program 4
{
	Stack: []
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30, 3, 40, 4]
	File table: {}
	Heap: {1=20, 2=30, 3=40}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=0}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [{print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30, 3, 40, 4]
	File table: {}
	Heap: {1=20, 2=30, 3=40}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=0}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [print(100), {countDown(cnt), print(100)}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30, 3, 40, 4]
	File table: {}
	Heap: {1=20, 2=30, 3=40}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=0}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [print(100), {countDown(cnt), print(100)}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30, 3, 40, 4]
	File table: {}
	Heap: {1=20, 2=30, 3=40}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=0}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [{countDown(cnt), print(100)}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30, 3, 40, 4, 100]
	File table: {}
	Heap: {1=20, 2=30, 3=40}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=0}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [{countDown(cnt), print(100)}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30, 3, 40, 4, 100]
	File table: {}
	Heap: {1=20, 2=30, 3=40}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=0}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [countDown(cnt), print(100)]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30, 3, 40, 4, 100]
	File table: {}
	Heap: {1=20, 2=30, 3=40}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=0}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [countDown(cnt), print(100)]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30, 3, 40, 4, 100]
	File table: {}
	Heap: {1=20, 2=30, 3=40}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=0}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [print(100)]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30, 3, 40, 4, 100, 1]
	File table: {}
	Heap: {1=20, 2=30, 3=40}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=0}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [print(100)]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30, 3, 40, 4, 100, 1]
	File table: {}
	Heap: {1=20, 2=30, 3=40}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=0}
	Count Semaphore table: {}
};
Program 1
{
	Stack: []
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30, 3, 40, 4, 100, 1, 100]
	File table: {}
	Heap: {1=20, 2=30, 3=40}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=0}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [{procedure[forkBody[v, latch]->{wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}], {Ref(int) v1, {Ref(int) v2, {Ref(int) v3, {int cnt, {new(v1,2), {new(v2,3), {new(v3,4), {newLatch(cnt, rH(v2)), {fork({call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}}}}}}}}}]
	Symbol Table: {}
	Output: []
	File table: {}
	Heap: {}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [procedure[forkBody[v, latch]->{wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}], {Ref(int) v1, {Ref(int) v2, {Ref(int) v3, {int cnt, {new(v1,2), {new(v2,3), {new(v3,4), {newLatch(cnt, rH(v2)), {fork({call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}}}}}}}}]
	Symbol Table: {}
	Output: []
	File table: {}
	Heap: {}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [procedure[forkBody[v, latch]->{wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}], {Ref(int) v1, {Ref(int) v2, {Ref(int) v3, {int cnt, {new(v1,2), {new(v2,3), {new(v3,4), {newLatch(cnt, rH(v2)), {fork({call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}}}}}}}}]
	Symbol Table: {}
	Output: []
	File table: {}
	Heap: {}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [{Ref(int) v1, {Ref(int) v2, {Ref(int) v3, {int cnt, {new(v1,2), {new(v2,3), {new(v3,4), {newLatch(cnt, rH(v2)), {fork({call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}}}}}}}}]
	Symbol Table: {}
	Output: []
	File table: {}
	Heap: {}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [{Ref(int) v1, {Ref(int) v2, {Ref(int) v3, {int cnt, {new(v1,2), {new(v2,3), {new(v3,4), {newLatch(cnt, rH(v2)), {fork({call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}}}}}}}}]
	Symbol Table: {}
	Output: []
	File table: {}
	Heap: {}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [Ref(int) v1, {Ref(int) v2, {Ref(int) v3, {int cnt, {new(v1,2), {new(v2,3), {new(v3,4), {newLatch(cnt, rH(v2)), {fork({call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}}}}}}}]
	Symbol Table: {}
	Output: []
	File table: {}
	Heap: {}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [Ref(int) v1, {Ref(int) v2, {Ref(int) v3, {int cnt, {new(v1,2), {new(v2,3), {new(v3,4), {newLatch(cnt, rH(v2)), {fork({call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}}}}}}}]
	Symbol Table: {}
	Output: []
	File table: {}
	Heap: {}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [{Ref(int) v2, {Ref(int) v3, {int cnt, {new(v1,2), {new(v2,3), {new(v3,4), {newLatch(cnt, rH(v2)), {fork({call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}}}}}}}]
	Symbol Table: {v1=RefValue(0, int)}
	Output: []
	File table: {}
	Heap: {}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [{Ref(int) v2, {Ref(int) v3, {int cnt, {new(v1,2), {new(v2,3), {new(v3,4), {newLatch(cnt, rH(v2)), {fork({call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}}}}}}}]
	Symbol Table: {v1=RefValue(0, int)}
	Output: []
	File table: {}
	Heap: {}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [Ref(int) v2, {Ref(int) v3, {int cnt, {new(v1,2), {new(v2,3), {new(v3,4), {newLatch(cnt, rH(v2)), {fork({call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}}}}}}]
	Symbol Table: {v1=RefValue(0, int)}
	Output: []
	File table: {}
	Heap: {}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [Ref(int) v2, {Ref(int) v3, {int cnt, {new(v1,2), {new(v2,3), {new(v3,4), {newLatch(cnt, rH(v2)), {fork({call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}}}}}}]
	Symbol Table: {v1=RefValue(0, int)}
	Output: []
	File table: {}
	Heap: {}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [{Ref(int) v3, {int cnt, {new(v1,2), {new(v2,3), {new(v3,4), {newLatch(cnt, rH(v2)), {fork({call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}}}}}}]
	Symbol Table: {v1=RefValue(0, int), v2=RefValue(0, int)}
	Output: []
	File table: {}
	Heap: {}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [{Ref(int) v3, {int cnt, {new(v1,2), {new(v2,3), {new(v3,4), {newLatch(cnt, rH(v2)), {fork({call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}}}}}}]
	Symbol Table: {v1=RefValue(0, int), v2=RefValue(0, int)}
	Output: []
	File table: {}
	Heap: {}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [Ref(int) v3, {int cnt, {new(v1,2), {new(v2,3), {new(v3,4), {newLatch(cnt, rH(v2)), {fork({call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}}}}}]
	Symbol Table: {v1=RefValue(0, int), v2=RefValue(0, int)}
	Output: []
	File table: {}
	Heap: {}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [Ref(int) v3, {int cnt, {new(v1,2), {new(v2,3), {new(v3,4), {newLatch(cnt, rH(v2)), {fork({call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}}}}}]
	Symbol Table: {v1=RefValue(0, int), v2=RefValue(0, int)}
	Output: []
	File table: {}
	Heap: {}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [{int cnt, {new(v1,2), {new(v2,3), {new(v3,4), {newLatch(cnt, rH(v2)), {fork({call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}}}}}]
	Symbol Table: {v1=RefValue(0, int), v2=RefValue(0, int), v3=RefValue(0, int)}
	Output: []
	File table: {}
	Heap: {}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [{int cnt, {new(v1,2), {new(v2,3), {new(v3,4), {newLatch(cnt, rH(v2)), {fork({call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}}}}}]
	Symbol Table: {v1=RefValue(0, int), v2=RefValue(0, int), v3=RefValue(0, int)}
	Output: []
	File table: {}
	Heap: {}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [int cnt, {new(v1,2), {new(v2,3), {new(v3,4), {newLatch(cnt, rH(v2)), {fork({call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}}}}]
	Symbol Table: {v1=RefValue(0, int), v2=RefValue(0, int), v3=RefValue(0, int)}
	Output: []
	File table: {}
	Heap: {}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [int cnt, {new(v1,2), {new(v2,3), {new(v3,4), {newLatch(cnt, rH(v2)), {fork({call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}}}}]
	Symbol Table: {v1=RefValue(0, int), v2=RefValue(0, int), v3=RefValue(0, int)}
	Output: []
	File table: {}
	Heap: {}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [{new(v1,2), {new(v2,3), {new(v3,4), {newLatch(cnt, rH(v2)), {fork({call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}}}}]
	Symbol Table: {cnt=0, v1=RefValue(0, int), v2=RefValue(0, int), v3=RefValue(0, int)}
	Output: []
	File table: {}
	Heap: {}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [{new(v1,2), {new(v2,3), {new(v3,4), {newLatch(cnt, rH(v2)), {fork({call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}}}}]
	Symbol Table: {cnt=0, v1=RefValue(0, int), v2=RefValue(0, int), v3=RefValue(0, int)}
	Output: []
	File table: {}
	Heap: {}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [new(v1,2), {new(v2,3), {new(v3,4), {newLatch(cnt, rH(v2)), {fork({call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}}}]
	Symbol Table: {cnt=0, v1=RefValue(0, int), v2=RefValue(0, int), v3=RefValue(0, int)}
	Output: []
	File table: {}
	Heap: {}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [new(v1,2), {new(v2,3), {new(v3,4), {newLatch(cnt, rH(v2)), {fork({call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}}}]
	Symbol Table: {cnt=0, v1=RefValue(0, int), v2=RefValue(0, int), v3=RefValue(0, int)}
	Output: []
	File table: {}
	Heap: {}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [{new(v2,3), {new(v3,4), {newLatch(cnt, rH(v2)), {fork({call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}}}]
	Symbol Table: {cnt=0, v1=RefValue(1, int), v2=RefValue(0, int), v3=RefValue(0, int)}
	Output: []
	File table: {}
	Heap: {1=2}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [{new(v2,3), {new(v3,4), {newLatch(cnt, rH(v2)), {fork({call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}}}]
	Symbol Table: {cnt=0, v1=RefValue(1, int), v2=RefValue(0, int), v3=RefValue(0, int)}
	Output: []
	File table: {}
	Heap: {1=2}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [new(v2,3), {new(v3,4), {newLatch(cnt, rH(v2)), {fork({call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}}]
	Symbol Table: {cnt=0, v1=RefValue(1, int), v2=RefValue(0, int), v3=RefValue(0, int)}
	Output: []
	File table: {}
	Heap: {1=2}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [new(v2,3), {new(v3,4), {newLatch(cnt, rH(v2)), {fork({call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}}]
	Symbol Table: {cnt=0, v1=RefValue(1, int), v2=RefValue(0, int), v3=RefValue(0, int)}
	Output: []
	File table: {}
	Heap: {1=2}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [{new(v3,4), {newLatch(cnt, rH(v2)), {fork({call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}}]
	Symbol Table: {cnt=0, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(0, int)}
	Output: []
	File table: {}
	Heap: {1=2, 2=3}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [{new(v3,4), {newLatch(cnt, rH(v2)), {fork({call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}}]
	Symbol Table: {cnt=0, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(0, int)}
	Output: []
	File table: {}
	Heap: {1=2, 2=3}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [new(v3,4), {newLatch(cnt, rH(v2)), {fork({call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}]
	Symbol Table: {cnt=0, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(0, int)}
	Output: []
	File table: {}
	Heap: {1=2, 2=3}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [new(v3,4), {newLatch(cnt, rH(v2)), {fork({call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}]
	Symbol Table: {cnt=0, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(0, int)}
	Output: []
	File table: {}
	Heap: {1=2, 2=3}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [{newLatch(cnt, rH(v2)), {fork({call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}]
	Symbol Table: {cnt=0, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: []
	File table: {}
	Heap: {1=2, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [{newLatch(cnt, rH(v2)), {fork({call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}]
	Symbol Table: {cnt=0, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: []
	File table: {}
	Heap: {1=2, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [newLatch(cnt, rH(v2)), {fork({call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}]
	Symbol Table: {cnt=0, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: []
	File table: {}
	Heap: {1=2, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [newLatch(cnt, rH(v2)), {fork({call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}]
	Symbol Table: {cnt=0, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: []
	File table: {}
	Heap: {1=2, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [{fork({call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: []
	File table: {}
	Heap: {1=2, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=3}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [{fork({call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: []
	File table: {}
	Heap: {1=2, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=3}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [fork({call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: []
	File table: {}
	Heap: {1=2, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=3}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [fork({call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: []
	File table: {}
	Heap: {1=2, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=3}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [{await(cnt), {print(100), {countDown(cnt), print(100)}}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: []
	File table: {}
	Heap: {1=2, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=3}
	Count Semaphore table: {}
};
Program 2
{
	Stack: [{call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: []
	File table: {}
	Heap: {1=2, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=3}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [{await(cnt), {print(100), {countDown(cnt), print(100)}}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: []
	File table: {}
	Heap: {1=2, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=3}
	Count Semaphore table: {}
};
Program 2
{
	Stack: [{call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: []
	File table: {}
	Heap: {1=2, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=3}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: []
	File table: {}
	Heap: {1=2, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=3}
	Count Semaphore table: {}
};
Program 2
{
	Stack: [call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: []
	File table: {}
	Heap: {1=2, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=3}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: []
	File table: {}
	Heap: {1=2, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=3}
	Count Semaphore table: {}
};
Program 2
{
	Stack: [call [forkBody[v1, cnt]], fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: []
	File table: {}
	Heap: {1=2, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=3}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: []
	File table: {}
	Heap: {1=2, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=3}
	Count Semaphore table: {}
};
Program 2
{
	Stack: [{wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}, return, fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})]
	Symbol Table: {v=RefValue(1, int), latch=1}
	Output: []
	File table: {}
	Heap: {1=2, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=3}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: []
	File table: {}
	Heap: {1=2, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=3}
	Count Semaphore table: {}
};
Program 2
{
	Stack: [{wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}, return, fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})]
	Symbol Table: {v=RefValue(1, int), latch=1}
	Output: []
	File table: {}
	Heap: {1=2, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=3}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: []
	File table: {}
	Heap: {1=2, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=3}
	Count Semaphore table: {}
};
Program 2
{
	Stack: [wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}, return, fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})]
	Symbol Table: {v=RefValue(1, int), latch=1}
	Output: []
	File table: {}
	Heap: {1=2, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=3}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: []
	File table: {}
	Heap: {1=2, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=3}
	Count Semaphore table: {}
};
Program 2
{
	Stack: [wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}, return, fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})]
	Symbol Table: {v=RefValue(1, int), latch=1}
	Output: []
	File table: {}
	Heap: {1=2, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=3}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: []
	File table: {}
	Heap: {1=20, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=3}
	Count Semaphore table: {}
};
Program 2
{
	Stack: [{print(rH(v)), countDown(latch)}, return, fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})]
	Symbol Table: {v=RefValue(1, int), latch=1}
	Output: []
	File table: {}
	Heap: {1=20, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=3}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: []
	File table: {}
	Heap: {1=20, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=3}
	Count Semaphore table: {}
};
Program 2
{
	Stack: [{print(rH(v)), countDown(latch)}, return, fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})]
	Symbol Table: {v=RefValue(1, int), latch=1}
	Output: []
	File table: {}
	Heap: {1=20, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=3}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: []
	File table: {}
	Heap: {1=20, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=3}
	Count Semaphore table: {}
};
Program 2
{
	Stack: [print(rH(v)), countDown(latch), return, fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})]
	Symbol Table: {v=RefValue(1, int), latch=1}
	Output: []
	File table: {}
	Heap: {1=20, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=3}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: []
	File table: {}
	Heap: {1=20, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=3}
	Count Semaphore table: {}
};
Program 2
{
	Stack: [print(rH(v)), countDown(latch), return, fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})]
	Symbol Table: {v=RefValue(1, int), latch=1}
	Output: []
	File table: {}
	Heap: {1=20, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=3}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20]
	File table: {}
	Heap: {1=20, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=3}
	Count Semaphore table: {}
};
Program 2
{
	Stack: [countDown(latch), return, fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})]
	Symbol Table: {v=RefValue(1, int), latch=1}
	Output: [20]
	File table: {}
	Heap: {1=20, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=3}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20]
	File table: {}
	Heap: {1=20, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=3}
	Count Semaphore table: {}
};
Program 2
{
	Stack: [countDown(latch), return, fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})]
	Symbol Table: {v=RefValue(1, int), latch=1}
	Output: [20]
	File table: {}
	Heap: {1=20, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=3}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2]
	File table: {}
	Heap: {1=20, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 2
{
	Stack: [return, fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})]
	Symbol Table: {v=RefValue(1, int), latch=1}
	Output: [20, 2]
	File table: {}
	Heap: {1=20, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2]
	File table: {}
	Heap: {1=20, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 2
{
	Stack: [return, fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})]
	Symbol Table: {v=RefValue(1, int), latch=1}
	Output: [20, 2]
	File table: {}
	Heap: {1=20, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2]
	File table: {}
	Heap: {1=20, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 2
{
	Stack: [fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2]
	File table: {}
	Heap: {1=20, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2]
	File table: {}
	Heap: {1=20, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 2
{
	Stack: [fork({call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])})]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2]
	File table: {}
	Heap: {1=20, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2]
	File table: {}
	Heap: {1=20, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 2
{
	Stack: []
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2]
	File table: {}
	Heap: {1=20, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 3
{
	Stack: [{call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2]
	File table: {}
	Heap: {1=20, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2]
	File table: {}
	Heap: {1=20, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 3
{
	Stack: [{call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2]
	File table: {}
	Heap: {1=20, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2]
	File table: {}
	Heap: {1=20, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 3
{
	Stack: [call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2]
	File table: {}
	Heap: {1=20, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2]
	File table: {}
	Heap: {1=20, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 3
{
	Stack: [call [forkBody[v2, cnt]], fork(call [forkBody[v3, cnt]])]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2]
	File table: {}
	Heap: {1=20, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2]
	File table: {}
	Heap: {1=20, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 3
{
	Stack: [{wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}, return, fork(call [forkBody[v3, cnt]])]
	Symbol Table: {v=RefValue(2, int), latch=1}
	Output: [20, 2]
	File table: {}
	Heap: {1=20, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2]
	File table: {}
	Heap: {1=20, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 3
{
	Stack: [{wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}, return, fork(call [forkBody[v3, cnt]])]
	Symbol Table: {v=RefValue(2, int), latch=1}
	Output: [20, 2]
	File table: {}
	Heap: {1=20, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2]
	File table: {}
	Heap: {1=20, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 3
{
	Stack: [wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}, return, fork(call [forkBody[v3, cnt]])]
	Symbol Table: {v=RefValue(2, int), latch=1}
	Output: [20, 2]
	File table: {}
	Heap: {1=20, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2]
	File table: {}
	Heap: {1=20, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 3
{
	Stack: [wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}, return, fork(call [forkBody[v3, cnt]])]
	Symbol Table: {v=RefValue(2, int), latch=1}
	Output: [20, 2]
	File table: {}
	Heap: {1=20, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2]
	File table: {}
	Heap: {1=20, 2=30, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 3
{
	Stack: [{print(rH(v)), countDown(latch)}, return, fork(call [forkBody[v3, cnt]])]
	Symbol Table: {v=RefValue(2, int), latch=1}
	Output: [20, 2]
	File table: {}
	Heap: {1=20, 2=30, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2]
	File table: {}
	Heap: {1=20, 2=30, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 3
{
	Stack: [{print(rH(v)), countDown(latch)}, return, fork(call [forkBody[v3, cnt]])]
	Symbol Table: {v=RefValue(2, int), latch=1}
	Output: [20, 2]
	File table: {}
	Heap: {1=20, 2=30, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2]
	File table: {}
	Heap: {1=20, 2=30, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 3
{
	Stack: [print(rH(v)), countDown(latch), return, fork(call [forkBody[v3, cnt]])]
	Symbol Table: {v=RefValue(2, int), latch=1}
	Output: [20, 2]
	File table: {}
	Heap: {1=20, 2=30, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2]
	File table: {}
	Heap: {1=20, 2=30, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 3
{
	Stack: [print(rH(v)), countDown(latch), return, fork(call [forkBody[v3, cnt]])]
	Symbol Table: {v=RefValue(2, int), latch=1}
	Output: [20, 2]
	File table: {}
	Heap: {1=20, 2=30, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30]
	File table: {}
	Heap: {1=20, 2=30, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 3
{
	Stack: [countDown(latch), return, fork(call [forkBody[v3, cnt]])]
	Symbol Table: {v=RefValue(2, int), latch=1}
	Output: [20, 2, 30]
	File table: {}
	Heap: {1=20, 2=30, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30]
	File table: {}
	Heap: {1=20, 2=30, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 3
{
	Stack: [countDown(latch), return, fork(call [forkBody[v3, cnt]])]
	Symbol Table: {v=RefValue(2, int), latch=1}
	Output: [20, 2, 30]
	File table: {}
	Heap: {1=20, 2=30, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30, 3]
	File table: {}
	Heap: {1=20, 2=30, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=1}
	Count Semaphore table: {}
};
Program 3
{
	Stack: [return, fork(call [forkBody[v3, cnt]])]
	Symbol Table: {v=RefValue(2, int), latch=1}
	Output: [20, 2, 30, 3]
	File table: {}
	Heap: {1=20, 2=30, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=1}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30, 3]
	File table: {}
	Heap: {1=20, 2=30, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=1}
	Count Semaphore table: {}
};
Program 3
{
	Stack: [return, fork(call [forkBody[v3, cnt]])]
	Symbol Table: {v=RefValue(2, int), latch=1}
	Output: [20, 2, 30, 3]
	File table: {}
	Heap: {1=20, 2=30, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=1}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30, 3]
	File table: {}
	Heap: {1=20, 2=30, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=1}
	Count Semaphore table: {}
};
Program 3
{
	Stack: [fork(call [forkBody[v3, cnt]])]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30, 3]
	File table: {}
	Heap: {1=20, 2=30, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=1}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30, 3]
	File table: {}
	Heap: {1=20, 2=30, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=1}
	Count Semaphore table: {}
};
Program 3
{
	Stack: [fork(call [forkBody[v3, cnt]])]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30, 3]
	File table: {}
	Heap: {1=20, 2=30, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=1}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30, 3]
	File table: {}
	Heap: {1=20, 2=30, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=1}
	Count Semaphore table: {}
};
Program 3
{
	Stack: []
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30, 3]
	File table: {}
	Heap: {1=20, 2=30, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=1}
	Count Semaphore table: {}
};
Program 4
{
	Stack: [call [forkBody[v3, cnt]]]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30, 3]
	File table: {}
	Heap: {1=20, 2=30, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=1}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30, 3]
	File table: {}
	Heap: {1=20, 2=30, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=1}
	Count Semaphore table: {}
};
Program 4
{
	Stack: [call [forkBody[v3, cnt]]]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30, 3]
	File table: {}
	Heap: {1=20, 2=30, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=1}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30, 3]
	File table: {}
	Heap: {1=20, 2=30, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=1}
	Count Semaphore table: {}
};
Program 4
{
	Stack: [{wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}, return]
	Symbol Table: {v=RefValue(3, int), latch=1}
	Output: [20, 2, 30, 3]
	File table: {}
	Heap: {1=20, 2=30, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=1}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30, 3]
	File table: {}
	Heap: {1=20, 2=30, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=1}
	Count Semaphore table: {}
};
Program 4
{
	Stack: [{wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}, return]
	Symbol Table: {v=RefValue(3, int), latch=1}
	Output: [20, 2, 30, 3]
	File table: {}
	Heap: {1=20, 2=30, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=1}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30, 3]
	File table: {}
	Heap: {1=20, 2=30, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=1}
	Count Semaphore table: {}
};
Program 4
{
	Stack: [wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}, return]
	Symbol Table: {v=RefValue(3, int), latch=1}
	Output: [20, 2, 30, 3]
	File table: {}
	Heap: {1=20, 2=30, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=1}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30, 3]
	File table: {}
	Heap: {1=20, 2=30, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=1}
	Count Semaphore table: {}
};
Program 4
{
	Stack: [wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}, return]
	Symbol Table: {v=RefValue(3, int), latch=1}
	Output: [20, 2, 30, 3]
	File table: {}
	Heap: {1=20, 2=30, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=1}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30, 3]
	File table: {}
	Heap: {1=20, 2=30, 3=40}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=1}
	Count Semaphore table: {}
};
Program 4
{
	Stack: [{print(rH(v)), countDown(latch)}, return]
	Symbol Table: {v=RefValue(3, int), latch=1}
	Output: [20, 2, 30, 3]
	File table: {}
	Heap: {1=20, 2=30, 3=40}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=1}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30, 3]
	File table: {}
	Heap: {1=20, 2=30, 3=40}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=1}
	Count Semaphore table: {}
};
Program 4
{
	Stack: [{print(rH(v)), countDown(latch)}, return]
	Symbol Table: {v=RefValue(3, int), latch=1}
	Output: [20, 2, 30, 3]
	File table: {}
	Heap: {1=20, 2=30, 3=40}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=1}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30, 3]
	File table: {}
	Heap: {1=20, 2=30, 3=40}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=1}
	Count Semaphore table: {}
};
Program 4
{
	Stack: [print(rH(v)), countDown(latch), return]
	Symbol Table: {v=RefValue(3, int), latch=1}
	Output: [20, 2, 30, 3]
	File table: {}
	Heap: {1=20, 2=30, 3=40}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=1}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30, 3]
	File table: {}
	Heap: {1=20, 2=30, 3=40}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=1}
	Count Semaphore table: {}
};
Program 4
{
	Stack: [print(rH(v)), countDown(latch), return]
	Symbol Table: {v=RefValue(3, int), latch=1}
	Output: [20, 2, 30, 3]
	File table: {}
	Heap: {1=20, 2=30, 3=40}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=1}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30, 3, 40]
	File table: {}
	Heap: {1=20, 2=30, 3=40}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=1}
	Count Semaphore table: {}
};
Program 4
{
	Stack: [countDown(latch), return]
	Symbol Table: {v=RefValue(3, int), latch=1}
	Output: [20, 2, 30, 3, 40]
	File table: {}
	Heap: {1=20, 2=30, 3=40}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=1}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30, 3, 40]
	File table: {}
	Heap: {1=20, 2=30, 3=40}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=1}
	Count Semaphore table: {}
};
Program 4
{
	Stack: [countDown(latch), return]
	Symbol Table: {v=RefValue(3, int), latch=1}
	Output: [20, 2, 30, 3, 40]
	File table: {}
	Heap: {1=20, 2=30, 3=40}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=1}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30, 3, 40, 4]
	File table: {}
	Heap: {1=20, 2=30, 3=40}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=0}
	Count Semaphore table: {}
};
Program 4
{
	Stack: [return]
	Symbol Table: {v=RefValue(3, int), latch=1}
	Output: [20, 2, 30, 3, 40, 4]
	File table: {}
	Heap: {1=20, 2=30, 3=40}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=0}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30, 3, 40, 4]
	File table: {}
	Heap: {1=20, 2=30, 3=40}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=0}
	Count Semaphore table: {}
};
Program 4
{
	Stack: [return]
	Symbol Table: {v=RefValue(3, int), latch=1}
	Output: [20, 2, 30, 3, 40, 4]
	File table: {}
	Heap: {1=20, 2=30, 3=40}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=0}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [{print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30, 3, 40, 4]
	File table: {}
	Heap: {1=20, 2=30, 3=40}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=0}
	Count Semaphore table: {}
};
Program 4
{
	Stack: []
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30, 3, 40, 4]
	File table: {}
	Heap: {1=20, 2=30, 3=40}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=0}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [{print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30, 3, 40, 4]
	File table: {}
	Heap: {1=20, 2=30, 3=40}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=0}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [print(100), {countDown(cnt), print(100)}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30, 3, 40, 4]
	File table: {}
	Heap: {1=20, 2=30, 3=40}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=0}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [print(100), {countDown(cnt), print(100)}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30, 3, 40, 4]
	File table: {}
	Heap: {1=20, 2=30, 3=40}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=0}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [{countDown(cnt), print(100)}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30, 3, 40, 4, 100]
	File table: {}
	Heap: {1=20, 2=30, 3=40}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=0}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [{countDown(cnt), print(100)}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30, 3, 40, 4, 100]
	File table: {}
	Heap: {1=20, 2=30, 3=40}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=0}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [countDown(cnt), print(100)]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30, 3, 40, 4, 100]
	File table: {}
	Heap: {1=20, 2=30, 3=40}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=0}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [countDown(cnt), print(100)]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30, 3, 40, 4, 100]
	File table: {}
	Heap: {1=20, 2=30, 3=40}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=0}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [print(100)]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30, 3, 40, 4, 100, 1]
	File table: {}
	Heap: {1=20, 2=30, 3=40}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=0}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [print(100)]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30, 3, 40, 4, 100, 1]
	File table: {}
	Heap: {1=20, 2=30, 3=40}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=0}
	Count Semaphore table: {}
};
Program 1
{
	Stack: []
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30, 3, 40, 4, 100, 1, 100]
	File table: {}
	Heap: {1=20, 2=30, 3=40}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=0}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [{procedure[forkBody[v, latch]->{wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}], {Ref(int) v1, {Ref(int) v2, {Ref(int) v3, {int cnt, {new(v1,2), {new(v2,3), {new(v3,4), {newLatch(cnt, rH(v2)), {fork({{wH(v1, rH(v1) * 10), {print(rH(v1)), countDown(cnt)}}, fork({{wH(v2, rH(v2) * 10), {print(rH(v2)), countDown(cnt)}}, fork({wH(v3, rH(v3) * 10), {print(rH(v3)), countDown(cnt)}})})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}}}}}}}}}]
	Symbol Table: {}
	Output: []
	File table: {}
	Heap: {}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [procedure[forkBody[v, latch]->{wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}], {Ref(int) v1, {Ref(int) v2, {Ref(int) v3, {int cnt, {new(v1,2), {new(v2,3), {new(v3,4), {newLatch(cnt, rH(v2)), {fork({{wH(v1, rH(v1) * 10), {print(rH(v1)), countDown(cnt)}}, fork({{wH(v2, rH(v2) * 10), {print(rH(v2)), countDown(cnt)}}, fork({wH(v3, rH(v3) * 10), {print(rH(v3)), countDown(cnt)}})})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}}}}}}}}]
	Symbol Table: {}
	Output: []
	File table: {}
	Heap: {}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [procedure[forkBody[v, latch]->{wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}], {Ref(int) v1, {Ref(int) v2, {Ref(int) v3, {int cnt, {new(v1,2), {new(v2,3), {new(v3,4), {newLatch(cnt, rH(v2)), {fork({{wH(v1, rH(v1) * 10), {print(rH(v1)), countDown(cnt)}}, fork({{wH(v2, rH(v2) * 10), {print(rH(v2)), countDown(cnt)}}, fork({wH(v3, rH(v3) * 10), {print(rH(v3)), countDown(cnt)}})})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}}}}}}}}]
	Symbol Table: {}
	Output: []
	File table: {}
	Heap: {}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [{Ref(int) v1, {Ref(int) v2, {Ref(int) v3, {int cnt, {new(v1,2), {new(v2,3), {new(v3,4), {newLatch(cnt, rH(v2)), {fork({{wH(v1, rH(v1) * 10), {print(rH(v1)), countDown(cnt)}}, fork({{wH(v2, rH(v2) * 10), {print(rH(v2)), countDown(cnt)}}, fork({wH(v3, rH(v3) * 10), {print(rH(v3)), countDown(cnt)}})})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}}}}}}}}]
	Symbol Table: {}
	Output: []
	File table: {}
	Heap: {}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [{Ref(int) v1, {Ref(int) v2, {Ref(int) v3, {int cnt, {new(v1,2), {new(v2,3), {new(v3,4), {newLatch(cnt, rH(v2)), {fork({{wH(v1, rH(v1) * 10), {print(rH(v1)), countDown(cnt)}}, fork({{wH(v2, rH(v2) * 10), {print(rH(v2)), countDown(cnt)}}, fork({wH(v3, rH(v3) * 10), {print(rH(v3)), countDown(cnt)}})})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}}}}}}}}]
	Symbol Table: {}
	Output: []
	File table: {}
	Heap: {}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [Ref(int) v1, {Ref(int) v2, {Ref(int) v3, {int cnt, {new(v1,2), {new(v2,3), {new(v3,4), {newLatch(cnt, rH(v2)), {fork({{wH(v1, rH(v1) * 10), {print(rH(v1)), countDown(cnt)}}, fork({{wH(v2, rH(v2) * 10), {print(rH(v2)), countDown(cnt)}}, fork({wH(v3, rH(v3) * 10), {print(rH(v3)), countDown(cnt)}})})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}}}}}}}]
	Symbol Table: {}
	Output: []
	File table: {}
	Heap: {}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [Ref(int) v1, {Ref(int) v2, {Ref(int) v3, {int cnt, {new(v1,2), {new(v2,3), {new(v3,4), {newLatch(cnt, rH(v2)), {fork({{wH(v1, rH(v1) * 10), {print(rH(v1)), countDown(cnt)}}, fork({{wH(v2, rH(v2) * 10), {print(rH(v2)), countDown(cnt)}}, fork({wH(v3, rH(v3) * 10), {print(rH(v3)), countDown(cnt)}})})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}}}}}}}]
	Symbol Table: {}
	Output: []
	File table: {}
	Heap: {}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [{Ref(int) v2, {Ref(int) v3, {int cnt, {new(v1,2), {new(v2,3), {new(v3,4), {newLatch(cnt, rH(v2)), {fork({{wH(v1, rH(v1) * 10), {print(rH(v1)), countDown(cnt)}}, fork({{wH(v2, rH(v2) * 10), {print(rH(v2)), countDown(cnt)}}, fork({wH(v3, rH(v3) * 10), {print(rH(v3)), countDown(cnt)}})})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}}}}}}}]
	Symbol Table: {v1=RefValue(0, int)}
	Output: []
	File table: {}
	Heap: {}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [{Ref(int) v2, {Ref(int) v3, {int cnt, {new(v1,2), {new(v2,3), {new(v3,4), {newLatch(cnt, rH(v2)), {fork({{wH(v1, rH(v1) * 10), {print(rH(v1)), countDown(cnt)}}, fork({{wH(v2, rH(v2) * 10), {print(rH(v2)), countDown(cnt)}}, fork({wH(v3, rH(v3) * 10), {print(rH(v3)), countDown(cnt)}})})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}}}}}}}]
	Symbol Table: {v1=RefValue(0, int)}
	Output: []
	File table: {}
	Heap: {}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [Ref(int) v2, {Ref(int) v3, {int cnt, {new(v1,2), {new(v2,3), {new(v3,4), {newLatch(cnt, rH(v2)), {fork({{wH(v1, rH(v1) * 10), {print(rH(v1)), countDown(cnt)}}, fork({{wH(v2, rH(v2) * 10), {print(rH(v2)), countDown(cnt)}}, fork({wH(v3, rH(v3) * 10), {print(rH(v3)), countDown(cnt)}})})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}}}}}}]
	Symbol Table: {v1=RefValue(0, int)}
	Output: []
	File table: {}
	Heap: {}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [Ref(int) v2, {Ref(int) v3, {int cnt, {new(v1,2), {new(v2,3), {new(v3,4), {newLatch(cnt, rH(v2)), {fork({{wH(v1, rH(v1) * 10), {print(rH(v1)), countDown(cnt)}}, fork({{wH(v2, rH(v2) * 10), {print(rH(v2)), countDown(cnt)}}, fork({wH(v3, rH(v3) * 10), {print(rH(v3)), countDown(cnt)}})})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}}}}}}]
	Symbol Table: {v1=RefValue(0, int)}
	Output: []
	File table: {}
	Heap: {}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [{Ref(int) v3, {int cnt, {new(v1,2), {new(v2,3), {new(v3,4), {newLatch(cnt, rH(v2)), {fork({{wH(v1, rH(v1) * 10), {print(rH(v1)), countDown(cnt)}}, fork({{wH(v2, rH(v2) * 10), {print(rH(v2)), countDown(cnt)}}, fork({wH(v3, rH(v3) * 10), {print(rH(v3)), countDown(cnt)}})})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}}}}}}]
	Symbol Table: {v1=RefValue(0, int), v2=RefValue(0, int)}
	Output: []
	File table: {}
	Heap: {}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [{Ref(int) v3, {int cnt, {new(v1,2), {new(v2,3), {new(v3,4), {newLatch(cnt, rH(v2)), {fork({{wH(v1, rH(v1) * 10), {print(rH(v1)), countDown(cnt)}}, fork({{wH(v2, rH(v2) * 10), {print(rH(v2)), countDown(cnt)}}, fork({wH(v3, rH(v3) * 10), {print(rH(v3)), countDown(cnt)}})})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}}}}}}]
	Symbol Table: {v1=RefValue(0, int), v2=RefValue(0, int)}
	Output: []
	File table: {}
	Heap: {}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [Ref(int) v3, {int cnt, {new(v1,2), {new(v2,3), {new(v3,4), {newLatch(cnt, rH(v2)), {fork({{wH(v1, rH(v1) * 10), {print(rH(v1)), countDown(cnt)}}, fork({{wH(v2, rH(v2) * 10), {print(rH(v2)), countDown(cnt)}}, fork({wH(v3, rH(v3) * 10), {print(rH(v3)), countDown(cnt)}})})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}}}}}]
	Symbol Table: {v1=RefValue(0, int), v2=RefValue(0, int)}
	Output: []
	File table: {}
	Heap: {}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [Ref(int) v3, {int cnt, {new(v1,2), {new(v2,3), {new(v3,4), {newLatch(cnt, rH(v2)), {fork({{wH(v1, rH(v1) * 10), {print(rH(v1)), countDown(cnt)}}, fork({{wH(v2, rH(v2) * 10), {print(rH(v2)), countDown(cnt)}}, fork({wH(v3, rH(v3) * 10), {print(rH(v3)), countDown(cnt)}})})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}}}}}]
	Symbol Table: {v1=RefValue(0, int), v2=RefValue(0, int)}
	Output: []
	File table: {}
	Heap: {}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [{int cnt, {new(v1,2), {new(v2,3), {new(v3,4), {newLatch(cnt, rH(v2)), {fork({{wH(v1, rH(v1) * 10), {print(rH(v1)), countDown(cnt)}}, fork({{wH(v2, rH(v2) * 10), {print(rH(v2)), countDown(cnt)}}, fork({wH(v3, rH(v3) * 10), {print(rH(v3)), countDown(cnt)}})})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}}}}}]
	Symbol Table: {v1=RefValue(0, int), v2=RefValue(0, int), v3=RefValue(0, int)}
	Output: []
	File table: {}
	Heap: {}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [{int cnt, {new(v1,2), {new(v2,3), {new(v3,4), {newLatch(cnt, rH(v2)), {fork({{wH(v1, rH(v1) * 10), {print(rH(v1)), countDown(cnt)}}, fork({{wH(v2, rH(v2) * 10), {print(rH(v2)), countDown(cnt)}}, fork({wH(v3, rH(v3) * 10), {print(rH(v3)), countDown(cnt)}})})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}}}}}]
	Symbol Table: {v1=RefValue(0, int), v2=RefValue(0, int), v3=RefValue(0, int)}
	Output: []
	File table: {}
	Heap: {}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [int cnt, {new(v1,2), {new(v2,3), {new(v3,4), {newLatch(cnt, rH(v2)), {fork({{wH(v1, rH(v1) * 10), {print(rH(v1)), countDown(cnt)}}, fork({{wH(v2, rH(v2) * 10), {print(rH(v2)), countDown(cnt)}}, fork({wH(v3, rH(v3) * 10), {print(rH(v3)), countDown(cnt)}})})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}}}}]
	Symbol Table: {v1=RefValue(0, int), v2=RefValue(0, int), v3=RefValue(0, int)}
	Output: []
	File table: {}
	Heap: {}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [int cnt, {new(v1,2), {new(v2,3), {new(v3,4), {newLatch(cnt, rH(v2)), {fork({{wH(v1, rH(v1) * 10), {print(rH(v1)), countDown(cnt)}}, fork({{wH(v2, rH(v2) * 10), {print(rH(v2)), countDown(cnt)}}, fork({wH(v3, rH(v3) * 10), {print(rH(v3)), countDown(cnt)}})})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}}}}]
	Symbol Table: {v1=RefValue(0, int), v2=RefValue(0, int), v3=RefValue(0, int)}
	Output: []
	File table: {}
	Heap: {}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [{new(v1,2), {new(v2,3), {new(v3,4), {newLatch(cnt, rH(v2)), {fork({{wH(v1, rH(v1) * 10), {print(rH(v1)), countDown(cnt)}}, fork({{wH(v2, rH(v2) * 10), {print(rH(v2)), countDown(cnt)}}, fork({wH(v3, rH(v3) * 10), {print(rH(v3)), countDown(cnt)}})})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}}}}]
	Symbol Table: {cnt=0, v1=RefValue(0, int), v2=RefValue(0, int), v3=RefValue(0, int)}
	Output: []
	File table: {}
	Heap: {}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [{new(v1,2), {new(v2,3), {new(v3,4), {newLatch(cnt, rH(v2)), {fork({{wH(v1, rH(v1) * 10), {print(rH(v1)), countDown(cnt)}}, fork({{wH(v2, rH(v2) * 10), {print(rH(v2)), countDown(cnt)}}, fork({wH(v3, rH(v3) * 10), {print(rH(v3)), countDown(cnt)}})})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}}}}]
	Symbol Table: {cnt=0, v1=RefValue(0, int), v2=RefValue(0, int), v3=RefValue(0, int)}
	Output: []
	File table: {}
	Heap: {}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [new(v1,2), {new(v2,3), {new(v3,4), {newLatch(cnt, rH(v2)), {fork({{wH(v1, rH(v1) * 10), {print(rH(v1)), countDown(cnt)}}, fork({{wH(v2, rH(v2) * 10), {print(rH(v2)), countDown(cnt)}}, fork({wH(v3, rH(v3) * 10), {print(rH(v3)), countDown(cnt)}})})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}}}]
	Symbol Table: {cnt=0, v1=RefValue(0, int), v2=RefValue(0, int), v3=RefValue(0, int)}
	Output: []
	File table: {}
	Heap: {}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [new(v1,2), {new(v2,3), {new(v3,4), {newLatch(cnt, rH(v2)), {fork({{wH(v1, rH(v1) * 10), {print(rH(v1)), countDown(cnt)}}, fork({{wH(v2, rH(v2) * 10), {print(rH(v2)), countDown(cnt)}}, fork({wH(v3, rH(v3) * 10), {print(rH(v3)), countDown(cnt)}})})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}}}]
	Symbol Table: {cnt=0, v1=RefValue(0, int), v2=RefValue(0, int), v3=RefValue(0, int)}
	Output: []
	File table: {}
	Heap: {}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [{new(v2,3), {new(v3,4), {newLatch(cnt, rH(v2)), {fork({{wH(v1, rH(v1) * 10), {print(rH(v1)), countDown(cnt)}}, fork({{wH(v2, rH(v2) * 10), {print(rH(v2)), countDown(cnt)}}, fork({wH(v3, rH(v3) * 10), {print(rH(v3)), countDown(cnt)}})})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}}}]
	Symbol Table: {cnt=0, v1=RefValue(1, int), v2=RefValue(0, int), v3=RefValue(0, int)}
	Output: []
	File table: {}
	Heap: {1=2}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [{new(v2,3), {new(v3,4), {newLatch(cnt, rH(v2)), {fork({{wH(v1, rH(v1) * 10), {print(rH(v1)), countDown(cnt)}}, fork({{wH(v2, rH(v2) * 10), {print(rH(v2)), countDown(cnt)}}, fork({wH(v3, rH(v3) * 10), {print(rH(v3)), countDown(cnt)}})})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}}}]
	Symbol Table: {cnt=0, v1=RefValue(1, int), v2=RefValue(0, int), v3=RefValue(0, int)}
	Output: []
	File table: {}
	Heap: {1=2}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [new(v2,3), {new(v3,4), {newLatch(cnt, rH(v2)), {fork({{wH(v1, rH(v1) * 10), {print(rH(v1)), countDown(cnt)}}, fork({{wH(v2, rH(v2) * 10), {print(rH(v2)), countDown(cnt)}}, fork({wH(v3, rH(v3) * 10), {print(rH(v3)), countDown(cnt)}})})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}}]
	Symbol Table: {cnt=0, v1=RefValue(1, int), v2=RefValue(0, int), v3=RefValue(0, int)}
	Output: []
	File table: {}
	Heap: {1=2}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [new(v2,3), {new(v3,4), {newLatch(cnt, rH(v2)), {fork({{wH(v1, rH(v1) * 10), {print(rH(v1)), countDown(cnt)}}, fork({{wH(v2, rH(v2) * 10), {print(rH(v2)), countDown(cnt)}}, fork({wH(v3, rH(v3) * 10), {print(rH(v3)), countDown(cnt)}})})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}}]
	Symbol Table: {cnt=0, v1=RefValue(1, int), v2=RefValue(0, int), v3=RefValue(0, int)}
	Output: []
	File table: {}
	Heap: {1=2}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [{new(v3,4), {newLatch(cnt, rH(v2)), {fork({{wH(v1, rH(v1) * 10), {print(rH(v1)), countDown(cnt)}}, fork({{wH(v2, rH(v2) * 10), {print(rH(v2)), countDown(cnt)}}, fork({wH(v3, rH(v3) * 10), {print(rH(v3)), countDown(cnt)}})})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}}]
	Symbol Table: {cnt=0, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(0, int)}
	Output: []
	File table: {}
	Heap: {1=2, 2=3}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [{new(v3,4), {newLatch(cnt, rH(v2)), {fork({{wH(v1, rH(v1) * 10), {print(rH(v1)), countDown(cnt)}}, fork({{wH(v2, rH(v2) * 10), {print(rH(v2)), countDown(cnt)}}, fork({wH(v3, rH(v3) * 10), {print(rH(v3)), countDown(cnt)}})})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}}]
	Symbol Table: {cnt=0, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(0, int)}
	Output: []
	File table: {}
	Heap: {1=2, 2=3}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [new(v3,4), {newLatch(cnt, rH(v2)), {fork({{wH(v1, rH(v1) * 10), {print(rH(v1)), countDown(cnt)}}, fork({{wH(v2, rH(v2) * 10), {print(rH(v2)), countDown(cnt)}}, fork({wH(v3, rH(v3) * 10), {print(rH(v3)), countDown(cnt)}})})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}]
	Symbol Table: {cnt=0, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(0, int)}
	Output: []
	File table: {}
	Heap: {1=2, 2=3}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [new(v3,4), {newLatch(cnt, rH(v2)), {fork({{wH(v1, rH(v1) * 10), {print(rH(v1)), countDown(cnt)}}, fork({{wH(v2, rH(v2) * 10), {print(rH(v2)), countDown(cnt)}}, fork({wH(v3, rH(v3) * 10), {print(rH(v3)), countDown(cnt)}})})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}]
	Symbol Table: {cnt=0, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(0, int)}
	Output: []
	File table: {}
	Heap: {1=2, 2=3}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [{newLatch(cnt, rH(v2)), {fork({{wH(v1, rH(v1) * 10), {print(rH(v1)), countDown(cnt)}}, fork({{wH(v2, rH(v2) * 10), {print(rH(v2)), countDown(cnt)}}, fork({wH(v3, rH(v3) * 10), {print(rH(v3)), countDown(cnt)}})})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}]
	Symbol Table: {cnt=0, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: []
	File table: {}
	Heap: {1=2, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [{newLatch(cnt, rH(v2)), {fork({{wH(v1, rH(v1) * 10), {print(rH(v1)), countDown(cnt)}}, fork({{wH(v2, rH(v2) * 10), {print(rH(v2)), countDown(cnt)}}, fork({wH(v3, rH(v3) * 10), {print(rH(v3)), countDown(cnt)}})})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}]
	Symbol Table: {cnt=0, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: []
	File table: {}
	Heap: {1=2, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [newLatch(cnt, rH(v2)), {fork({{wH(v1, rH(v1) * 10), {print(rH(v1)), countDown(cnt)}}, fork({{wH(v2, rH(v2) * 10), {print(rH(v2)), countDown(cnt)}}, fork({wH(v3, rH(v3) * 10), {print(rH(v3)), countDown(cnt)}})})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}]
	Symbol Table: {cnt=0, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: []
	File table: {}
	Heap: {1=2, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [newLatch(cnt, rH(v2)), {fork({{wH(v1, rH(v1) * 10), {print(rH(v1)), countDown(cnt)}}, fork({{wH(v2, rH(v2) * 10), {print(rH(v2)), countDown(cnt)}}, fork({wH(v3, rH(v3) * 10), {print(rH(v3)), countDown(cnt)}})})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}]
	Symbol Table: {cnt=0, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: []
	File table: {}
	Heap: {1=2, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [{fork({{wH(v1, rH(v1) * 10), {print(rH(v1)), countDown(cnt)}}, fork({{wH(v2, rH(v2) * 10), {print(rH(v2)), countDown(cnt)}}, fork({wH(v3, rH(v3) * 10), {print(rH(v3)), countDown(cnt)}})})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: []
	File table: {}
	Heap: {1=2, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=3}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [{fork({{wH(v1, rH(v1) * 10), {print(rH(v1)), countDown(cnt)}}, fork({{wH(v2, rH(v2) * 10), {print(rH(v2)), countDown(cnt)}}, fork({wH(v3, rH(v3) * 10), {print(rH(v3)), countDown(cnt)}})})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: []
	File table: {}
	Heap: {1=2, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=3}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [fork({{wH(v1, rH(v1) * 10), {print(rH(v1)), countDown(cnt)}}, fork({{wH(v2, rH(v2) * 10), {print(rH(v2)), countDown(cnt)}}, fork({wH(v3, rH(v3) * 10), {print(rH(v3)), countDown(cnt)}})})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: []
	File table: {}
	Heap: {1=2, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=3}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [fork({{wH(v1, rH(v1) * 10), {print(rH(v1)), countDown(cnt)}}, fork({{wH(v2, rH(v2) * 10), {print(rH(v2)), countDown(cnt)}}, fork({wH(v3, rH(v3) * 10), {print(rH(v3)), countDown(cnt)}})})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: []
	File table: {}
	Heap: {1=2, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=3}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [{await(cnt), {print(100), {countDown(cnt), print(100)}}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: []
	File table: {}
	Heap: {1=2, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=3}
	Count Semaphore table: {}
};
Program 2
{
	Stack: [{{wH(v1, rH(v1) * 10), {print(rH(v1)), countDown(cnt)}}, fork({{wH(v2, rH(v2) * 10), {print(rH(v2)), countDown(cnt)}}, fork({wH(v3, rH(v3) * 10), {print(rH(v3)), countDown(cnt)}})})}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: []
	File table: {}
	Heap: {1=2, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=3}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [{await(cnt), {print(100), {countDown(cnt), print(100)}}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: []
	File table: {}
	Heap: {1=2, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=3}
	Count Semaphore table: {}
};
Program 2
{
	Stack: [{{wH(v1, rH(v1) * 10), {print(rH(v1)), countDown(cnt)}}, fork({{wH(v2, rH(v2) * 10), {print(rH(v2)), countDown(cnt)}}, fork({wH(v3, rH(v3) * 10), {print(rH(v3)), countDown(cnt)}})})}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: []
	File table: {}
	Heap: {1=2, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=3}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: []
	File table: {}
	Heap: {1=2, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=3}
	Count Semaphore table: {}
};
Program 2
{
	Stack: [{wH(v1, rH(v1) * 10), {print(rH(v1)), countDown(cnt)}}, fork({{wH(v2, rH(v2) * 10), {print(rH(v2)), countDown(cnt)}}, fork({wH(v3, rH(v3) * 10), {print(rH(v3)), countDown(cnt)}})})]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: []
	File table: {}
	Heap: {1=2, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=3}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: []
	File table: {}
	Heap: {1=2, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=3}
	Count Semaphore table: {}
};
Program 2
{
	Stack: [{wH(v1, rH(v1) * 10), {print(rH(v1)), countDown(cnt)}}, fork({{wH(v2, rH(v2) * 10), {print(rH(v2)), countDown(cnt)}}, fork({wH(v3, rH(v3) * 10), {print(rH(v3)), countDown(cnt)}})})]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: []
	File table: {}
	Heap: {1=2, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=3}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: []
	File table: {}
	Heap: {1=2, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=3}
	Count Semaphore table: {}
};
Program 2
{
	Stack: [wH(v1, rH(v1) * 10), {print(rH(v1)), countDown(cnt)}, fork({{wH(v2, rH(v2) * 10), {print(rH(v2)), countDown(cnt)}}, fork({wH(v3, rH(v3) * 10), {print(rH(v3)), countDown(cnt)}})})]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: []
	File table: {}
	Heap: {1=2, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=3}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: []
	File table: {}
	Heap: {1=2, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=3}
	Count Semaphore table: {}
};
Program 2
{
	Stack: [wH(v1, rH(v1) * 10), {print(rH(v1)), countDown(cnt)}, fork({{wH(v2, rH(v2) * 10), {print(rH(v2)), countDown(cnt)}}, fork({wH(v3, rH(v3) * 10), {print(rH(v3)), countDown(cnt)}})})]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: []
	File table: {}
	Heap: {1=2, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=3}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: []
	File table: {}
	Heap: {1=20, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=3}
	Count Semaphore table: {}
};
Program 2
{
	Stack: [{print(rH(v1)), countDown(cnt)}, fork({{wH(v2, rH(v2) * 10), {print(rH(v2)), countDown(cnt)}}, fork({wH(v3, rH(v3) * 10), {print(rH(v3)), countDown(cnt)}})})]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: []
	File table: {}
	Heap: {1=20, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=3}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: []
	File table: {}
	Heap: {1=20, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=3}
	Count Semaphore table: {}
};
Program 2
{
	Stack: [{print(rH(v1)), countDown(cnt)}, fork({{wH(v2, rH(v2) * 10), {print(rH(v2)), countDown(cnt)}}, fork({wH(v3, rH(v3) * 10), {print(rH(v3)), countDown(cnt)}})})]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: []
	File table: {}
	Heap: {1=20, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=3}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: []
	File table: {}
	Heap: {1=20, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=3}
	Count Semaphore table: {}
};
Program 2
{
	Stack: [print(rH(v1)), countDown(cnt), fork({{wH(v2, rH(v2) * 10), {print(rH(v2)), countDown(cnt)}}, fork({wH(v3, rH(v3) * 10), {print(rH(v3)), countDown(cnt)}})})]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: []
	File table: {}
	Heap: {1=20, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=3}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: []
	File table: {}
	Heap: {1=20, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=3}
	Count Semaphore table: {}
};
Program 2
{
	Stack: [print(rH(v1)), countDown(cnt), fork({{wH(v2, rH(v2) * 10), {print(rH(v2)), countDown(cnt)}}, fork({wH(v3, rH(v3) * 10), {print(rH(v3)), countDown(cnt)}})})]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: []
	File table: {}
	Heap: {1=20, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=3}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20]
	File table: {}
	Heap: {1=20, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=3}
	Count Semaphore table: {}
};
Program 2
{
	Stack: [countDown(cnt), fork({{wH(v2, rH(v2) * 10), {print(rH(v2)), countDown(cnt)}}, fork({wH(v3, rH(v3) * 10), {print(rH(v3)), countDown(cnt)}})})]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20]
	File table: {}
	Heap: {1=20, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=3}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20]
	File table: {}
	Heap: {1=20, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=3}
	Count Semaphore table: {}
};
Program 2
{
	Stack: [countDown(cnt), fork({{wH(v2, rH(v2) * 10), {print(rH(v2)), countDown(cnt)}}, fork({wH(v3, rH(v3) * 10), {print(rH(v3)), countDown(cnt)}})})]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20]
	File table: {}
	Heap: {1=20, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=3}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2]
	File table: {}
	Heap: {1=20, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 2
{
	Stack: [fork({{wH(v2, rH(v2) * 10), {print(rH(v2)), countDown(cnt)}}, fork({wH(v3, rH(v3) * 10), {print(rH(v3)), countDown(cnt)}})})]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2]
	File table: {}
	Heap: {1=20, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2]
	File table: {}
	Heap: {1=20, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 2
{
	Stack: [fork({{wH(v2, rH(v2) * 10), {print(rH(v2)), countDown(cnt)}}, fork({wH(v3, rH(v3) * 10), {print(rH(v3)), countDown(cnt)}})})]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2]
	File table: {}
	Heap: {1=20, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2]
	File table: {}
	Heap: {1=20, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 2
{
	Stack: []
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2]
	File table: {}
	Heap: {1=20, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 3
{
	Stack: [{{wH(v2, rH(v2) * 10), {print(rH(v2)), countDown(cnt)}}, fork({wH(v3, rH(v3) * 10), {print(rH(v3)), countDown(cnt)}})}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2]
	File table: {}
	Heap: {1=20, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2]
	File table: {}
	Heap: {1=20, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 3
{
	Stack: [{{wH(v2, rH(v2) * 10), {print(rH(v2)), countDown(cnt)}}, fork({wH(v3, rH(v3) * 10), {print(rH(v3)), countDown(cnt)}})}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2]
	File table: {}
	Heap: {1=20, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2]
	File table: {}
	Heap: {1=20, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 3
{
	Stack: [{wH(v2, rH(v2) * 10), {print(rH(v2)), countDown(cnt)}}, fork({wH(v3, rH(v3) * 10), {print(rH(v3)), countDown(cnt)}})]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2]
	File table: {}
	Heap: {1=20, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2]
	File table: {}
	Heap: {1=20, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 3
{
	Stack: [{wH(v2, rH(v2) * 10), {print(rH(v2)), countDown(cnt)}}, fork({wH(v3, rH(v3) * 10), {print(rH(v3)), countDown(cnt)}})]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2]
	File table: {}
	Heap: {1=20, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2]
	File table: {}
	Heap: {1=20, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 3
{
	Stack: [wH(v2, rH(v2) * 10), {print(rH(v2)), countDown(cnt)}, fork({wH(v3, rH(v3) * 10), {print(rH(v3)), countDown(cnt)}})]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2]
	File table: {}
	Heap: {1=20, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2]
	File table: {}
	Heap: {1=20, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 3
{
	Stack: [wH(v2, rH(v2) * 10), {print(rH(v2)), countDown(cnt)}, fork({wH(v3, rH(v3) * 10), {print(rH(v3)), countDown(cnt)}})]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2]
	File table: {}
	Heap: {1=20, 2=3, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2]
	File table: {}
	Heap: {1=20, 2=30, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 3
{
	Stack: [{print(rH(v2)), countDown(cnt)}, fork({wH(v3, rH(v3) * 10), {print(rH(v3)), countDown(cnt)}})]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2]
	File table: {}
	Heap: {1=20, 2=30, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2]
	File table: {}
	Heap: {1=20, 2=30, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 3
{
	Stack: [{print(rH(v2)), countDown(cnt)}, fork({wH(v3, rH(v3) * 10), {print(rH(v3)), countDown(cnt)}})]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2]
	File table: {}
	Heap: {1=20, 2=30, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2]
	File table: {}
	Heap: {1=20, 2=30, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 3
{
	Stack: [print(rH(v2)), countDown(cnt), fork({wH(v3, rH(v3) * 10), {print(rH(v3)), countDown(cnt)}})]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2]
	File table: {}
	Heap: {1=20, 2=30, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2]
	File table: {}
	Heap: {1=20, 2=30, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 3
{
	Stack: [print(rH(v2)), countDown(cnt), fork({wH(v3, rH(v3) * 10), {print(rH(v3)), countDown(cnt)}})]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2]
	File table: {}
	Heap: {1=20, 2=30, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30]
	File table: {}
	Heap: {1=20, 2=30, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 3
{
	Stack: [countDown(cnt), fork({wH(v3, rH(v3) * 10), {print(rH(v3)), countDown(cnt)}})]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30]
	File table: {}
	Heap: {1=20, 2=30, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30]
	File table: {}
	Heap: {1=20, 2=30, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 3
{
	Stack: [countDown(cnt), fork({wH(v3, rH(v3) * 10), {print(rH(v3)), countDown(cnt)}})]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30]
	File table: {}
	Heap: {1=20, 2=30, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30, 3]
	File table: {}
	Heap: {1=20, 2=30, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=1}
	Count Semaphore table: {}
};
Program 3
{
	Stack: [fork({wH(v3, rH(v3) * 10), {print(rH(v3)), countDown(cnt)}})]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30, 3]
	File table: {}
	Heap: {1=20, 2=30, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=1}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30, 3]
	File table: {}
	Heap: {1=20, 2=30, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=1}
	Count Semaphore table: {}
};
Program 3
{
	Stack: [fork({wH(v3, rH(v3) * 10), {print(rH(v3)), countDown(cnt)}})]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30, 3]
	File table: {}
	Heap: {1=20, 2=30, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=1}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30, 3]
	File table: {}
	Heap: {1=20, 2=30, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=1}
	Count Semaphore table: {}
};
Program 3
{
	Stack: []
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30, 3]
	File table: {}
	Heap: {1=20, 2=30, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=1}
	Count Semaphore table: {}
};
Program 4
{
	Stack: [{wH(v3, rH(v3) * 10), {print(rH(v3)), countDown(cnt)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30, 3]
	File table: {}
	Heap: {1=20, 2=30, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=1}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30, 3]
	File table: {}
	Heap: {1=20, 2=30, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=1}
	Count Semaphore table: {}
};
Program 4
{
	Stack: [{wH(v3, rH(v3) * 10), {print(rH(v3)), countDown(cnt)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30, 3]
	File table: {}
	Heap: {1=20, 2=30, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=1}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30, 3]
	File table: {}
	Heap: {1=20, 2=30, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=1}
	Count Semaphore table: {}
};
Program 4
{
	Stack: [wH(v3, rH(v3) * 10), {print(rH(v3)), countDown(cnt)}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30, 3]
	File table: {}
	Heap: {1=20, 2=30, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=1}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30, 3]
	File table: {}
	Heap: {1=20, 2=30, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=1}
	Count Semaphore table: {}
};
Program 4
{
	Stack: [wH(v3, rH(v3) * 10), {print(rH(v3)), countDown(cnt)}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30, 3]
	File table: {}
	Heap: {1=20, 2=30, 3=4}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=1}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30, 3]
	File table: {}
	Heap: {1=20, 2=30, 3=40}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=1}
	Count Semaphore table: {}
};
Program 4
{
	Stack: [{print(rH(v3)), countDown(cnt)}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30, 3]
	File table: {}
	Heap: {1=20, 2=30, 3=40}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=1}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30, 3]
	File table: {}
	Heap: {1=20, 2=30, 3=40}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=1}
	Count Semaphore table: {}
};
Program 4
{
	Stack: [{print(rH(v3)), countDown(cnt)}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30, 3]
	File table: {}
	Heap: {1=20, 2=30, 3=40}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=1}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30, 3]
	File table: {}
	Heap: {1=20, 2=30, 3=40}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=1}
	Count Semaphore table: {}
};
Program 4
{
	Stack: [print(rH(v3)), countDown(cnt)]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30, 3]
	File table: {}
	Heap: {1=20, 2=30, 3=40}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=1}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30, 3]
	File table: {}
	Heap: {1=20, 2=30, 3=40}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=1}
	Count Semaphore table: {}
};
Program 4
{
	Stack: [print(rH(v3)), countDown(cnt)]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30, 3]
	File table: {}
	Heap: {1=20, 2=30, 3=40}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=1}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30, 3, 40]
	File table: {}
	Heap: {1=20, 2=30, 3=40}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=1}
	Count Semaphore table: {}
};
Program 4
{
	Stack: [countDown(cnt)]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30, 3, 40]
	File table: {}
	Heap: {1=20, 2=30, 3=40}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=1}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30, 3, 40]
	File table: {}
	Heap: {1=20, 2=30, 3=40}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=1}
	Count Semaphore table: {}
};
Program 4
{
	Stack: [countDown(cnt)]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30, 3, 40]
	File table: {}
	Heap: {1=20, 2=30, 3=40}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=1}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30, 3, 40, 4]
	File table: {}
	Heap: {1=20, 2=30, 3=40}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=0}
	Count Semaphore table: {}
};
Program 4
{
	Stack: []
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30, 3, 40, 4]
	File table: {}
	Heap: {1=20, 2=30, 3=40}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=0}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30, 3, 40, 4]
	File table: {}
	Heap: {1=20, 2=30, 3=40}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=0}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [{print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30, 3, 40, 4]
	File table: {}
	Heap: {1=20, 2=30, 3=40}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=0}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [{print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30, 3, 40, 4]
	File table: {}
	Heap: {1=20, 2=30, 3=40}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=0}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [print(100), {countDown(cnt), print(100)}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30, 3, 40, 4]
	File table: {}
	Heap: {1=20, 2=30, 3=40}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=0}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [print(100), {countDown(cnt), print(100)}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30, 3, 40, 4]
	File table: {}
	Heap: {1=20, 2=30, 3=40}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=0}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [{countDown(cnt), print(100)}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30, 3, 40, 4, 100]
	File table: {}
	Heap: {1=20, 2=30, 3=40}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=0}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [{countDown(cnt), print(100)}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30, 3, 40, 4, 100]
	File table: {}
	Heap: {1=20, 2=30, 3=40}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=0}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [countDown(cnt), print(100)]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30, 3, 40, 4, 100]
	File table: {}
	Heap: {1=20, 2=30, 3=40}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=0}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [countDown(cnt), print(100)]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30, 3, 40, 4, 100]
	File table: {}
	Heap: {1=20, 2=30, 3=40}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=0}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [print(100)]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30, 3, 40, 4, 100, 1]
	File table: {}
	Heap: {1=20, 2=30, 3=40}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=0}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [print(100)]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30, 3, 40, 4, 100, 1]
	File table: {}
	Heap: {1=20, 2=30, 3=40}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=0}
	Count Semaphore table: {}
};
Program 1
{
	Stack: []
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30, 3, 40, 4, 100, 1, 100]
	File table: {}
	Heap: {1=20, 2=30, 3=40}
	Procedures: {forkBody=<[v, latch], {wH(v, rH(v) * 10), {print(rH(v)), countDown(latch)}}>}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=0}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [{Ref(int) v1, {Ref(int) v2, {Ref(int) v3, {int cnt, {new(v1,2), {new(v2,3), {new(v3,4), {newLatch(cnt, rH(v2)), {fork({{wH(v1, rH(v1) * 10), {print(rH(v1)), countDown(cnt)}}, fork({{wH(v2, rH(v2) * 10), {print(rH(v2)), countDown(cnt)}}, fork({wH(v3, rH(v3) * 10), {print(rH(v3)), countDown(cnt)}})})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}}}}}}}}]
	Symbol Table: {}
	Output: []
	File table: {}
	Heap: {}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [Ref(int) v1, {Ref(int) v2, {Ref(int) v3, {int cnt, {new(v1,2), {new(v2,3), {new(v3,4), {newLatch(cnt, rH(v2)), {fork({{wH(v1, rH(v1) * 10), {print(rH(v1)), countDown(cnt)}}, fork({{wH(v2, rH(v2) * 10), {print(rH(v2)), countDown(cnt)}}, fork({wH(v3, rH(v3) * 10), {print(rH(v3)), countDown(cnt)}})})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}}}}}}}]
	Symbol Table: {}
	Output: []
	File table: {}
	Heap: {}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [Ref(int) v1, {Ref(int) v2, {Ref(int) v3, {int cnt, {new(v1,2), {new(v2,3), {new(v3,4), {newLatch(cnt, rH(v2)), {fork({{wH(v1, rH(v1) * 10), {print(rH(v1)), countDown(cnt)}}, fork({{wH(v2, rH(v2) * 10), {print(rH(v2)), countDown(cnt)}}, fork({wH(v3, rH(v3) * 10), {print(rH(v3)), countDown(cnt)}})})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}}}}}}}]
	Symbol Table: {}
	Output: []
	File table: {}
	Heap: {}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [{Ref(int) v2, {Ref(int) v3, {int cnt, {new(v1,2), {new(v2,3), {new(v3,4), {newLatch(cnt, rH(v2)), {fork({{wH(v1, rH(v1) * 10), {print(rH(v1)), countDown(cnt)}}, fork({{wH(v2, rH(v2) * 10), {print(rH(v2)), countDown(cnt)}}, fork({wH(v3, rH(v3) * 10), {print(rH(v3)), countDown(cnt)}})})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}}}}}}}]
	Symbol Table: {v1=RefValue(0, int)}
	Output: []
	File table: {}
	Heap: {}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [{Ref(int) v2, {Ref(int) v3, {int cnt, {new(v1,2), {new(v2,3), {new(v3,4), {newLatch(cnt, rH(v2)), {fork({{wH(v1, rH(v1) * 10), {print(rH(v1)), countDown(cnt)}}, fork({{wH(v2, rH(v2) * 10), {print(rH(v2)), countDown(cnt)}}, fork({wH(v3, rH(v3) * 10), {print(rH(v3)), countDown(cnt)}})})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}}}}}}}]
	Symbol Table: {v1=RefValue(0, int)}
	Output: []
	File table: {}
	Heap: {}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [Ref(int) v2, {Ref(int) v3, {int cnt, {new(v1,2), {new(v2,3), {new(v3,4), {newLatch(cnt, rH(v2)), {fork({{wH(v1, rH(v1) * 10), {print(rH(v1)), countDown(cnt)}}, fork({{wH(v2, rH(v2) * 10), {print(rH(v2)), countDown(cnt)}}, fork({wH(v3, rH(v3) * 10), {print(rH(v3)), countDown(cnt)}})})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}}}}}}]
	Symbol Table: {v1=RefValue(0, int)}
	Output: []
	File table: {}
	Heap: {}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [Ref(int) v2, {Ref(int) v3, {int cnt, {new(v1,2), {new(v2,3), {new(v3,4), {newLatch(cnt, rH(v2)), {fork({{wH(v1, rH(v1) * 10), {print(rH(v1)), countDown(cnt)}}, fork({{wH(v2, rH(v2) * 10), {print(rH(v2)), countDown(cnt)}}, fork({wH(v3, rH(v3) * 10), {print(rH(v3)), countDown(cnt)}})})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}}}}}}]
	Symbol Table: {v1=RefValue(0, int)}
	Output: []
	File table: {}
	Heap: {}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [{Ref(int) v3, {int cnt, {new(v1,2), {new(v2,3), {new(v3,4), {newLatch(cnt, rH(v2)), {fork({{wH(v1, rH(v1) * 10), {print(rH(v1)), countDown(cnt)}}, fork({{wH(v2, rH(v2) * 10), {print(rH(v2)), countDown(cnt)}}, fork({wH(v3, rH(v3) * 10), {print(rH(v3)), countDown(cnt)}})})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}}}}}}]
	Symbol Table: {v1=RefValue(0, int), v2=RefValue(0, int)}
	Output: []
	File table: {}
	Heap: {}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [{Ref(int) v3, {int cnt, {new(v1,2), {new(v2,3), {new(v3,4), {newLatch(cnt, rH(v2)), {fork({{wH(v1, rH(v1) * 10), {print(rH(v1)), countDown(cnt)}}, fork({{wH(v2, rH(v2) * 10), {print(rH(v2)), countDown(cnt)}}, fork({wH(v3, rH(v3) * 10), {print(rH(v3)), countDown(cnt)}})})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}}}}}}]
	Symbol Table: {v1=RefValue(0, int), v2=RefValue(0, int)}
	Output: []
	File table: {}
	Heap: {}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [Ref(int) v3, {int cnt, {new(v1,2), {new(v2,3), {new(v3,4), {newLatch(cnt, rH(v2)), {fork({{wH(v1, rH(v1) * 10), {print(rH(v1)), countDown(cnt)}}, fork({{wH(v2, rH(v2) * 10), {print(rH(v2)), countDown(cnt)}}, fork({wH(v3, rH(v3) * 10), {print(rH(v3)), countDown(cnt)}})})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}}}}}]
	Symbol Table: {v1=RefValue(0, int), v2=RefValue(0, int)}
	Output: []
	File table: {}
	Heap: {}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [Ref(int) v3, {int cnt, {new(v1,2), {new(v2,3), {new(v3,4), {newLatch(cnt, rH(v2)), {fork({{wH(v1, rH(v1) * 10), {print(rH(v1)), countDown(cnt)}}, fork({{wH(v2, rH(v2) * 10), {print(rH(v2)), countDown(cnt)}}, fork({wH(v3, rH(v3) * 10), {print(rH(v3)), countDown(cnt)}})})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}}}}}]
	Symbol Table: {v1=RefValue(0, int), v2=RefValue(0, int)}
	Output: []
	File table: {}
	Heap: {}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [{int cnt, {new(v1,2), {new(v2,3), {new(v3,4), {newLatch(cnt, rH(v2)), {fork({{wH(v1, rH(v1) * 10), {print(rH(v1)), countDown(cnt)}}, fork({{wH(v2, rH(v2) * 10), {print(rH(v2)), countDown(cnt)}}, fork({wH(v3, rH(v3) * 10), {print(rH(v3)), countDown(cnt)}})})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}}}}}]
	Symbol Table: {v1=RefValue(0, int), v2=RefValue(0, int), v3=RefValue(0, int)}
	Output: []
	File table: {}
	Heap: {}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [{int cnt, {new(v1,2), {new(v2,3), {new(v3,4), {newLatch(cnt, rH(v2)), {fork({{wH(v1, rH(v1) * 10), {print(rH(v1)), countDown(cnt)}}, fork({{wH(v2, rH(v2) * 10), {print(rH(v2)), countDown(cnt)}}, fork({wH(v3, rH(v3) * 10), {print(rH(v3)), countDown(cnt)}})})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}}}}}]
	Symbol Table: {v1=RefValue(0, int), v2=RefValue(0, int), v3=RefValue(0, int)}
	Output: []
	File table: {}
	Heap: {}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [int cnt, {new(v1,2), {new(v2,3), {new(v3,4), {newLatch(cnt, rH(v2)), {fork({{wH(v1, rH(v1) * 10), {print(rH(v1)), countDown(cnt)}}, fork({{wH(v2, rH(v2) * 10), {print(rH(v2)), countDown(cnt)}}, fork({wH(v3, rH(v3) * 10), {print(rH(v3)), countDown(cnt)}})})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}}}}]
	Symbol Table: {v1=RefValue(0, int), v2=RefValue(0, int), v3=RefValue(0, int)}
	Output: []
	File table: {}
	Heap: {}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [int cnt, {new(v1,2), {new(v2,3), {new(v3,4), {newLatch(cnt, rH(v2)), {fork({{wH(v1, rH(v1) * 10), {print(rH(v1)), countDown(cnt)}}, fork({{wH(v2, rH(v2) * 10), {print(rH(v2)), countDown(cnt)}}, fork({wH(v3, rH(v3) * 10), {print(rH(v3)), countDown(cnt)}})})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}}}}]
	Symbol Table: {v1=RefValue(0, int), v2=RefValue(0, int), v3=RefValue(0, int)}
	Output: []
	File table: {}
	Heap: {}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [{new(v1,2), {new(v2,3), {new(v3,4), {newLatch(cnt, rH(v2)), {fork({{wH(v1, rH(v1) * 10), {print(rH(v1)), countDown(cnt)}}, fork({{wH(v2, rH(v2) * 10), {print(rH(v2)), countDown(cnt)}}, fork({wH(v3, rH(v3) * 10), {print(rH(v3)), countDown(cnt)}})})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}}}}]
	Symbol Table: {cnt=0, v1=RefValue(0, int), v2=RefValue(0, int), v3=RefValue(0, int)}
	Output: []
	File table: {}
	Heap: {}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [{new(v1,2), {new(v2,3), {new(v3,4), {newLatch(cnt, rH(v2)), {fork({{wH(v1, rH(v1) * 10), {print(rH(v1)), countDown(cnt)}}, fork({{wH(v2, rH(v2) * 10), {print(rH(v2)), countDown(cnt)}}, fork({wH(v3, rH(v3) * 10), {print(rH(v3)), countDown(cnt)}})})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}}}}]
	Symbol Table: {cnt=0, v1=RefValue(0, int), v2=RefValue(0, int), v3=RefValue(0, int)}
	Output: []
	File table: {}
	Heap: {}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [new(v1,2), {new(v2,3), {new(v3,4), {newLatch(cnt, rH(v2)), {fork({{wH(v1, rH(v1) * 10), {print(rH(v1)), countDown(cnt)}}, fork({{wH(v2, rH(v2) * 10), {print(rH(v2)), countDown(cnt)}}, fork({wH(v3, rH(v3) * 10), {print(rH(v3)), countDown(cnt)}})})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}}}]
	Symbol Table: {cnt=0, v1=RefValue(0, int), v2=RefValue(0, int), v3=RefValue(0, int)}
	Output: []
	File table: {}
	Heap: {}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [new(v1,2), {new(v2,3), {new(v3,4), {newLatch(cnt, rH(v2)), {fork({{wH(v1, rH(v1) * 10), {print(rH(v1)), countDown(cnt)}}, fork({{wH(v2, rH(v2) * 10), {print(rH(v2)), countDown(cnt)}}, fork({wH(v3, rH(v3) * 10), {print(rH(v3)), countDown(cnt)}})})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}}}]
	Symbol Table: {cnt=0, v1=RefValue(0, int), v2=RefValue(0, int), v3=RefValue(0, int)}
	Output: []
	File table: {}
	Heap: {}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [{new(v2,3), {new(v3,4), {newLatch(cnt, rH(v2)), {fork({{wH(v1, rH(v1) * 10), {print(rH(v1)), countDown(cnt)}}, fork({{wH(v2, rH(v2) * 10), {print(rH(v2)), countDown(cnt)}}, fork({wH(v3, rH(v3) * 10), {print(rH(v3)), countDown(cnt)}})})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}}}]
	Symbol Table: {cnt=0, v1=RefValue(1, int), v2=RefValue(0, int), v3=RefValue(0, int)}
	Output: []
	File table: {}
	Heap: {1=2}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [{new(v2,3), {new(v3,4), {newLatch(cnt, rH(v2)), {fork({{wH(v1, rH(v1) * 10), {print(rH(v1)), countDown(cnt)}}, fork({{wH(v2, rH(v2) * 10), {print(rH(v2)), countDown(cnt)}}, fork({wH(v3, rH(v3) * 10), {print(rH(v3)), countDown(cnt)}})})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}}}]
	Symbol Table: {cnt=0, v1=RefValue(1, int), v2=RefValue(0, int), v3=RefValue(0, int)}
	Output: []
	File table: {}
	Heap: {1=2}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [new(v2,3), {new(v3,4), {newLatch(cnt, rH(v2)), {fork({{wH(v1, rH(v1) * 10), {print(rH(v1)), countDown(cnt)}}, fork({{wH(v2, rH(v2) * 10), {print(rH(v2)), countDown(cnt)}}, fork({wH(v3, rH(v3) * 10), {print(rH(v3)), countDown(cnt)}})})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}}]
	Symbol Table: {cnt=0, v1=RefValue(1, int), v2=RefValue(0, int), v3=RefValue(0, int)}
	Output: []
	File table: {}
	Heap: {1=2}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [new(v2,3), {new(v3,4), {newLatch(cnt, rH(v2)), {fork({{wH(v1, rH(v1) * 10), {print(rH(v1)), countDown(cnt)}}, fork({{wH(v2, rH(v2) * 10), {print(rH(v2)), countDown(cnt)}}, fork({wH(v3, rH(v3) * 10), {print(rH(v3)), countDown(cnt)}})})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}}]
	Symbol Table: {cnt=0, v1=RefValue(1, int), v2=RefValue(0, int), v3=RefValue(0, int)}
	Output: []
	File table: {}
	Heap: {1=2}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [{new(v3,4), {newLatch(cnt, rH(v2)), {fork({{wH(v1, rH(v1) * 10), {print(rH(v1)), countDown(cnt)}}, fork({{wH(v2, rH(v2) * 10), {print(rH(v2)), countDown(cnt)}}, fork({wH(v3, rH(v3) * 10), {print(rH(v3)), countDown(cnt)}})})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}}]
	Symbol Table: {cnt=0, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(0, int)}
	Output: []
	File table: {}
	Heap: {1=2, 2=3}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [{new(v3,4), {newLatch(cnt, rH(v2)), {fork({{wH(v1, rH(v1) * 10), {print(rH(v1)), countDown(cnt)}}, fork({{wH(v2, rH(v2) * 10), {print(rH(v2)), countDown(cnt)}}, fork({wH(v3, rH(v3) * 10), {print(rH(v3)), countDown(cnt)}})})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}}]
	Symbol Table: {cnt=0, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(0, int)}
	Output: []
	File table: {}
	Heap: {1=2, 2=3}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [new(v3,4), {newLatch(cnt, rH(v2)), {fork({{wH(v1, rH(v1) * 10), {print(rH(v1)), countDown(cnt)}}, fork({{wH(v2, rH(v2) * 10), {print(rH(v2)), countDown(cnt)}}, fork({wH(v3, rH(v3) * 10), {print(rH(v3)), countDown(cnt)}})})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}]
	Symbol Table: {cnt=0, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(0, int)}
	Output: []
	File table: {}
	Heap: {1=2, 2=3}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [new(v3,4), {newLatch(cnt, rH(v2)), {fork({{wH(v1, rH(v1) * 10), {print(rH(v1)), countDown(cnt)}}, fork({{wH(v2, rH(v2) * 10), {print(rH(v2)), countDown(cnt)}}, fork({wH(v3, rH(v3) * 10), {print(rH(v3)), countDown(cnt)}})})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}]
	Symbol Table: {cnt=0, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(0, int)}
	Output: []
	File table: {}
	Heap: {1=2, 2=3}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [{newLatch(cnt, rH(v2)), {fork({{wH(v1, rH(v1) * 10), {print(rH(v1)), countDown(cnt)}}, fork({{wH(v2, rH(v2) * 10), {print(rH(v2)), countDown(cnt)}}, fork({wH(v3, rH(v3) * 10), {print(rH(v3)), countDown(cnt)}})})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}]
	Symbol Table: {cnt=0, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: []
	File table: {}
	Heap: {1=2, 2=3, 3=4}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [{newLatch(cnt, rH(v2)), {fork({{wH(v1, rH(v1) * 10), {print(rH(v1)), countDown(cnt)}}, fork({{wH(v2, rH(v2) * 10), {print(rH(v2)), countDown(cnt)}}, fork({wH(v3, rH(v3) * 10), {print(rH(v3)), countDown(cnt)}})})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}]
	Symbol Table: {cnt=0, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: []
	File table: {}
	Heap: {1=2, 2=3, 3=4}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [newLatch(cnt, rH(v2)), {fork({{wH(v1, rH(v1) * 10), {print(rH(v1)), countDown(cnt)}}, fork({{wH(v2, rH(v2) * 10), {print(rH(v2)), countDown(cnt)}}, fork({wH(v3, rH(v3) * 10), {print(rH(v3)), countDown(cnt)}})})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}]
	Symbol Table: {cnt=0, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: []
	File table: {}
	Heap: {1=2, 2=3, 3=4}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [newLatch(cnt, rH(v2)), {fork({{wH(v1, rH(v1) * 10), {print(rH(v1)), countDown(cnt)}}, fork({{wH(v2, rH(v2) * 10), {print(rH(v2)), countDown(cnt)}}, fork({wH(v3, rH(v3) * 10), {print(rH(v3)), countDown(cnt)}})})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}]
	Symbol Table: {cnt=0, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: []
	File table: {}
	Heap: {1=2, 2=3, 3=4}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [{fork({{wH(v1, rH(v1) * 10), {print(rH(v1)), countDown(cnt)}}, fork({{wH(v2, rH(v2) * 10), {print(rH(v2)), countDown(cnt)}}, fork({wH(v3, rH(v3) * 10), {print(rH(v3)), countDown(cnt)}})})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: []
	File table: {}
	Heap: {1=2, 2=3, 3=4}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=3}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [{fork({{wH(v1, rH(v1) * 10), {print(rH(v1)), countDown(cnt)}}, fork({{wH(v2, rH(v2) * 10), {print(rH(v2)), countDown(cnt)}}, fork({wH(v3, rH(v3) * 10), {print(rH(v3)), countDown(cnt)}})})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: []
	File table: {}
	Heap: {1=2, 2=3, 3=4}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=3}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [fork({{wH(v1, rH(v1) * 10), {print(rH(v1)), countDown(cnt)}}, fork({{wH(v2, rH(v2) * 10), {print(rH(v2)), countDown(cnt)}}, fork({wH(v3, rH(v3) * 10), {print(rH(v3)), countDown(cnt)}})})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: []
	File table: {}
	Heap: {1=2, 2=3, 3=4}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=3}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [fork({{wH(v1, rH(v1) * 10), {print(rH(v1)), countDown(cnt)}}, fork({{wH(v2, rH(v2) * 10), {print(rH(v2)), countDown(cnt)}}, fork({wH(v3, rH(v3) * 10), {print(rH(v3)), countDown(cnt)}})})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: []
	File table: {}
	Heap: {1=2, 2=3, 3=4}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=3}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [{await(cnt), {print(100), {countDown(cnt), print(100)}}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: []
	File table: {}
	Heap: {1=2, 2=3, 3=4}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=3}
	Count Semaphore table: {}
};
Program 2
{
	Stack: [{{wH(v1, rH(v1) * 10), {print(rH(v1)), countDown(cnt)}}, fork({{wH(v2, rH(v2) * 10), {print(rH(v2)), countDown(cnt)}}, fork({wH(v3, rH(v3) * 10), {print(rH(v3)), countDown(cnt)}})})}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: []
	File table: {}
	Heap: {1=2, 2=3, 3=4}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=3}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [{await(cnt), {print(100), {countDown(cnt), print(100)}}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: []
	File table: {}
	Heap: {1=2, 2=3, 3=4}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=3}
	Count Semaphore table: {}
};
Program 2
{
	Stack: [{{wH(v1, rH(v1) * 10), {print(rH(v1)), countDown(cnt)}}, fork({{wH(v2, rH(v2) * 10), {print(rH(v2)), countDown(cnt)}}, fork({wH(v3, rH(v3) * 10), {print(rH(v3)), countDown(cnt)}})})}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: []
	File table: {}
	Heap: {1=2, 2=3, 3=4}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=3}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: []
	File table: {}
	Heap: {1=2, 2=3, 3=4}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=3}
	Count Semaphore table: {}
};
Program 2
{
	Stack: [{wH(v1, rH(v1) * 10), {print(rH(v1)), countDown(cnt)}}, fork({{wH(v2, rH(v2) * 10), {print(rH(v2)), countDown(cnt)}}, fork({wH(v3, rH(v3) * 10), {print(rH(v3)), countDown(cnt)}})})]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: []
	File table: {}
	Heap: {1=2, 2=3, 3=4}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=3}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: []
	File table: {}
	Heap: {1=2, 2=3, 3=4}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=3}
	Count Semaphore table: {}
};
Program 2
{
	Stack: [{wH(v1, rH(v1) * 10), {print(rH(v1)), countDown(cnt)}}, fork({{wH(v2, rH(v2) * 10), {print(rH(v2)), countDown(cnt)}}, fork({wH(v3, rH(v3) * 10), {print(rH(v3)), countDown(cnt)}})})]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: []
	File table: {}
	Heap: {1=2, 2=3, 3=4}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=3}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: []
	File table: {}
	Heap: {1=2, 2=3, 3=4}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=3}
	Count Semaphore table: {}
};
Program 2
{
	Stack: [wH(v1, rH(v1) * 10), {print(rH(v1)), countDown(cnt)}, fork({{wH(v2, rH(v2) * 10), {print(rH(v2)), countDown(cnt)}}, fork({wH(v3, rH(v3) * 10), {print(rH(v3)), countDown(cnt)}})})]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: []
	File table: {}
	Heap: {1=2, 2=3, 3=4}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=3}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: []
	File table: {}
	Heap: {1=2, 2=3, 3=4}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=3}
	Count Semaphore table: {}
};
Program 2
{
	Stack: [wH(v1, rH(v1) * 10), {print(rH(v1)), countDown(cnt)}, fork({{wH(v2, rH(v2) * 10), {print(rH(v2)), countDown(cnt)}}, fork({wH(v3, rH(v3) * 10), {print(rH(v3)), countDown(cnt)}})})]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: []
	File table: {}
	Heap: {1=2, 2=3, 3=4}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=3}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: []
	File table: {}
	Heap: {1=20, 2=3, 3=4}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=3}
	Count Semaphore table: {}
};
Program 2
{
	Stack: [{print(rH(v1)), countDown(cnt)}, fork({{wH(v2, rH(v2) * 10), {print(rH(v2)), countDown(cnt)}}, fork({wH(v3, rH(v3) * 10), {print(rH(v3)), countDown(cnt)}})})]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: []
	File table: {}
	Heap: {1=20, 2=3, 3=4}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=3}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: []
	File table: {}
	Heap: {1=20, 2=3, 3=4}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=3}
	Count Semaphore table: {}
};
Program 2
{
	Stack: [{print(rH(v1)), countDown(cnt)}, fork({{wH(v2, rH(v2) * 10), {print(rH(v2)), countDown(cnt)}}, fork({wH(v3, rH(v3) * 10), {print(rH(v3)), countDown(cnt)}})})]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: []
	File table: {}
	Heap: {1=20, 2=3, 3=4}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=3}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: []
	File table: {}
	Heap: {1=20, 2=3, 3=4}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=3}
	Count Semaphore table: {}
};
Program 2
{
	Stack: [print(rH(v1)), countDown(cnt), fork({{wH(v2, rH(v2) * 10), {print(rH(v2)), countDown(cnt)}}, fork({wH(v3, rH(v3) * 10), {print(rH(v3)), countDown(cnt)}})})]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: []
	File table: {}
	Heap: {1=20, 2=3, 3=4}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=3}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: []
	File table: {}
	Heap: {1=20, 2=3, 3=4}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=3}
	Count Semaphore table: {}
};
Program 2
{
	Stack: [print(rH(v1)), countDown(cnt), fork({{wH(v2, rH(v2) * 10), {print(rH(v2)), countDown(cnt)}}, fork({wH(v3, rH(v3) * 10), {print(rH(v3)), countDown(cnt)}})})]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: []
	File table: {}
	Heap: {1=20, 2=3, 3=4}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=3}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20]
	File table: {}
	Heap: {1=20, 2=3, 3=4}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=3}
	Count Semaphore table: {}
};
Program 2
{
	Stack: [countDown(cnt), fork({{wH(v2, rH(v2) * 10), {print(rH(v2)), countDown(cnt)}}, fork({wH(v3, rH(v3) * 10), {print(rH(v3)), countDown(cnt)}})})]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20]
	File table: {}
	Heap: {1=20, 2=3, 3=4}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=3}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20]
	File table: {}
	Heap: {1=20, 2=3, 3=4}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=3}
	Count Semaphore table: {}
};
Program 2
{
	Stack: [countDown(cnt), fork({{wH(v2, rH(v2) * 10), {print(rH(v2)), countDown(cnt)}}, fork({wH(v3, rH(v3) * 10), {print(rH(v3)), countDown(cnt)}})})]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20]
	File table: {}
	Heap: {1=20, 2=3, 3=4}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=3}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2]
	File table: {}
	Heap: {1=20, 2=3, 3=4}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 2
{
	Stack: [fork({{wH(v2, rH(v2) * 10), {print(rH(v2)), countDown(cnt)}}, fork({wH(v3, rH(v3) * 10), {print(rH(v3)), countDown(cnt)}})})]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2]
	File table: {}
	Heap: {1=20, 2=3, 3=4}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2]
	File table: {}
	Heap: {1=20, 2=3, 3=4}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 2
{
	Stack: [fork({{wH(v2, rH(v2) * 10), {print(rH(v2)), countDown(cnt)}}, fork({wH(v3, rH(v3) * 10), {print(rH(v3)), countDown(cnt)}})})]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2]
	File table: {}
	Heap: {1=20, 2=3, 3=4}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2]
	File table: {}
	Heap: {1=20, 2=3, 3=4}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 2
{
	Stack: []
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2]
	File table: {}
	Heap: {1=20, 2=3, 3=4}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 3
{
	Stack: [{{wH(v2, rH(v2) * 10), {print(rH(v2)), countDown(cnt)}}, fork({wH(v3, rH(v3) * 10), {print(rH(v3)), countDown(cnt)}})}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2]
	File table: {}
	Heap: {1=20, 2=3, 3=4}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2]
	File table: {}
	Heap: {1=20, 2=3, 3=4}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 3
{
	Stack: [{{wH(v2, rH(v2) * 10), {print(rH(v2)), countDown(cnt)}}, fork({wH(v3, rH(v3) * 10), {print(rH(v3)), countDown(cnt)}})}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2]
	File table: {}
	Heap: {1=20, 2=3, 3=4}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2]
	File table: {}
	Heap: {1=20, 2=3, 3=4}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 3
{
	Stack: [{wH(v2, rH(v2) * 10), {print(rH(v2)), countDown(cnt)}}, fork({wH(v3, rH(v3) * 10), {print(rH(v3)), countDown(cnt)}})]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2]
	File table: {}
	Heap: {1=20, 2=3, 3=4}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2]
	File table: {}
	Heap: {1=20, 2=3, 3=4}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 3
{
	Stack: [{wH(v2, rH(v2) * 10), {print(rH(v2)), countDown(cnt)}}, fork({wH(v3, rH(v3) * 10), {print(rH(v3)), countDown(cnt)}})]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2]
	File table: {}
	Heap: {1=20, 2=3, 3=4}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2]
	File table: {}
	Heap: {1=20, 2=3, 3=4}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 3
{
	Stack: [wH(v2, rH(v2) * 10), {print(rH(v2)), countDown(cnt)}, fork({wH(v3, rH(v3) * 10), {print(rH(v3)), countDown(cnt)}})]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2]
	File table: {}
	Heap: {1=20, 2=3, 3=4}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2]
	File table: {}
	Heap: {1=20, 2=3, 3=4}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 3
{
	Stack: [wH(v2, rH(v2) * 10), {print(rH(v2)), countDown(cnt)}, fork({wH(v3, rH(v3) * 10), {print(rH(v3)), countDown(cnt)}})]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2]
	File table: {}
	Heap: {1=20, 2=3, 3=4}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2]
	File table: {}
	Heap: {1=20, 2=30, 3=4}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 3
{
	Stack: [{print(rH(v2)), countDown(cnt)}, fork({wH(v3, rH(v3) * 10), {print(rH(v3)), countDown(cnt)}})]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2]
	File table: {}
	Heap: {1=20, 2=30, 3=4}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2]
	File table: {}
	Heap: {1=20, 2=30, 3=4}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 3
{
	Stack: [{print(rH(v2)), countDown(cnt)}, fork({wH(v3, rH(v3) * 10), {print(rH(v3)), countDown(cnt)}})]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2]
	File table: {}
	Heap: {1=20, 2=30, 3=4}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2]
	File table: {}
	Heap: {1=20, 2=30, 3=4}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 3
{
	Stack: [print(rH(v2)), countDown(cnt), fork({wH(v3, rH(v3) * 10), {print(rH(v3)), countDown(cnt)}})]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2]
	File table: {}
	Heap: {1=20, 2=30, 3=4}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2]
	File table: {}
	Heap: {1=20, 2=30, 3=4}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 3
{
	Stack: [print(rH(v2)), countDown(cnt), fork({wH(v3, rH(v3) * 10), {print(rH(v3)), countDown(cnt)}})]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2]
	File table: {}
	Heap: {1=20, 2=30, 3=4}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30]
	File table: {}
	Heap: {1=20, 2=30, 3=4}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 3
{
	Stack: [countDown(cnt), fork({wH(v3, rH(v3) * 10), {print(rH(v3)), countDown(cnt)}})]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30]
	File table: {}
	Heap: {1=20, 2=30, 3=4}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30]
	File table: {}
	Heap: {1=20, 2=30, 3=4}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 3
{
	Stack: [countDown(cnt), fork({wH(v3, rH(v3) * 10), {print(rH(v3)), countDown(cnt)}})]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30]
	File table: {}
	Heap: {1=20, 2=30, 3=4}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30, 3]
	File table: {}
	Heap: {1=20, 2=30, 3=4}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=1}
	Count Semaphore table: {}
};
Program 3
{
	Stack: [fork({wH(v3, rH(v3) * 10), {print(rH(v3)), countDown(cnt)}})]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30, 3]
	File table: {}
	Heap: {1=20, 2=30, 3=4}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=1}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30, 3]
	File table: {}
	Heap: {1=20, 2=30, 3=4}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=1}
	Count Semaphore table: {}
};
Program 3
{
	Stack: [fork({wH(v3, rH(v3) * 10), {print(rH(v3)), countDown(cnt)}})]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30, 3]
	File table: {}
	Heap: {1=20, 2=30, 3=4}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=1}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30, 3]
	File table: {}
	Heap: {1=20, 2=30, 3=4}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=1}
	Count Semaphore table: {}
};
Program 3
{
	Stack: []
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30, 3]
	File table: {}
	Heap: {1=20, 2=30, 3=4}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=1}
	Count Semaphore table: {}
};
Program 4
{
	Stack: [{wH(v3, rH(v3) * 10), {print(rH(v3)), countDown(cnt)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30, 3]
	File table: {}
	Heap: {1=20, 2=30, 3=4}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=1}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30, 3]
	File table: {}
	Heap: {1=20, 2=30, 3=4}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=1}
	Count Semaphore table: {}
};
Program 4
{
	Stack: [{wH(v3, rH(v3) * 10), {print(rH(v3)), countDown(cnt)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30, 3]
	File table: {}
	Heap: {1=20, 2=30, 3=4}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=1}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30, 3]
	File table: {}
	Heap: {1=20, 2=30, 3=4}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=1}
	Count Semaphore table: {}
};
Program 4
{
	Stack: [wH(v3, rH(v3) * 10), {print(rH(v3)), countDown(cnt)}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30, 3]
	File table: {}
	Heap: {1=20, 2=30, 3=4}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=1}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30, 3]
	File table: {}
	Heap: {1=20, 2=30, 3=4}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=1}
	Count Semaphore table: {}
};
Program 4
{
	Stack: [wH(v3, rH(v3) * 10), {print(rH(v3)), countDown(cnt)}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30, 3]
	File table: {}
	Heap: {1=20, 2=30, 3=4}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=1}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30, 3]
	File table: {}
	Heap: {1=20, 2=30, 3=40}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=1}
	Count Semaphore table: {}
};
Program 4
{
	Stack: [{print(rH(v3)), countDown(cnt)}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30, 3]
	File table: {}
	Heap: {1=20, 2=30, 3=40}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=1}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30, 3]
	File table: {}
	Heap: {1=20, 2=30, 3=40}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=1}
	Count Semaphore table: {}
};
Program 4
{
	Stack: [{print(rH(v3)), countDown(cnt)}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30, 3]
	File table: {}
	Heap: {1=20, 2=30, 3=40}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=1}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30, 3]
	File table: {}
	Heap: {1=20, 2=30, 3=40}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=1}
	Count Semaphore table: {}
};
Program 4
{
	Stack: [print(rH(v3)), countDown(cnt)]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30, 3]
	File table: {}
	Heap: {1=20, 2=30, 3=40}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=1}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30, 3]
	File table: {}
	Heap: {1=20, 2=30, 3=40}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=1}
	Count Semaphore table: {}
};
Program 4
{
	Stack: [print(rH(v3)), countDown(cnt)]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30, 3]
	File table: {}
	Heap: {1=20, 2=30, 3=40}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=1}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30, 3, 40]
	File table: {}
	Heap: {1=20, 2=30, 3=40}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=1}
	Count Semaphore table: {}
};
Program 4
{
	Stack: [countDown(cnt)]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30, 3, 40]
	File table: {}
	Heap: {1=20, 2=30, 3=40}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=1}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30, 3, 40]
	File table: {}
	Heap: {1=20, 2=30, 3=40}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=1}
	Count Semaphore table: {}
};
Program 4
{
	Stack: [countDown(cnt)]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30, 3, 40]
	File table: {}
	Heap: {1=20, 2=30, 3=40}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=1}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30, 3, 40, 4]
	File table: {}
	Heap: {1=20, 2=30, 3=40}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=0}
	Count Semaphore table: {}
};
Program 4
{
	Stack: []
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30, 3, 40, 4]
	File table: {}
	Heap: {1=20, 2=30, 3=40}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=0}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30, 3, 40, 4]
	File table: {}
	Heap: {1=20, 2=30, 3=40}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=0}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [{print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30, 3, 40, 4]
	File table: {}
	Heap: {1=20, 2=30, 3=40}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=0}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [{print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30, 3, 40, 4]
	File table: {}
	Heap: {1=20, 2=30, 3=40}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=0}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [print(100), {countDown(cnt), print(100)}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30, 3, 40, 4]
	File table: {}
	Heap: {1=20, 2=30, 3=40}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=0}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [print(100), {countDown(cnt), print(100)}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30, 3, 40, 4]
	File table: {}
	Heap: {1=20, 2=30, 3=40}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=0}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [{countDown(cnt), print(100)}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30, 3, 40, 4, 100]
	File table: {}
	Heap: {1=20, 2=30, 3=40}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=0}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [{countDown(cnt), print(100)}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30, 3, 40, 4, 100]
	File table: {}
	Heap: {1=20, 2=30, 3=40}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=0}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [countDown(cnt), print(100)]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30, 3, 40, 4, 100]
	File table: {}
	Heap: {1=20, 2=30, 3=40}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=0}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [countDown(cnt), print(100)]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30, 3, 40, 4, 100]
	File table: {}
	Heap: {1=20, 2=30, 3=40}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=0}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [print(100)]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30, 3, 40, 4, 100, 1]
	File table: {}
	Heap: {1=20, 2=30, 3=40}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=0}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [print(100)]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30, 3, 40, 4, 100, 1]
	File table: {}
	Heap: {1=20, 2=30, 3=40}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=0}
	Count Semaphore table: {}
};
Program 1
{
	Stack: []
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30, 3, 40, 4, 100, 1, 100]
	File table: {}
	Heap: {1=20, 2=30, 3=40}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=0}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [{Ref(int) v1, {Ref(int) v2, {Ref(int) v3, {int cnt, {new(v1,2), {new(v2,3), {new(v3,4), {newLatch(cnt, rH(v2)), {fork({{wH(v1, rH(v1) * 10), {print(rH(v1)), countDown(cnt)}}, fork({{wH(v2, rH(v2) * 10), {print(rH(v2)), countDown(cnt)}}, fork({wH(v3, rH(v3) * 10), {print(rH(v3)), countDown(cnt)}})})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}}}}}}}}]
	Symbol Table: {}
	Output: []
	File table: {}
	Heap: {}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [Ref(int) v1, {Ref(int) v2, {Ref(int) v3, {int cnt, {new(v1,2), {new(v2,3), {new(v3,4), {newLatch(cnt, rH(v2)), {fork({{wH(v1, rH(v1) * 10), {print(rH(v1)), countDown(cnt)}}, fork({{wH(v2, rH(v2) * 10), {print(rH(v2)), countDown(cnt)}}, fork({wH(v3, rH(v3) * 10), {print(rH(v3)), countDown(cnt)}})})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}}}}}}}]
	Symbol Table: {}
	Output: []
	File table: {}
	Heap: {}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [Ref(int) v1, {Ref(int) v2, {Ref(int) v3, {int cnt, {new(v1,2), {new(v2,3), {new(v3,4), {newLatch(cnt, rH(v2)), {fork({{wH(v1, rH(v1) * 10), {print(rH(v1)), countDown(cnt)}}, fork({{wH(v2, rH(v2) * 10), {print(rH(v2)), countDown(cnt)}}, fork({wH(v3, rH(v3) * 10), {print(rH(v3)), countDown(cnt)}})})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}}}}}}}]
	Symbol Table: {}
	Output: []
	File table: {}
	Heap: {}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [{Ref(int) v2, {Ref(int) v3, {int cnt, {new(v1,2), {new(v2,3), {new(v3,4), {newLatch(cnt, rH(v2)), {fork({{wH(v1, rH(v1) * 10), {print(rH(v1)), countDown(cnt)}}, fork({{wH(v2, rH(v2) * 10), {print(rH(v2)), countDown(cnt)}}, fork({wH(v3, rH(v3) * 10), {print(rH(v3)), countDown(cnt)}})})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}}}}}}}]
	Symbol Table: {v1=RefValue(0, int)}
	Output: []
	File table: {}
	Heap: {}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [{Ref(int) v2, {Ref(int) v3, {int cnt, {new(v1,2), {new(v2,3), {new(v3,4), {newLatch(cnt, rH(v2)), {fork({{wH(v1, rH(v1) * 10), {print(rH(v1)), countDown(cnt)}}, fork({{wH(v2, rH(v2) * 10), {print(rH(v2)), countDown(cnt)}}, fork({wH(v3, rH(v3) * 10), {print(rH(v3)), countDown(cnt)}})})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}}}}}}}]
	Symbol Table: {v1=RefValue(0, int)}
	Output: []
	File table: {}
	Heap: {}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [Ref(int) v2, {Ref(int) v3, {int cnt, {new(v1,2), {new(v2,3), {new(v3,4), {newLatch(cnt, rH(v2)), {fork({{wH(v1, rH(v1) * 10), {print(rH(v1)), countDown(cnt)}}, fork({{wH(v2, rH(v2) * 10), {print(rH(v2)), countDown(cnt)}}, fork({wH(v3, rH(v3) * 10), {print(rH(v3)), countDown(cnt)}})})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}}}}}}]
	Symbol Table: {v1=RefValue(0, int)}
	Output: []
	File table: {}
	Heap: {}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [Ref(int) v2, {Ref(int) v3, {int cnt, {new(v1,2), {new(v2,3), {new(v3,4), {newLatch(cnt, rH(v2)), {fork({{wH(v1, rH(v1) * 10), {print(rH(v1)), countDown(cnt)}}, fork({{wH(v2, rH(v2) * 10), {print(rH(v2)), countDown(cnt)}}, fork({wH(v3, rH(v3) * 10), {print(rH(v3)), countDown(cnt)}})})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}}}}}}]
	Symbol Table: {v1=RefValue(0, int)}
	Output: []
	File table: {}
	Heap: {}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [{Ref(int) v3, {int cnt, {new(v1,2), {new(v2,3), {new(v3,4), {newLatch(cnt, rH(v2)), {fork({{wH(v1, rH(v1) * 10), {print(rH(v1)), countDown(cnt)}}, fork({{wH(v2, rH(v2) * 10), {print(rH(v2)), countDown(cnt)}}, fork({wH(v3, rH(v3) * 10), {print(rH(v3)), countDown(cnt)}})})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}}}}}}]
	Symbol Table: {v1=RefValue(0, int), v2=RefValue(0, int)}
	Output: []
	File table: {}
	Heap: {}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [{Ref(int) v3, {int cnt, {new(v1,2), {new(v2,3), {new(v3,4), {newLatch(cnt, rH(v2)), {fork({{wH(v1, rH(v1) * 10), {print(rH(v1)), countDown(cnt)}}, fork({{wH(v2, rH(v2) * 10), {print(rH(v2)), countDown(cnt)}}, fork({wH(v3, rH(v3) * 10), {print(rH(v3)), countDown(cnt)}})})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}}}}}}]
	Symbol Table: {v1=RefValue(0, int), v2=RefValue(0, int)}
	Output: []
	File table: {}
	Heap: {}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [Ref(int) v3, {int cnt, {new(v1,2), {new(v2,3), {new(v3,4), {newLatch(cnt, rH(v2)), {fork({{wH(v1, rH(v1) * 10), {print(rH(v1)), countDown(cnt)}}, fork({{wH(v2, rH(v2) * 10), {print(rH(v2)), countDown(cnt)}}, fork({wH(v3, rH(v3) * 10), {print(rH(v3)), countDown(cnt)}})})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}}}}}]
	Symbol Table: {v1=RefValue(0, int), v2=RefValue(0, int)}
	Output: []
	File table: {}
	Heap: {}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [Ref(int) v3, {int cnt, {new(v1,2), {new(v2,3), {new(v3,4), {newLatch(cnt, rH(v2)), {fork({{wH(v1, rH(v1) * 10), {print(rH(v1)), countDown(cnt)}}, fork({{wH(v2, rH(v2) * 10), {print(rH(v2)), countDown(cnt)}}, fork({wH(v3, rH(v3) * 10), {print(rH(v3)), countDown(cnt)}})})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}}}}}]
	Symbol Table: {v1=RefValue(0, int), v2=RefValue(0, int)}
	Output: []
	File table: {}
	Heap: {}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [{int cnt, {new(v1,2), {new(v2,3), {new(v3,4), {newLatch(cnt, rH(v2)), {fork({{wH(v1, rH(v1) * 10), {print(rH(v1)), countDown(cnt)}}, fork({{wH(v2, rH(v2) * 10), {print(rH(v2)), countDown(cnt)}}, fork({wH(v3, rH(v3) * 10), {print(rH(v3)), countDown(cnt)}})})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}}}}}]
	Symbol Table: {v1=RefValue(0, int), v2=RefValue(0, int), v3=RefValue(0, int)}
	Output: []
	File table: {}
	Heap: {}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [{int cnt, {new(v1,2), {new(v2,3), {new(v3,4), {newLatch(cnt, rH(v2)), {fork({{wH(v1, rH(v1) * 10), {print(rH(v1)), countDown(cnt)}}, fork({{wH(v2, rH(v2) * 10), {print(rH(v2)), countDown(cnt)}}, fork({wH(v3, rH(v3) * 10), {print(rH(v3)), countDown(cnt)}})})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}}}}}]
	Symbol Table: {v1=RefValue(0, int), v2=RefValue(0, int), v3=RefValue(0, int)}
	Output: []
	File table: {}
	Heap: {}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [int cnt, {new(v1,2), {new(v2,3), {new(v3,4), {newLatch(cnt, rH(v2)), {fork({{wH(v1, rH(v1) * 10), {print(rH(v1)), countDown(cnt)}}, fork({{wH(v2, rH(v2) * 10), {print(rH(v2)), countDown(cnt)}}, fork({wH(v3, rH(v3) * 10), {print(rH(v3)), countDown(cnt)}})})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}}}}]
	Symbol Table: {v1=RefValue(0, int), v2=RefValue(0, int), v3=RefValue(0, int)}
	Output: []
	File table: {}
	Heap: {}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [int cnt, {new(v1,2), {new(v2,3), {new(v3,4), {newLatch(cnt, rH(v2)), {fork({{wH(v1, rH(v1) * 10), {print(rH(v1)), countDown(cnt)}}, fork({{wH(v2, rH(v2) * 10), {print(rH(v2)), countDown(cnt)}}, fork({wH(v3, rH(v3) * 10), {print(rH(v3)), countDown(cnt)}})})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}}}}]
	Symbol Table: {v1=RefValue(0, int), v2=RefValue(0, int), v3=RefValue(0, int)}
	Output: []
	File table: {}
	Heap: {}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [{new(v1,2), {new(v2,3), {new(v3,4), {newLatch(cnt, rH(v2)), {fork({{wH(v1, rH(v1) * 10), {print(rH(v1)), countDown(cnt)}}, fork({{wH(v2, rH(v2) * 10), {print(rH(v2)), countDown(cnt)}}, fork({wH(v3, rH(v3) * 10), {print(rH(v3)), countDown(cnt)}})})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}}}}]
	Symbol Table: {cnt=0, v1=RefValue(0, int), v2=RefValue(0, int), v3=RefValue(0, int)}
	Output: []
	File table: {}
	Heap: {}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [{new(v1,2), {new(v2,3), {new(v3,4), {newLatch(cnt, rH(v2)), {fork({{wH(v1, rH(v1) * 10), {print(rH(v1)), countDown(cnt)}}, fork({{wH(v2, rH(v2) * 10), {print(rH(v2)), countDown(cnt)}}, fork({wH(v3, rH(v3) * 10), {print(rH(v3)), countDown(cnt)}})})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}}}}]
	Symbol Table: {cnt=0, v1=RefValue(0, int), v2=RefValue(0, int), v3=RefValue(0, int)}
	Output: []
	File table: {}
	Heap: {}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [new(v1,2), {new(v2,3), {new(v3,4), {newLatch(cnt, rH(v2)), {fork({{wH(v1, rH(v1) * 10), {print(rH(v1)), countDown(cnt)}}, fork({{wH(v2, rH(v2) * 10), {print(rH(v2)), countDown(cnt)}}, fork({wH(v3, rH(v3) * 10), {print(rH(v3)), countDown(cnt)}})})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}}}]
	Symbol Table: {cnt=0, v1=RefValue(0, int), v2=RefValue(0, int), v3=RefValue(0, int)}
	Output: []
	File table: {}
	Heap: {}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [new(v1,2), {new(v2,3), {new(v3,4), {newLatch(cnt, rH(v2)), {fork({{wH(v1, rH(v1) * 10), {print(rH(v1)), countDown(cnt)}}, fork({{wH(v2, rH(v2) * 10), {print(rH(v2)), countDown(cnt)}}, fork({wH(v3, rH(v3) * 10), {print(rH(v3)), countDown(cnt)}})})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}}}]
	Symbol Table: {cnt=0, v1=RefValue(0, int), v2=RefValue(0, int), v3=RefValue(0, int)}
	Output: []
	File table: {}
	Heap: {}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [{new(v2,3), {new(v3,4), {newLatch(cnt, rH(v2)), {fork({{wH(v1, rH(v1) * 10), {print(rH(v1)), countDown(cnt)}}, fork({{wH(v2, rH(v2) * 10), {print(rH(v2)), countDown(cnt)}}, fork({wH(v3, rH(v3) * 10), {print(rH(v3)), countDown(cnt)}})})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}}}]
	Symbol Table: {cnt=0, v1=RefValue(1, int), v2=RefValue(0, int), v3=RefValue(0, int)}
	Output: []
	File table: {}
	Heap: {1=2}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [{new(v2,3), {new(v3,4), {newLatch(cnt, rH(v2)), {fork({{wH(v1, rH(v1) * 10), {print(rH(v1)), countDown(cnt)}}, fork({{wH(v2, rH(v2) * 10), {print(rH(v2)), countDown(cnt)}}, fork({wH(v3, rH(v3) * 10), {print(rH(v3)), countDown(cnt)}})})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}}}]
	Symbol Table: {cnt=0, v1=RefValue(1, int), v2=RefValue(0, int), v3=RefValue(0, int)}
	Output: []
	File table: {}
	Heap: {1=2}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [new(v2,3), {new(v3,4), {newLatch(cnt, rH(v2)), {fork({{wH(v1, rH(v1) * 10), {print(rH(v1)), countDown(cnt)}}, fork({{wH(v2, rH(v2) * 10), {print(rH(v2)), countDown(cnt)}}, fork({wH(v3, rH(v3) * 10), {print(rH(v3)), countDown(cnt)}})})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}}]
	Symbol Table: {cnt=0, v1=RefValue(1, int), v2=RefValue(0, int), v3=RefValue(0, int)}
	Output: []
	File table: {}
	Heap: {1=2}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [new(v2,3), {new(v3,4), {newLatch(cnt, rH(v2)), {fork({{wH(v1, rH(v1) * 10), {print(rH(v1)), countDown(cnt)}}, fork({{wH(v2, rH(v2) * 10), {print(rH(v2)), countDown(cnt)}}, fork({wH(v3, rH(v3) * 10), {print(rH(v3)), countDown(cnt)}})})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}}]
	Symbol Table: {cnt=0, v1=RefValue(1, int), v2=RefValue(0, int), v3=RefValue(0, int)}
	Output: []
	File table: {}
	Heap: {1=2}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [{new(v3,4), {newLatch(cnt, rH(v2)), {fork({{wH(v1, rH(v1) * 10), {print(rH(v1)), countDown(cnt)}}, fork({{wH(v2, rH(v2) * 10), {print(rH(v2)), countDown(cnt)}}, fork({wH(v3, rH(v3) * 10), {print(rH(v3)), countDown(cnt)}})})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}}]
	Symbol Table: {cnt=0, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(0, int)}
	Output: []
	File table: {}
	Heap: {1=2, 2=3}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [{new(v3,4), {newLatch(cnt, rH(v2)), {fork({{wH(v1, rH(v1) * 10), {print(rH(v1)), countDown(cnt)}}, fork({{wH(v2, rH(v2) * 10), {print(rH(v2)), countDown(cnt)}}, fork({wH(v3, rH(v3) * 10), {print(rH(v3)), countDown(cnt)}})})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}}]
	Symbol Table: {cnt=0, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(0, int)}
	Output: []
	File table: {}
	Heap: {1=2, 2=3}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [new(v3,4), {newLatch(cnt, rH(v2)), {fork({{wH(v1, rH(v1) * 10), {print(rH(v1)), countDown(cnt)}}, fork({{wH(v2, rH(v2) * 10), {print(rH(v2)), countDown(cnt)}}, fork({wH(v3, rH(v3) * 10), {print(rH(v3)), countDown(cnt)}})})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}]
	Symbol Table: {cnt=0, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(0, int)}
	Output: []
	File table: {}
	Heap: {1=2, 2=3}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [new(v3,4), {newLatch(cnt, rH(v2)), {fork({{wH(v1, rH(v1) * 10), {print(rH(v1)), countDown(cnt)}}, fork({{wH(v2, rH(v2) * 10), {print(rH(v2)), countDown(cnt)}}, fork({wH(v3, rH(v3) * 10), {print(rH(v3)), countDown(cnt)}})})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}]
	Symbol Table: {cnt=0, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(0, int)}
	Output: []
	File table: {}
	Heap: {1=2, 2=3}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [{newLatch(cnt, rH(v2)), {fork({{wH(v1, rH(v1) * 10), {print(rH(v1)), countDown(cnt)}}, fork({{wH(v2, rH(v2) * 10), {print(rH(v2)), countDown(cnt)}}, fork({wH(v3, rH(v3) * 10), {print(rH(v3)), countDown(cnt)}})})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}]
	Symbol Table: {cnt=0, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: []
	File table: {}
	Heap: {1=2, 2=3, 3=4}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [{newLatch(cnt, rH(v2)), {fork({{wH(v1, rH(v1) * 10), {print(rH(v1)), countDown(cnt)}}, fork({{wH(v2, rH(v2) * 10), {print(rH(v2)), countDown(cnt)}}, fork({wH(v3, rH(v3) * 10), {print(rH(v3)), countDown(cnt)}})})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}]
	Symbol Table: {cnt=0, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: []
	File table: {}
	Heap: {1=2, 2=3, 3=4}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [newLatch(cnt, rH(v2)), {fork({{wH(v1, rH(v1) * 10), {print(rH(v1)), countDown(cnt)}}, fork({{wH(v2, rH(v2) * 10), {print(rH(v2)), countDown(cnt)}}, fork({wH(v3, rH(v3) * 10), {print(rH(v3)), countDown(cnt)}})})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}]
	Symbol Table: {cnt=0, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: []
	File table: {}
	Heap: {1=2, 2=3, 3=4}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [newLatch(cnt, rH(v2)), {fork({{wH(v1, rH(v1) * 10), {print(rH(v1)), countDown(cnt)}}, fork({{wH(v2, rH(v2) * 10), {print(rH(v2)), countDown(cnt)}}, fork({wH(v3, rH(v3) * 10), {print(rH(v3)), countDown(cnt)}})})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}]
	Symbol Table: {cnt=0, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: []
	File table: {}
	Heap: {1=2, 2=3, 3=4}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [{fork({{wH(v1, rH(v1) * 10), {print(rH(v1)), countDown(cnt)}}, fork({{wH(v2, rH(v2) * 10), {print(rH(v2)), countDown(cnt)}}, fork({wH(v3, rH(v3) * 10), {print(rH(v3)), countDown(cnt)}})})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: []
	File table: {}
	Heap: {1=2, 2=3, 3=4}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=3}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [{fork({{wH(v1, rH(v1) * 10), {print(rH(v1)), countDown(cnt)}}, fork({{wH(v2, rH(v2) * 10), {print(rH(v2)), countDown(cnt)}}, fork({wH(v3, rH(v3) * 10), {print(rH(v3)), countDown(cnt)}})})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: []
	File table: {}
	Heap: {1=2, 2=3, 3=4}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=3}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [fork({{wH(v1, rH(v1) * 10), {print(rH(v1)), countDown(cnt)}}, fork({{wH(v2, rH(v2) * 10), {print(rH(v2)), countDown(cnt)}}, fork({wH(v3, rH(v3) * 10), {print(rH(v3)), countDown(cnt)}})})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: []
	File table: {}
	Heap: {1=2, 2=3, 3=4}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=3}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [fork({{wH(v1, rH(v1) * 10), {print(rH(v1)), countDown(cnt)}}, fork({{wH(v2, rH(v2) * 10), {print(rH(v2)), countDown(cnt)}}, fork({wH(v3, rH(v3) * 10), {print(rH(v3)), countDown(cnt)}})})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: []
	File table: {}
	Heap: {1=2, 2=3, 3=4}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=3}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [{await(cnt), {print(100), {countDown(cnt), print(100)}}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: []
	File table: {}
	Heap: {1=2, 2=3, 3=4}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=3}
	Count Semaphore table: {}
};
Program 2
{
	Stack: [{{wH(v1, rH(v1) * 10), {print(rH(v1)), countDown(cnt)}}, fork({{wH(v2, rH(v2) * 10), {print(rH(v2)), countDown(cnt)}}, fork({wH(v3, rH(v3) * 10), {print(rH(v3)), countDown(cnt)}})})}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: []
	File table: {}
	Heap: {1=2, 2=3, 3=4}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=3}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [{await(cnt), {print(100), {countDown(cnt), print(100)}}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: []
	File table: {}
	Heap: {1=2, 2=3, 3=4}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=3}
	Count Semaphore table: {}
};
Program 2
{
	Stack: [{{wH(v1, rH(v1) * 10), {print(rH(v1)), countDown(cnt)}}, fork({{wH(v2, rH(v2) * 10), {print(rH(v2)), countDown(cnt)}}, fork({wH(v3, rH(v3) * 10), {print(rH(v3)), countDown(cnt)}})})}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: []
	File table: {}
	Heap: {1=2, 2=3, 3=4}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=3}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: []
	File table: {}
	Heap: {1=2, 2=3, 3=4}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=3}
	Count Semaphore table: {}
};
Program 2
{
	Stack: [{wH(v1, rH(v1) * 10), {print(rH(v1)), countDown(cnt)}}, fork({{wH(v2, rH(v2) * 10), {print(rH(v2)), countDown(cnt)}}, fork({wH(v3, rH(v3) * 10), {print(rH(v3)), countDown(cnt)}})})]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: []
	File table: {}
	Heap: {1=2, 2=3, 3=4}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=3}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: []
	File table: {}
	Heap: {1=2, 2=3, 3=4}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=3}
	Count Semaphore table: {}
};
Program 2
{
	Stack: [{wH(v1, rH(v1) * 10), {print(rH(v1)), countDown(cnt)}}, fork({{wH(v2, rH(v2) * 10), {print(rH(v2)), countDown(cnt)}}, fork({wH(v3, rH(v3) * 10), {print(rH(v3)), countDown(cnt)}})})]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: []
	File table: {}
	Heap: {1=2, 2=3, 3=4}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=3}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: []
	File table: {}
	Heap: {1=2, 2=3, 3=4}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=3}
	Count Semaphore table: {}
};
Program 2
{
	Stack: [wH(v1, rH(v1) * 10), {print(rH(v1)), countDown(cnt)}, fork({{wH(v2, rH(v2) * 10), {print(rH(v2)), countDown(cnt)}}, fork({wH(v3, rH(v3) * 10), {print(rH(v3)), countDown(cnt)}})})]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: []
	File table: {}
	Heap: {1=2, 2=3, 3=4}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=3}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: []
	File table: {}
	Heap: {1=2, 2=3, 3=4}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=3}
	Count Semaphore table: {}
};
Program 2
{
	Stack: [wH(v1, rH(v1) * 10), {print(rH(v1)), countDown(cnt)}, fork({{wH(v2, rH(v2) * 10), {print(rH(v2)), countDown(cnt)}}, fork({wH(v3, rH(v3) * 10), {print(rH(v3)), countDown(cnt)}})})]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: []
	File table: {}
	Heap: {1=2, 2=3, 3=4}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=3}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: []
	File table: {}
	Heap: {1=20, 2=3, 3=4}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=3}
	Count Semaphore table: {}
};
Program 2
{
	Stack: [{print(rH(v1)), countDown(cnt)}, fork({{wH(v2, rH(v2) * 10), {print(rH(v2)), countDown(cnt)}}, fork({wH(v3, rH(v3) * 10), {print(rH(v3)), countDown(cnt)}})})]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: []
	File table: {}
	Heap: {1=20, 2=3, 3=4}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=3}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: []
	File table: {}
	Heap: {1=20, 2=3, 3=4}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=3}
	Count Semaphore table: {}
};
Program 2
{
	Stack: [{print(rH(v1)), countDown(cnt)}, fork({{wH(v2, rH(v2) * 10), {print(rH(v2)), countDown(cnt)}}, fork({wH(v3, rH(v3) * 10), {print(rH(v3)), countDown(cnt)}})})]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: []
	File table: {}
	Heap: {1=20, 2=3, 3=4}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=3}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: []
	File table: {}
	Heap: {1=20, 2=3, 3=4}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=3}
	Count Semaphore table: {}
};
Program 2
{
	Stack: [print(rH(v1)), countDown(cnt), fork({{wH(v2, rH(v2) * 10), {print(rH(v2)), countDown(cnt)}}, fork({wH(v3, rH(v3) * 10), {print(rH(v3)), countDown(cnt)}})})]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: []
	File table: {}
	Heap: {1=20, 2=3, 3=4}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=3}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: []
	File table: {}
	Heap: {1=20, 2=3, 3=4}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=3}
	Count Semaphore table: {}
};
Program 2
{
	Stack: [print(rH(v1)), countDown(cnt), fork({{wH(v2, rH(v2) * 10), {print(rH(v2)), countDown(cnt)}}, fork({wH(v3, rH(v3) * 10), {print(rH(v3)), countDown(cnt)}})})]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: []
	File table: {}
	Heap: {1=20, 2=3, 3=4}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=3}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20]
	File table: {}
	Heap: {1=20, 2=3, 3=4}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=3}
	Count Semaphore table: {}
};
Program 2
{
	Stack: [countDown(cnt), fork({{wH(v2, rH(v2) * 10), {print(rH(v2)), countDown(cnt)}}, fork({wH(v3, rH(v3) * 10), {print(rH(v3)), countDown(cnt)}})})]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20]
	File table: {}
	Heap: {1=20, 2=3, 3=4}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=3}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20]
	File table: {}
	Heap: {1=20, 2=3, 3=4}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=3}
	Count Semaphore table: {}
};
Program 2
{
	Stack: [countDown(cnt), fork({{wH(v2, rH(v2) * 10), {print(rH(v2)), countDown(cnt)}}, fork({wH(v3, rH(v3) * 10), {print(rH(v3)), countDown(cnt)}})})]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20]
	File table: {}
	Heap: {1=20, 2=3, 3=4}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=3}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2]
	File table: {}
	Heap: {1=20, 2=3, 3=4}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 2
{
	Stack: [fork({{wH(v2, rH(v2) * 10), {print(rH(v2)), countDown(cnt)}}, fork({wH(v3, rH(v3) * 10), {print(rH(v3)), countDown(cnt)}})})]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2]
	File table: {}
	Heap: {1=20, 2=3, 3=4}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2]
	File table: {}
	Heap: {1=20, 2=3, 3=4}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 2
{
	Stack: [fork({{wH(v2, rH(v2) * 10), {print(rH(v2)), countDown(cnt)}}, fork({wH(v3, rH(v3) * 10), {print(rH(v3)), countDown(cnt)}})})]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2]
	File table: {}
	Heap: {1=20, 2=3, 3=4}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2]
	File table: {}
	Heap: {1=20, 2=3, 3=4}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 2
{
	Stack: []
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2]
	File table: {}
	Heap: {1=20, 2=3, 3=4}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 3
{
	Stack: [{{wH(v2, rH(v2) * 10), {print(rH(v2)), countDown(cnt)}}, fork({wH(v3, rH(v3) * 10), {print(rH(v3)), countDown(cnt)}})}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2]
	File table: {}
	Heap: {1=20, 2=3, 3=4}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2]
	File table: {}
	Heap: {1=20, 2=3, 3=4}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 3
{
	Stack: [{{wH(v2, rH(v2) * 10), {print(rH(v2)), countDown(cnt)}}, fork({wH(v3, rH(v3) * 10), {print(rH(v3)), countDown(cnt)}})}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2]
	File table: {}
	Heap: {1=20, 2=3, 3=4}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2]
	File table: {}
	Heap: {1=20, 2=3, 3=4}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 3
{
	Stack: [{wH(v2, rH(v2) * 10), {print(rH(v2)), countDown(cnt)}}, fork({wH(v3, rH(v3) * 10), {print(rH(v3)), countDown(cnt)}})]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2]
	File table: {}
	Heap: {1=20, 2=3, 3=4}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2]
	File table: {}
	Heap: {1=20, 2=3, 3=4}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 3
{
	Stack: [{wH(v2, rH(v2) * 10), {print(rH(v2)), countDown(cnt)}}, fork({wH(v3, rH(v3) * 10), {print(rH(v3)), countDown(cnt)}})]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2]
	File table: {}
	Heap: {1=20, 2=3, 3=4}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2]
	File table: {}
	Heap: {1=20, 2=3, 3=4}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 3
{
	Stack: [wH(v2, rH(v2) * 10), {print(rH(v2)), countDown(cnt)}, fork({wH(v3, rH(v3) * 10), {print(rH(v3)), countDown(cnt)}})]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2]
	File table: {}
	Heap: {1=20, 2=3, 3=4}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2]
	File table: {}
	Heap: {1=20, 2=3, 3=4}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 3
{
	Stack: [wH(v2, rH(v2) * 10), {print(rH(v2)), countDown(cnt)}, fork({wH(v3, rH(v3) * 10), {print(rH(v3)), countDown(cnt)}})]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2]
	File table: {}
	Heap: {1=20, 2=3, 3=4}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2]
	File table: {}
	Heap: {1=20, 2=30, 3=4}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 3
{
	Stack: [{print(rH(v2)), countDown(cnt)}, fork({wH(v3, rH(v3) * 10), {print(rH(v3)), countDown(cnt)}})]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2]
	File table: {}
	Heap: {1=20, 2=30, 3=4}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2]
	File table: {}
	Heap: {1=20, 2=30, 3=4}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 3
{
	Stack: [{print(rH(v2)), countDown(cnt)}, fork({wH(v3, rH(v3) * 10), {print(rH(v3)), countDown(cnt)}})]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2]
	File table: {}
	Heap: {1=20, 2=30, 3=4}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2]
	File table: {}
	Heap: {1=20, 2=30, 3=4}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 3
{
	Stack: [print(rH(v2)), countDown(cnt), fork({wH(v3, rH(v3) * 10), {print(rH(v3)), countDown(cnt)}})]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2]
	File table: {}
	Heap: {1=20, 2=30, 3=4}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2]
	File table: {}
	Heap: {1=20, 2=30, 3=4}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 3
{
	Stack: [print(rH(v2)), countDown(cnt), fork({wH(v3, rH(v3) * 10), {print(rH(v3)), countDown(cnt)}})]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2]
	File table: {}
	Heap: {1=20, 2=30, 3=4}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30]
	File table: {}
	Heap: {1=20, 2=30, 3=4}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 3
{
	Stack: [countDown(cnt), fork({wH(v3, rH(v3) * 10), {print(rH(v3)), countDown(cnt)}})]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30]
	File table: {}
	Heap: {1=20, 2=30, 3=4}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30]
	File table: {}
	Heap: {1=20, 2=30, 3=4}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 3
{
	Stack: [countDown(cnt), fork({wH(v3, rH(v3) * 10), {print(rH(v3)), countDown(cnt)}})]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30]
	File table: {}
	Heap: {1=20, 2=30, 3=4}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30, 3]
	File table: {}
	Heap: {1=20, 2=30, 3=4}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=1}
	Count Semaphore table: {}
};
Program 3
{
	Stack: [fork({wH(v3, rH(v3) * 10), {print(rH(v3)), countDown(cnt)}})]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30, 3]
	File table: {}
	Heap: {1=20, 2=30, 3=4}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=1}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30, 3]
	File table: {}
	Heap: {1=20, 2=30, 3=4}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=1}
	Count Semaphore table: {}
};
Program 3
{
	Stack: [fork({wH(v3, rH(v3) * 10), {print(rH(v3)), countDown(cnt)}})]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30, 3]
	File table: {}
	Heap: {1=20, 2=30, 3=4}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=1}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30, 3]
	File table: {}
	Heap: {1=20, 2=30, 3=4}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=1}
	Count Semaphore table: {}
};
Program 3
{
	Stack: []
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30, 3]
	File table: {}
	Heap: {1=20, 2=30, 3=4}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=1}
	Count Semaphore table: {}
};
Program 4
{
	Stack: [{wH(v3, rH(v3) * 10), {print(rH(v3)), countDown(cnt)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30, 3]
	File table: {}
	Heap: {1=20, 2=30, 3=4}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=1}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30, 3]
	File table: {}
	Heap: {1=20, 2=30, 3=4}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=1}
	Count Semaphore table: {}
};
Program 4
{
	Stack: [{wH(v3, rH(v3) * 10), {print(rH(v3)), countDown(cnt)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30, 3]
	File table: {}
	Heap: {1=20, 2=30, 3=4}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=1}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30, 3]
	File table: {}
	Heap: {1=20, 2=30, 3=4}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=1}
	Count Semaphore table: {}
};
Program 4
{
	Stack: [wH(v3, rH(v3) * 10), {print(rH(v3)), countDown(cnt)}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30, 3]
	File table: {}
	Heap: {1=20, 2=30, 3=4}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=1}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30, 3]
	File table: {}
	Heap: {1=20, 2=30, 3=4}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=1}
	Count Semaphore table: {}
};
Program 4
{
	Stack: [wH(v3, rH(v3) * 10), {print(rH(v3)), countDown(cnt)}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30, 3]
	File table: {}
	Heap: {1=20, 2=30, 3=4}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=1}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30, 3]
	File table: {}
	Heap: {1=20, 2=30, 3=40}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=1}
	Count Semaphore table: {}
};
Program 4
{
	Stack: [{print(rH(v3)), countDown(cnt)}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30, 3]
	File table: {}
	Heap: {1=20, 2=30, 3=40}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=1}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30, 3]
	File table: {}
	Heap: {1=20, 2=30, 3=40}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=1}
	Count Semaphore table: {}
};
Program 4
{
	Stack: [{print(rH(v3)), countDown(cnt)}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30, 3]
	File table: {}
	Heap: {1=20, 2=30, 3=40}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=1}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30, 3]
	File table: {}
	Heap: {1=20, 2=30, 3=40}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=1}
	Count Semaphore table: {}
};
Program 4
{
	Stack: [print(rH(v3)), countDown(cnt)]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30, 3]
	File table: {}
	Heap: {1=20, 2=30, 3=40}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=1}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30, 3]
	File table: {}
	Heap: {1=20, 2=30, 3=40}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=1}
	Count Semaphore table: {}
};
Program 4
{
	Stack: [print(rH(v3)), countDown(cnt)]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30, 3]
	File table: {}
	Heap: {1=20, 2=30, 3=40}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=1}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30, 3, 40]
	File table: {}
	Heap: {1=20, 2=30, 3=40}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=1}
	Count Semaphore table: {}
};
Program 4
{
	Stack: [countDown(cnt)]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30, 3, 40]
	File table: {}
	Heap: {1=20, 2=30, 3=40}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=1}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30, 3, 40]
	File table: {}
	Heap: {1=20, 2=30, 3=40}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=1}
	Count Semaphore table: {}
};
Program 4
{
	Stack: [countDown(cnt)]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30, 3, 40]
	File table: {}
	Heap: {1=20, 2=30, 3=40}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=1}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30, 3, 40, 4]
	File table: {}
	Heap: {1=20, 2=30, 3=40}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=0}
	Count Semaphore table: {}
};
Program 4
{
	Stack: []
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30, 3, 40, 4]
	File table: {}
	Heap: {1=20, 2=30, 3=40}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=0}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30, 3, 40, 4]
	File table: {}
	Heap: {1=20, 2=30, 3=40}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=0}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [{print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30, 3, 40, 4]
	File table: {}
	Heap: {1=20, 2=30, 3=40}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=0}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [{print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30, 3, 40, 4]
	File table: {}
	Heap: {1=20, 2=30, 3=40}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=0}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [print(100), {countDown(cnt), print(100)}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30, 3, 40, 4]
	File table: {}
	Heap: {1=20, 2=30, 3=40}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=0}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [print(100), {countDown(cnt), print(100)}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30, 3, 40, 4]
	File table: {}
	Heap: {1=20, 2=30, 3=40}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=0}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [{countDown(cnt), print(100)}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30, 3, 40, 4, 100]
	File table: {}
	Heap: {1=20, 2=30, 3=40}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=0}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [{countDown(cnt), print(100)}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30, 3, 40, 4, 100]
	File table: {}
	Heap: {1=20, 2=30, 3=40}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=0}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [countDown(cnt), print(100)]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30, 3, 40, 4, 100]
	File table: {}
	Heap: {1=20, 2=30, 3=40}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=0}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [countDown(cnt), print(100)]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30, 3, 40, 4, 100]
	File table: {}
	Heap: {1=20, 2=30, 3=40}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=0}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [print(100)]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30, 3, 40, 4, 100, 1]
	File table: {}
	Heap: {1=20, 2=30, 3=40}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=0}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [print(100)]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30, 3, 40, 4, 100, 1]
	File table: {}
	Heap: {1=20, 2=30, 3=40}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=0}
	Count Semaphore table: {}
};
Program 1
{
	Stack: []
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30, 3, 40, 4, 100, 1, 100]
	File table: {}
	Heap: {1=20, 2=30, 3=40}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=0}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [{Ref(int) v1, {Ref(int) v2, {Ref(int) v3, {int cnt, {new(v1,2), {new(v2,3), {new(v3,4), {newLatch(cnt, rH(v2)), {fork({{wH(v1, rH(v1) * 10), {print(rH(v1)), countDown(cnt)}}, fork({{wH(v2, rH(v2) * 10), {print(rH(v2)), countDown(cnt)}}, fork({wH(v3, rH(v3) * 10), {print(rH(v3)), countDown(cnt)}})})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}}}}}}}}]
	Symbol Table: {}
	Output: []
	File table: {}
	Heap: {}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [Ref(int) v1, {Ref(int) v2, {Ref(int) v3, {int cnt, {new(v1,2), {new(v2,3), {new(v3,4), {newLatch(cnt, rH(v2)), {fork({{wH(v1, rH(v1) * 10), {print(rH(v1)), countDown(cnt)}}, fork({{wH(v2, rH(v2) * 10), {print(rH(v2)), countDown(cnt)}}, fork({wH(v3, rH(v3) * 10), {print(rH(v3)), countDown(cnt)}})})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}}}}}}}]
	Symbol Table: {}
	Output: []
	File table: {}
	Heap: {}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [Ref(int) v1, {Ref(int) v2, {Ref(int) v3, {int cnt, {new(v1,2), {new(v2,3), {new(v3,4), {newLatch(cnt, rH(v2)), {fork({{wH(v1, rH(v1) * 10), {print(rH(v1)), countDown(cnt)}}, fork({{wH(v2, rH(v2) * 10), {print(rH(v2)), countDown(cnt)}}, fork({wH(v3, rH(v3) * 10), {print(rH(v3)), countDown(cnt)}})})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}}}}}}}]
	Symbol Table: {}
	Output: []
	File table: {}
	Heap: {}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [{Ref(int) v2, {Ref(int) v3, {int cnt, {new(v1,2), {new(v2,3), {new(v3,4), {newLatch(cnt, rH(v2)), {fork({{wH(v1, rH(v1) * 10), {print(rH(v1)), countDown(cnt)}}, fork({{wH(v2, rH(v2) * 10), {print(rH(v2)), countDown(cnt)}}, fork({wH(v3, rH(v3) * 10), {print(rH(v3)), countDown(cnt)}})})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}}}}}}}]
	Symbol Table: {v1=RefValue(0, int)}
	Output: []
	File table: {}
	Heap: {}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [{Ref(int) v2, {Ref(int) v3, {int cnt, {new(v1,2), {new(v2,3), {new(v3,4), {newLatch(cnt, rH(v2)), {fork({{wH(v1, rH(v1) * 10), {print(rH(v1)), countDown(cnt)}}, fork({{wH(v2, rH(v2) * 10), {print(rH(v2)), countDown(cnt)}}, fork({wH(v3, rH(v3) * 10), {print(rH(v3)), countDown(cnt)}})})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}}}}}}}]
	Symbol Table: {v1=RefValue(0, int)}
	Output: []
	File table: {}
	Heap: {}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [Ref(int) v2, {Ref(int) v3, {int cnt, {new(v1,2), {new(v2,3), {new(v3,4), {newLatch(cnt, rH(v2)), {fork({{wH(v1, rH(v1) * 10), {print(rH(v1)), countDown(cnt)}}, fork({{wH(v2, rH(v2) * 10), {print(rH(v2)), countDown(cnt)}}, fork({wH(v3, rH(v3) * 10), {print(rH(v3)), countDown(cnt)}})})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}}}}}}]
	Symbol Table: {v1=RefValue(0, int)}
	Output: []
	File table: {}
	Heap: {}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [Ref(int) v2, {Ref(int) v3, {int cnt, {new(v1,2), {new(v2,3), {new(v3,4), {newLatch(cnt, rH(v2)), {fork({{wH(v1, rH(v1) * 10), {print(rH(v1)), countDown(cnt)}}, fork({{wH(v2, rH(v2) * 10), {print(rH(v2)), countDown(cnt)}}, fork({wH(v3, rH(v3) * 10), {print(rH(v3)), countDown(cnt)}})})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}}}}}}]
	Symbol Table: {v1=RefValue(0, int)}
	Output: []
	File table: {}
	Heap: {}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [{Ref(int) v3, {int cnt, {new(v1,2), {new(v2,3), {new(v3,4), {newLatch(cnt, rH(v2)), {fork({{wH(v1, rH(v1) * 10), {print(rH(v1)), countDown(cnt)}}, fork({{wH(v2, rH(v2) * 10), {print(rH(v2)), countDown(cnt)}}, fork({wH(v3, rH(v3) * 10), {print(rH(v3)), countDown(cnt)}})})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}}}}}}]
	Symbol Table: {v1=RefValue(0, int), v2=RefValue(0, int)}
	Output: []
	File table: {}
	Heap: {}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [{Ref(int) v3, {int cnt, {new(v1,2), {new(v2,3), {new(v3,4), {newLatch(cnt, rH(v2)), {fork({{wH(v1, rH(v1) * 10), {print(rH(v1)), countDown(cnt)}}, fork({{wH(v2, rH(v2) * 10), {print(rH(v2)), countDown(cnt)}}, fork({wH(v3, rH(v3) * 10), {print(rH(v3)), countDown(cnt)}})})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}}}}}}]
	Symbol Table: {v1=RefValue(0, int), v2=RefValue(0, int)}
	Output: []
	File table: {}
	Heap: {}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [Ref(int) v3, {int cnt, {new(v1,2), {new(v2,3), {new(v3,4), {newLatch(cnt, rH(v2)), {fork({{wH(v1, rH(v1) * 10), {print(rH(v1)), countDown(cnt)}}, fork({{wH(v2, rH(v2) * 10), {print(rH(v2)), countDown(cnt)}}, fork({wH(v3, rH(v3) * 10), {print(rH(v3)), countDown(cnt)}})})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}}}}}]
	Symbol Table: {v1=RefValue(0, int), v2=RefValue(0, int)}
	Output: []
	File table: {}
	Heap: {}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [Ref(int) v3, {int cnt, {new(v1,2), {new(v2,3), {new(v3,4), {newLatch(cnt, rH(v2)), {fork({{wH(v1, rH(v1) * 10), {print(rH(v1)), countDown(cnt)}}, fork({{wH(v2, rH(v2) * 10), {print(rH(v2)), countDown(cnt)}}, fork({wH(v3, rH(v3) * 10), {print(rH(v3)), countDown(cnt)}})})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}}}}}]
	Symbol Table: {v1=RefValue(0, int), v2=RefValue(0, int)}
	Output: []
	File table: {}
	Heap: {}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [{int cnt, {new(v1,2), {new(v2,3), {new(v3,4), {newLatch(cnt, rH(v2)), {fork({{wH(v1, rH(v1) * 10), {print(rH(v1)), countDown(cnt)}}, fork({{wH(v2, rH(v2) * 10), {print(rH(v2)), countDown(cnt)}}, fork({wH(v3, rH(v3) * 10), {print(rH(v3)), countDown(cnt)}})})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}}}}}]
	Symbol Table: {v1=RefValue(0, int), v2=RefValue(0, int), v3=RefValue(0, int)}
	Output: []
	File table: {}
	Heap: {}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [{int cnt, {new(v1,2), {new(v2,3), {new(v3,4), {newLatch(cnt, rH(v2)), {fork({{wH(v1, rH(v1) * 10), {print(rH(v1)), countDown(cnt)}}, fork({{wH(v2, rH(v2) * 10), {print(rH(v2)), countDown(cnt)}}, fork({wH(v3, rH(v3) * 10), {print(rH(v3)), countDown(cnt)}})})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}}}}}]
	Symbol Table: {v1=RefValue(0, int), v2=RefValue(0, int), v3=RefValue(0, int)}
	Output: []
	File table: {}
	Heap: {}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [int cnt, {new(v1,2), {new(v2,3), {new(v3,4), {newLatch(cnt, rH(v2)), {fork({{wH(v1, rH(v1) * 10), {print(rH(v1)), countDown(cnt)}}, fork({{wH(v2, rH(v2) * 10), {print(rH(v2)), countDown(cnt)}}, fork({wH(v3, rH(v3) * 10), {print(rH(v3)), countDown(cnt)}})})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}}}}]
	Symbol Table: {v1=RefValue(0, int), v2=RefValue(0, int), v3=RefValue(0, int)}
	Output: []
	File table: {}
	Heap: {}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [int cnt, {new(v1,2), {new(v2,3), {new(v3,4), {newLatch(cnt, rH(v2)), {fork({{wH(v1, rH(v1) * 10), {print(rH(v1)), countDown(cnt)}}, fork({{wH(v2, rH(v2) * 10), {print(rH(v2)), countDown(cnt)}}, fork({wH(v3, rH(v3) * 10), {print(rH(v3)), countDown(cnt)}})})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}}}}]
	Symbol Table: {v1=RefValue(0, int), v2=RefValue(0, int), v3=RefValue(0, int)}
	Output: []
	File table: {}
	Heap: {}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [{new(v1,2), {new(v2,3), {new(v3,4), {newLatch(cnt, rH(v2)), {fork({{wH(v1, rH(v1) * 10), {print(rH(v1)), countDown(cnt)}}, fork({{wH(v2, rH(v2) * 10), {print(rH(v2)), countDown(cnt)}}, fork({wH(v3, rH(v3) * 10), {print(rH(v3)), countDown(cnt)}})})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}}}}]
	Symbol Table: {cnt=0, v1=RefValue(0, int), v2=RefValue(0, int), v3=RefValue(0, int)}
	Output: []
	File table: {}
	Heap: {}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [{new(v1,2), {new(v2,3), {new(v3,4), {newLatch(cnt, rH(v2)), {fork({{wH(v1, rH(v1) * 10), {print(rH(v1)), countDown(cnt)}}, fork({{wH(v2, rH(v2) * 10), {print(rH(v2)), countDown(cnt)}}, fork({wH(v3, rH(v3) * 10), {print(rH(v3)), countDown(cnt)}})})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}}}}]
	Symbol Table: {cnt=0, v1=RefValue(0, int), v2=RefValue(0, int), v3=RefValue(0, int)}
	Output: []
	File table: {}
	Heap: {}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [new(v1,2), {new(v2,3), {new(v3,4), {newLatch(cnt, rH(v2)), {fork({{wH(v1, rH(v1) * 10), {print(rH(v1)), countDown(cnt)}}, fork({{wH(v2, rH(v2) * 10), {print(rH(v2)), countDown(cnt)}}, fork({wH(v3, rH(v3) * 10), {print(rH(v3)), countDown(cnt)}})})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}}}]
	Symbol Table: {cnt=0, v1=RefValue(0, int), v2=RefValue(0, int), v3=RefValue(0, int)}
	Output: []
	File table: {}
	Heap: {}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [new(v1,2), {new(v2,3), {new(v3,4), {newLatch(cnt, rH(v2)), {fork({{wH(v1, rH(v1) * 10), {print(rH(v1)), countDown(cnt)}}, fork({{wH(v2, rH(v2) * 10), {print(rH(v2)), countDown(cnt)}}, fork({wH(v3, rH(v3) * 10), {print(rH(v3)), countDown(cnt)}})})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}}}]
	Symbol Table: {cnt=0, v1=RefValue(0, int), v2=RefValue(0, int), v3=RefValue(0, int)}
	Output: []
	File table: {}
	Heap: {}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [{new(v2,3), {new(v3,4), {newLatch(cnt, rH(v2)), {fork({{wH(v1, rH(v1) * 10), {print(rH(v1)), countDown(cnt)}}, fork({{wH(v2, rH(v2) * 10), {print(rH(v2)), countDown(cnt)}}, fork({wH(v3, rH(v3) * 10), {print(rH(v3)), countDown(cnt)}})})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}}}]
	Symbol Table: {cnt=0, v1=RefValue(1, int), v2=RefValue(0, int), v3=RefValue(0, int)}
	Output: []
	File table: {}
	Heap: {1=2}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [{new(v2,3), {new(v3,4), {newLatch(cnt, rH(v2)), {fork({{wH(v1, rH(v1) * 10), {print(rH(v1)), countDown(cnt)}}, fork({{wH(v2, rH(v2) * 10), {print(rH(v2)), countDown(cnt)}}, fork({wH(v3, rH(v3) * 10), {print(rH(v3)), countDown(cnt)}})})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}}}]
	Symbol Table: {cnt=0, v1=RefValue(1, int), v2=RefValue(0, int), v3=RefValue(0, int)}
	Output: []
	File table: {}
	Heap: {1=2}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [new(v2,3), {new(v3,4), {newLatch(cnt, rH(v2)), {fork({{wH(v1, rH(v1) * 10), {print(rH(v1)), countDown(cnt)}}, fork({{wH(v2, rH(v2) * 10), {print(rH(v2)), countDown(cnt)}}, fork({wH(v3, rH(v3) * 10), {print(rH(v3)), countDown(cnt)}})})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}}]
	Symbol Table: {cnt=0, v1=RefValue(1, int), v2=RefValue(0, int), v3=RefValue(0, int)}
	Output: []
	File table: {}
	Heap: {1=2}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [new(v2,3), {new(v3,4), {newLatch(cnt, rH(v2)), {fork({{wH(v1, rH(v1) * 10), {print(rH(v1)), countDown(cnt)}}, fork({{wH(v2, rH(v2) * 10), {print(rH(v2)), countDown(cnt)}}, fork({wH(v3, rH(v3) * 10), {print(rH(v3)), countDown(cnt)}})})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}}]
	Symbol Table: {cnt=0, v1=RefValue(1, int), v2=RefValue(0, int), v3=RefValue(0, int)}
	Output: []
	File table: {}
	Heap: {1=2}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [{new(v3,4), {newLatch(cnt, rH(v2)), {fork({{wH(v1, rH(v1) * 10), {print(rH(v1)), countDown(cnt)}}, fork({{wH(v2, rH(v2) * 10), {print(rH(v2)), countDown(cnt)}}, fork({wH(v3, rH(v3) * 10), {print(rH(v3)), countDown(cnt)}})})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}}]
	Symbol Table: {cnt=0, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(0, int)}
	Output: []
	File table: {}
	Heap: {1=2, 2=3}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [{new(v3,4), {newLatch(cnt, rH(v2)), {fork({{wH(v1, rH(v1) * 10), {print(rH(v1)), countDown(cnt)}}, fork({{wH(v2, rH(v2) * 10), {print(rH(v2)), countDown(cnt)}}, fork({wH(v3, rH(v3) * 10), {print(rH(v3)), countDown(cnt)}})})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}}]
	Symbol Table: {cnt=0, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(0, int)}
	Output: []
	File table: {}
	Heap: {1=2, 2=3}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [new(v3,4), {newLatch(cnt, rH(v2)), {fork({{wH(v1, rH(v1) * 10), {print(rH(v1)), countDown(cnt)}}, fork({{wH(v2, rH(v2) * 10), {print(rH(v2)), countDown(cnt)}}, fork({wH(v3, rH(v3) * 10), {print(rH(v3)), countDown(cnt)}})})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}]
	Symbol Table: {cnt=0, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(0, int)}
	Output: []
	File table: {}
	Heap: {1=2, 2=3}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [new(v3,4), {newLatch(cnt, rH(v2)), {fork({{wH(v1, rH(v1) * 10), {print(rH(v1)), countDown(cnt)}}, fork({{wH(v2, rH(v2) * 10), {print(rH(v2)), countDown(cnt)}}, fork({wH(v3, rH(v3) * 10), {print(rH(v3)), countDown(cnt)}})})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}]
	Symbol Table: {cnt=0, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(0, int)}
	Output: []
	File table: {}
	Heap: {1=2, 2=3}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [{newLatch(cnt, rH(v2)), {fork({{wH(v1, rH(v1) * 10), {print(rH(v1)), countDown(cnt)}}, fork({{wH(v2, rH(v2) * 10), {print(rH(v2)), countDown(cnt)}}, fork({wH(v3, rH(v3) * 10), {print(rH(v3)), countDown(cnt)}})})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}]
	Symbol Table: {cnt=0, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: []
	File table: {}
	Heap: {1=2, 2=3, 3=4}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [{newLatch(cnt, rH(v2)), {fork({{wH(v1, rH(v1) * 10), {print(rH(v1)), countDown(cnt)}}, fork({{wH(v2, rH(v2) * 10), {print(rH(v2)), countDown(cnt)}}, fork({wH(v3, rH(v3) * 10), {print(rH(v3)), countDown(cnt)}})})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}}]
	Symbol Table: {cnt=0, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: []
	File table: {}
	Heap: {1=2, 2=3, 3=4}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [newLatch(cnt, rH(v2)), {fork({{wH(v1, rH(v1) * 10), {print(rH(v1)), countDown(cnt)}}, fork({{wH(v2, rH(v2) * 10), {print(rH(v2)), countDown(cnt)}}, fork({wH(v3, rH(v3) * 10), {print(rH(v3)), countDown(cnt)}})})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}]
	Symbol Table: {cnt=0, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: []
	File table: {}
	Heap: {1=2, 2=3, 3=4}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [newLatch(cnt, rH(v2)), {fork({{wH(v1, rH(v1) * 10), {print(rH(v1)), countDown(cnt)}}, fork({{wH(v2, rH(v2) * 10), {print(rH(v2)), countDown(cnt)}}, fork({wH(v3, rH(v3) * 10), {print(rH(v3)), countDown(cnt)}})})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}]
	Symbol Table: {cnt=0, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: []
	File table: {}
	Heap: {1=2, 2=3, 3=4}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [{fork({{wH(v1, rH(v1) * 10), {print(rH(v1)), countDown(cnt)}}, fork({{wH(v2, rH(v2) * 10), {print(rH(v2)), countDown(cnt)}}, fork({wH(v3, rH(v3) * 10), {print(rH(v3)), countDown(cnt)}})})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: []
	File table: {}
	Heap: {1=2, 2=3, 3=4}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=3}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [{fork({{wH(v1, rH(v1) * 10), {print(rH(v1)), countDown(cnt)}}, fork({{wH(v2, rH(v2) * 10), {print(rH(v2)), countDown(cnt)}}, fork({wH(v3, rH(v3) * 10), {print(rH(v3)), countDown(cnt)}})})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: []
	File table: {}
	Heap: {1=2, 2=3, 3=4}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=3}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [fork({{wH(v1, rH(v1) * 10), {print(rH(v1)), countDown(cnt)}}, fork({{wH(v2, rH(v2) * 10), {print(rH(v2)), countDown(cnt)}}, fork({wH(v3, rH(v3) * 10), {print(rH(v3)), countDown(cnt)}})})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: []
	File table: {}
	Heap: {1=2, 2=3, 3=4}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=3}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [fork({{wH(v1, rH(v1) * 10), {print(rH(v1)), countDown(cnt)}}, fork({{wH(v2, rH(v2) * 10), {print(rH(v2)), countDown(cnt)}}, fork({wH(v3, rH(v3) * 10), {print(rH(v3)), countDown(cnt)}})})}), {await(cnt), {print(100), {countDown(cnt), print(100)}}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: []
	File table: {}
	Heap: {1=2, 2=3, 3=4}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=3}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [{await(cnt), {print(100), {countDown(cnt), print(100)}}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: []
	File table: {}
	Heap: {1=2, 2=3, 3=4}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=3}
	Count Semaphore table: {}
};
Program 2
{
	Stack: [{{wH(v1, rH(v1) * 10), {print(rH(v1)), countDown(cnt)}}, fork({{wH(v2, rH(v2) * 10), {print(rH(v2)), countDown(cnt)}}, fork({wH(v3, rH(v3) * 10), {print(rH(v3)), countDown(cnt)}})})}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: []
	File table: {}
	Heap: {1=2, 2=3, 3=4}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=3}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [{await(cnt), {print(100), {countDown(cnt), print(100)}}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: []
	File table: {}
	Heap: {1=2, 2=3, 3=4}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=3}
	Count Semaphore table: {}
};
Program 2
{
	Stack: [{{wH(v1, rH(v1) * 10), {print(rH(v1)), countDown(cnt)}}, fork({{wH(v2, rH(v2) * 10), {print(rH(v2)), countDown(cnt)}}, fork({wH(v3, rH(v3) * 10), {print(rH(v3)), countDown(cnt)}})})}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: []
	File table: {}
	Heap: {1=2, 2=3, 3=4}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=3}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: []
	File table: {}
	Heap: {1=2, 2=3, 3=4}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=3}
	Count Semaphore table: {}
};
Program 2
{
	Stack: [{wH(v1, rH(v1) * 10), {print(rH(v1)), countDown(cnt)}}, fork({{wH(v2, rH(v2) * 10), {print(rH(v2)), countDown(cnt)}}, fork({wH(v3, rH(v3) * 10), {print(rH(v3)), countDown(cnt)}})})]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: []
	File table: {}
	Heap: {1=2, 2=3, 3=4}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=3}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: []
	File table: {}
	Heap: {1=2, 2=3, 3=4}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=3}
	Count Semaphore table: {}
};
Program 2
{
	Stack: [{wH(v1, rH(v1) * 10), {print(rH(v1)), countDown(cnt)}}, fork({{wH(v2, rH(v2) * 10), {print(rH(v2)), countDown(cnt)}}, fork({wH(v3, rH(v3) * 10), {print(rH(v3)), countDown(cnt)}})})]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: []
	File table: {}
	Heap: {1=2, 2=3, 3=4}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=3}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: []
	File table: {}
	Heap: {1=2, 2=3, 3=4}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=3}
	Count Semaphore table: {}
};
Program 2
{
	Stack: [wH(v1, rH(v1) * 10), {print(rH(v1)), countDown(cnt)}, fork({{wH(v2, rH(v2) * 10), {print(rH(v2)), countDown(cnt)}}, fork({wH(v3, rH(v3) * 10), {print(rH(v3)), countDown(cnt)}})})]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: []
	File table: {}
	Heap: {1=2, 2=3, 3=4}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=3}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: []
	File table: {}
	Heap: {1=2, 2=3, 3=4}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=3}
	Count Semaphore table: {}
};
Program 2
{
	Stack: [wH(v1, rH(v1) * 10), {print(rH(v1)), countDown(cnt)}, fork({{wH(v2, rH(v2) * 10), {print(rH(v2)), countDown(cnt)}}, fork({wH(v3, rH(v3) * 10), {print(rH(v3)), countDown(cnt)}})})]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: []
	File table: {}
	Heap: {1=2, 2=3, 3=4}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=3}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: []
	File table: {}
	Heap: {1=20, 2=3, 3=4}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=3}
	Count Semaphore table: {}
};
Program 2
{
	Stack: [{print(rH(v1)), countDown(cnt)}, fork({{wH(v2, rH(v2) * 10), {print(rH(v2)), countDown(cnt)}}, fork({wH(v3, rH(v3) * 10), {print(rH(v3)), countDown(cnt)}})})]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: []
	File table: {}
	Heap: {1=20, 2=3, 3=4}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=3}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: []
	File table: {}
	Heap: {1=20, 2=3, 3=4}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=3}
	Count Semaphore table: {}
};
Program 2
{
	Stack: [{print(rH(v1)), countDown(cnt)}, fork({{wH(v2, rH(v2) * 10), {print(rH(v2)), countDown(cnt)}}, fork({wH(v3, rH(v3) * 10), {print(rH(v3)), countDown(cnt)}})})]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: []
	File table: {}
	Heap: {1=20, 2=3, 3=4}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=3}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: []
	File table: {}
	Heap: {1=20, 2=3, 3=4}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=3}
	Count Semaphore table: {}
};
Program 2
{
	Stack: [print(rH(v1)), countDown(cnt), fork({{wH(v2, rH(v2) * 10), {print(rH(v2)), countDown(cnt)}}, fork({wH(v3, rH(v3) * 10), {print(rH(v3)), countDown(cnt)}})})]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: []
	File table: {}
	Heap: {1=20, 2=3, 3=4}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=3}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: []
	File table: {}
	Heap: {1=20, 2=3, 3=4}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=3}
	Count Semaphore table: {}
};
Program 2
{
	Stack: [print(rH(v1)), countDown(cnt), fork({{wH(v2, rH(v2) * 10), {print(rH(v2)), countDown(cnt)}}, fork({wH(v3, rH(v3) * 10), {print(rH(v3)), countDown(cnt)}})})]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: []
	File table: {}
	Heap: {1=20, 2=3, 3=4}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=3}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20]
	File table: {}
	Heap: {1=20, 2=3, 3=4}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=3}
	Count Semaphore table: {}
};
Program 2
{
	Stack: [countDown(cnt), fork({{wH(v2, rH(v2) * 10), {print(rH(v2)), countDown(cnt)}}, fork({wH(v3, rH(v3) * 10), {print(rH(v3)), countDown(cnt)}})})]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20]
	File table: {}
	Heap: {1=20, 2=3, 3=4}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=3}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20]
	File table: {}
	Heap: {1=20, 2=3, 3=4}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=3}
	Count Semaphore table: {}
};
Program 2
{
	Stack: [countDown(cnt), fork({{wH(v2, rH(v2) * 10), {print(rH(v2)), countDown(cnt)}}, fork({wH(v3, rH(v3) * 10), {print(rH(v3)), countDown(cnt)}})})]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20]
	File table: {}
	Heap: {1=20, 2=3, 3=4}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=3}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2]
	File table: {}
	Heap: {1=20, 2=3, 3=4}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 2
{
	Stack: [fork({{wH(v2, rH(v2) * 10), {print(rH(v2)), countDown(cnt)}}, fork({wH(v3, rH(v3) * 10), {print(rH(v3)), countDown(cnt)}})})]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2]
	File table: {}
	Heap: {1=20, 2=3, 3=4}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2]
	File table: {}
	Heap: {1=20, 2=3, 3=4}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 2
{
	Stack: [fork({{wH(v2, rH(v2) * 10), {print(rH(v2)), countDown(cnt)}}, fork({wH(v3, rH(v3) * 10), {print(rH(v3)), countDown(cnt)}})})]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2]
	File table: {}
	Heap: {1=20, 2=3, 3=4}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2]
	File table: {}
	Heap: {1=20, 2=3, 3=4}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 2
{
	Stack: []
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2]
	File table: {}
	Heap: {1=20, 2=3, 3=4}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 3
{
	Stack: [{{wH(v2, rH(v2) * 10), {print(rH(v2)), countDown(cnt)}}, fork({wH(v3, rH(v3) * 10), {print(rH(v3)), countDown(cnt)}})}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2]
	File table: {}
	Heap: {1=20, 2=3, 3=4}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2]
	File table: {}
	Heap: {1=20, 2=3, 3=4}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 3
{
	Stack: [{{wH(v2, rH(v2) * 10), {print(rH(v2)), countDown(cnt)}}, fork({wH(v3, rH(v3) * 10), {print(rH(v3)), countDown(cnt)}})}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2]
	File table: {}
	Heap: {1=20, 2=3, 3=4}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2]
	File table: {}
	Heap: {1=20, 2=3, 3=4}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 3
{
	Stack: [{wH(v2, rH(v2) * 10), {print(rH(v2)), countDown(cnt)}}, fork({wH(v3, rH(v3) * 10), {print(rH(v3)), countDown(cnt)}})]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2]
	File table: {}
	Heap: {1=20, 2=3, 3=4}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2]
	File table: {}
	Heap: {1=20, 2=3, 3=4}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 3
{
	Stack: [{wH(v2, rH(v2) * 10), {print(rH(v2)), countDown(cnt)}}, fork({wH(v3, rH(v3) * 10), {print(rH(v3)), countDown(cnt)}})]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2]
	File table: {}
	Heap: {1=20, 2=3, 3=4}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2]
	File table: {}
	Heap: {1=20, 2=3, 3=4}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 3
{
	Stack: [wH(v2, rH(v2) * 10), {print(rH(v2)), countDown(cnt)}, fork({wH(v3, rH(v3) * 10), {print(rH(v3)), countDown(cnt)}})]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2]
	File table: {}
	Heap: {1=20, 2=3, 3=4}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2]
	File table: {}
	Heap: {1=20, 2=3, 3=4}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 3
{
	Stack: [wH(v2, rH(v2) * 10), {print(rH(v2)), countDown(cnt)}, fork({wH(v3, rH(v3) * 10), {print(rH(v3)), countDown(cnt)}})]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2]
	File table: {}
	Heap: {1=20, 2=3, 3=4}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2]
	File table: {}
	Heap: {1=20, 2=30, 3=4}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 3
{
	Stack: [{print(rH(v2)), countDown(cnt)}, fork({wH(v3, rH(v3) * 10), {print(rH(v3)), countDown(cnt)}})]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2]
	File table: {}
	Heap: {1=20, 2=30, 3=4}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2]
	File table: {}
	Heap: {1=20, 2=30, 3=4}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 3
{
	Stack: [{print(rH(v2)), countDown(cnt)}, fork({wH(v3, rH(v3) * 10), {print(rH(v3)), countDown(cnt)}})]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2]
	File table: {}
	Heap: {1=20, 2=30, 3=4}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2]
	File table: {}
	Heap: {1=20, 2=30, 3=4}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 3
{
	Stack: [print(rH(v2)), countDown(cnt), fork({wH(v3, rH(v3) * 10), {print(rH(v3)), countDown(cnt)}})]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2]
	File table: {}
	Heap: {1=20, 2=30, 3=4}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2]
	File table: {}
	Heap: {1=20, 2=30, 3=4}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 3
{
	Stack: [print(rH(v2)), countDown(cnt), fork({wH(v3, rH(v3) * 10), {print(rH(v3)), countDown(cnt)}})]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2]
	File table: {}
	Heap: {1=20, 2=30, 3=4}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30]
	File table: {}
	Heap: {1=20, 2=30, 3=4}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 3
{
	Stack: [countDown(cnt), fork({wH(v3, rH(v3) * 10), {print(rH(v3)), countDown(cnt)}})]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30]
	File table: {}
	Heap: {1=20, 2=30, 3=4}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30]
	File table: {}
	Heap: {1=20, 2=30, 3=4}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 3
{
	Stack: [countDown(cnt), fork({wH(v3, rH(v3) * 10), {print(rH(v3)), countDown(cnt)}})]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30]
	File table: {}
	Heap: {1=20, 2=30, 3=4}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=2}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30, 3]
	File table: {}
	Heap: {1=20, 2=30, 3=4}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=1}
	Count Semaphore table: {}
};
Program 3
{
	Stack: [fork({wH(v3, rH(v3) * 10), {print(rH(v3)), countDown(cnt)}})]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30, 3]
	File table: {}
	Heap: {1=20, 2=30, 3=4}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=1}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30, 3]
	File table: {}
	Heap: {1=20, 2=30, 3=4}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=1}
	Count Semaphore table: {}
};
Program 3
{
	Stack: [fork({wH(v3, rH(v3) * 10), {print(rH(v3)), countDown(cnt)}})]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30, 3]
	File table: {}
	Heap: {1=20, 2=30, 3=4}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=1}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30, 3]
	File table: {}
	Heap: {1=20, 2=30, 3=4}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=1}
	Count Semaphore table: {}
};
Program 3
{
	Stack: []
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30, 3]
	File table: {}
	Heap: {1=20, 2=30, 3=4}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=1}
	Count Semaphore table: {}
};
Program 4
{
	Stack: [{wH(v3, rH(v3) * 10), {print(rH(v3)), countDown(cnt)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30, 3]
	File table: {}
	Heap: {1=20, 2=30, 3=4}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=1}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30, 3]
	File table: {}
	Heap: {1=20, 2=30, 3=4}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=1}
	Count Semaphore table: {}
};
Program 4
{
	Stack: [{wH(v3, rH(v3) * 10), {print(rH(v3)), countDown(cnt)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30, 3]
	File table: {}
	Heap: {1=20, 2=30, 3=4}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=1}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30, 3]
	File table: {}
	Heap: {1=20, 2=30, 3=4}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=1}
	Count Semaphore table: {}
};
Program 4
{
	Stack: [wH(v3, rH(v3) * 10), {print(rH(v3)), countDown(cnt)}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30, 3]
	File table: {}
	Heap: {1=20, 2=30, 3=4}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=1}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30, 3]
	File table: {}
	Heap: {1=20, 2=30, 3=4}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=1}
	Count Semaphore table: {}
};
Program 4
{
	Stack: [wH(v3, rH(v3) * 10), {print(rH(v3)), countDown(cnt)}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30, 3]
	File table: {}
	Heap: {1=20, 2=30, 3=4}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=1}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30, 3]
	File table: {}
	Heap: {1=20, 2=30, 3=40}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=1}
	Count Semaphore table: {}
};
Program 4
{
	Stack: [{print(rH(v3)), countDown(cnt)}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30, 3]
	File table: {}
	Heap: {1=20, 2=30, 3=40}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=1}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30, 3]
	File table: {}
	Heap: {1=20, 2=30, 3=40}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=1}
	Count Semaphore table: {}
};
Program 4
{
	Stack: [{print(rH(v3)), countDown(cnt)}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30, 3]
	File table: {}
	Heap: {1=20, 2=30, 3=40}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=1}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30, 3]
	File table: {}
	Heap: {1=20, 2=30, 3=40}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=1}
	Count Semaphore table: {}
};
Program 4
{
	Stack: [print(rH(v3)), countDown(cnt)]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30, 3]
	File table: {}
	Heap: {1=20, 2=30, 3=40}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=1}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30, 3]
	File table: {}
	Heap: {1=20, 2=30, 3=40}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=1}
	Count Semaphore table: {}
};
Program 4
{
	Stack: [print(rH(v3)), countDown(cnt)]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30, 3]
	File table: {}
	Heap: {1=20, 2=30, 3=40}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=1}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30, 3, 40]
	File table: {}
	Heap: {1=20, 2=30, 3=40}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=1}
	Count Semaphore table: {}
};
Program 4
{
	Stack: [countDown(cnt)]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30, 3, 40]
	File table: {}
	Heap: {1=20, 2=30, 3=40}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=1}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30, 3, 40]
	File table: {}
	Heap: {1=20, 2=30, 3=40}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=1}
	Count Semaphore table: {}
};
Program 4
{
	Stack: [countDown(cnt)]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30, 3, 40]
	File table: {}
	Heap: {1=20, 2=30, 3=40}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=1}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30, 3, 40, 4]
	File table: {}
	Heap: {1=20, 2=30, 3=40}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=0}
	Count Semaphore table: {}
};
Program 4
{
	Stack: []
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30, 3, 40, 4]
	File table: {}
	Heap: {1=20, 2=30, 3=40}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=0}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [await(cnt), {print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30, 3, 40, 4]
	File table: {}
	Heap: {1=20, 2=30, 3=40}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=0}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [{print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30, 3, 40, 4]
	File table: {}
	Heap: {1=20, 2=30, 3=40}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=0}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [{print(100), {countDown(cnt), print(100)}}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30, 3, 40, 4]
	File table: {}
	Heap: {1=20, 2=30, 3=40}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=0}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [print(100), {countDown(cnt), print(100)}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30, 3, 40, 4]
	File table: {}
	Heap: {1=20, 2=30, 3=40}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=0}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [print(100), {countDown(cnt), print(100)}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30, 3, 40, 4]
	File table: {}
	Heap: {1=20, 2=30, 3=40}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=0}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [{countDown(cnt), print(100)}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30, 3, 40, 4, 100]
	File table: {}
	Heap: {1=20, 2=30, 3=40}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=0}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [{countDown(cnt), print(100)}]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30, 3, 40, 4, 100]
	File table: {}
	Heap: {1=20, 2=30, 3=40}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=0}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [countDown(cnt), print(100)]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30, 3, 40, 4, 100]
	File table: {}
	Heap: {1=20, 2=30, 3=40}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=0}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [countDown(cnt), print(100)]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30, 3, 40, 4, 100]
	File table: {}
	Heap: {1=20, 2=30, 3=40}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=0}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [print(100)]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30, 3, 40, 4, 100, 1]
	File table: {}
	Heap: {1=20, 2=30, 3=40}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=0}
	Count Semaphore table: {}
};
Program 1
{
	Stack: [print(100)]
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30, 3, 40, 4, 100, 1]
	File table: {}
	Heap: {1=20, 2=30, 3=40}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=0}
	Count Semaphore table: {}
};
Program 1
{
	Stack: []
	Symbol Table: {cnt=1, v1=RefValue(1, int), v2=RefValue(2, int), v3=RefValue(3, int)}
	Output: [20, 2, 30, 3, 40, 4, 100, 1, 100]
	File table: {}
	Heap: {1=20, 2=30, 3=40}
	Procedures: {}
	Lock table: {}
	Barrier table: {}
	Latch table: {1=0}
	Count Semaphore table: {}
};
